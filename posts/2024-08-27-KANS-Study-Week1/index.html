<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[KANS 3기] 컨테이너 격리 | Sweet Little Bird</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="[KANS 3기] 컨테이너 격리">
<meta property="og:locale" content="ko">
<meta name="description" content="지난 테라폼 스터디에 이어 이번 주 부터 KANS 스터디를 시작하게 되었습니다! KANS는 Kubernetes Advanced Networking Study의 줄임말로 쿠버네티스 네트워킹에 대한 심도있게 공부하는 스터디입니다. 이번 스터디도 과제할 걱정도 되지만 재미있을것 같아 기대됩니다.">
<meta property="og:description" content="지난 테라폼 스터디에 이어 이번 주 부터 KANS 스터디를 시작하게 되었습니다! KANS는 Kubernetes Advanced Networking Study의 줄임말로 쿠버네티스 네트워킹에 대한 심도있게 공부하는 스터디입니다. 이번 스터디도 과제할 걱정도 되지만 재미있을것 같아 기대됩니다.">
<link rel="canonical" href="https://sweetlittlebird.github.io/posts/2024-08-27-KANS-Study-Week1/">
<meta property="og:url" content="https://sweetlittlebird.github.io/posts/2024-08-27-KANS-Study-Week1/">
<meta property="og:site_name" content="Sweet Little Bird">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-08-27T22:50:18+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="[KANS 3기] 컨테이너 격리">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-27T22:50:18+09:00","datePublished":"2024-08-27T22:50:18+09:00","description":"지난 테라폼 스터디에 이어 이번 주 부터 KANS 스터디를 시작하게 되었습니다! KANS는 Kubernetes Advanced Networking Study의 줄임말로 쿠버네티스 네트워킹에 대한 심도있게 공부하는 스터디입니다. 이번 스터디도 과제할 걱정도 되지만 재미있을것 같아 기대됩니다.","headline":"[KANS 3기] 컨테이너 격리","mainEntityOfPage":{"@type":"WebPage","@id":"https://sweetlittlebird.github.io/posts/2024-08-27-KANS-Study-Week1/"},"url":"https://sweetlittlebird.github.io/posts/2024-08-27-KANS-Study-Week1/"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/dist/main.min.css">
  <link rel="stylesheet" href="/assets/dist/main_dark.min.css" media="(prefers-color-scheme: dark)">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pretendard/1.3.9/static/pretendard.css" integrity="sha512-NzqTHTrO48HsIamogmIaVhTXoSgRF24Cn+ynrNYrFuKrY0AdDbmcNieiOHsQARS/r0Gax9VwV3/rVMHs3ipUlg==" crossorigin="anonymous" referrerpolicy="no-referrer">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!--  <link href="https://fonts.googleapis.com/css2?family=Elsie+Swash+Caps:wght@400;900&display=swap" rel="stylesheet">-->
  <link href="https://fonts.googleapis.com/css2?family=Elsie+Swash+Caps:wght@400;900&amp;family=Milonga&amp;display=swap" rel="stylesheet">

  <link rel="shortcut icon" href="/assets/favicon/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/favicon/favicon.ico" type="image/x-icon">
<link type="application/atom+xml" rel="alternate" href="https://sweetlittlebird.github.io/feed.xml" title="Sweet Little Bird">
</head>
<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/">Sweet Little Bird</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
<a class="page-link" href="/about/">소개</a><a class="page-link" href="/posts/">글 목록</a>
</div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">[KANS 3기] 컨테이너 격리</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-08-27T22:50:18+09:00" itemprop="datePublished">2024년 08월 27일에 작성
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div class="table-of-content">
      <header>목차</header>
      <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0">들어가며</a></li>
<li class="toc-entry toc-h2">
<a href="#%EB%8F%84%EC%BB%A4-%EC%86%8C%EA%B0%9C">도커 소개</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%EB%8F%84%EC%BB%A4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">도커란 무엇인가?</a></li>
<li class="toc-entry toc-h3"><a href="#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0">컨테이너와 가상 머신</a></li>
<li class="toc-entry toc-h3"><a href="#%EB%8F%84%EC%BB%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90">도커 아키텍쳐</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%EB%8F%84%EC%BB%A4-%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9">도커 기본 사용</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%EB%8F%84%EC%BB%A4-%EC%84%A4%EC%B9%98-%EB%B0%8F-%ED%99%95%EC%9D%B8">도커 설치 및 확인</a></li>
<li class="toc-entry toc-h3"><a href="#%EB%8F%84%EC%BB%A4%EB%A5%BC-%EB%B9%84-root-%EC%9C%A0%EC%A0%80%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0">도커를 비 root 유저로 관리하기</a></li>
<li class="toc-entry toc-h3"><a href="#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EA%B0%80-host%EC%9D%98-docker-socket-file-%EA%B3%B5%EC%9C%A0%EB%A1%9C-%EB%8F%84%EC%BB%A4-%EC%8B%A4%ED%96%89">컨테이너가 host의 docker socket file 공유로 도커 실행</a></li>
<li class="toc-entry toc-h3"><a href="#cpu-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90">CPU 아키텍쳐</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B2%A9%EB%A6%AC">컨테이너 격리</a>
<ul>
<li class="toc-entry toc-h3"><a href="#chroot">chroot</a></li>
<li class="toc-entry toc-h3">
<a href="#%EB%A7%88%EC%9A%B4%ED%8A%B8-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4--pivot_root">마운트 네임스페이스 + pivot_root</a>
<ul>
<li class="toc-entry toc-h4"><a href="#%EC%8B%A4%EC%8A%B5">실습</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-namespace">네임스페이스 (namespace)</a></li>
<li class="toc-entry toc-h3"><a href="#cgroup-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9E%90%EC%9B%90%EA%B4%80%EB%A6%AC">cgroup 를 이용한 자원관리</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC--iptables">컨테이너 네트워크 &amp; Iptables</a>
<ul>
<li class="toc-entry toc-h3"><a href="#red--blue-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B0%84-%ED%86%B5%EC%8B%A0">Red &lt;=&gt; Blue 네트워크 네임스페이스 간 통신</a></li>
<li class="toc-entry toc-h3"><a href="#red---bridge-br0---blue-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B0%84-%ED%86%B5%EC%8B%A0">Red &lt;- Bridge (br0) -&gt; Blue 네트워크 네임스페이스 간 통신</a></li>
<li class="toc-entry toc-h3"><a href="#%ED%98%B8%EC%8A%A4%ED%8A%B8--redblue-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A1%9C-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0">호스트 &lt;=&gt; RED/BLUE 네트워크 네임스페이스로 접근하기</a></li>
<li class="toc-entry toc-h3"><a href="#redblue%EC%97%90%EC%84%9C-%EC%99%B8%EB%B6%80-%EC%9D%B8%ED%84%B0%EB%84%B7-%ED%86%B5%EC%8B%A0">RED/BLUE에서 외부 인터넷 통신</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
</ul>
    </div>
    <h2 id="들어가며">들어가며</h2>

<p>지난 테라폼 스터디에 이어 이번 주 부터 KANS 스터디를 시작하게 되었습니다!
KANS는 <strong>K</strong>ubernetes <strong>A</strong>dvanced <strong>N</strong>etworking <strong>S</strong>tudy의 줄임말로 쿠버네티스 네트워킹에 대한 심도있게 공부하는 스터디입니다.
이번 스터디도 과제할 걱정도 <img class="emoji" title=":sweat:" alt=":sweat:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png" height="20" width="20" loading="lazy"> 되지만 재미있을것 같아 기대됩니다. <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20" loading="lazy"></p>

<p>첫 주 스터디도 컨테이너 격리와 리눅스 네트워크에 대해 많은것을 배웠고 이 자리에 정리해보려고 합니다. 
이번 스터디도 다들 완주하기를 기도하며 스터디 정리를 시작해 보겠습니다.</p>

<h2 id="도커-소개">도커 소개</h2>

<h3 id="도커란-무엇인가">도커란 무엇인가?</h3>

<ul>
  <li>
    <p>도커(Docker)는 컨테이너(Container)라고 불리는 가상실행 환경을 제공하고, 
그 가상환경에서 유용한 어플리케이션을 실행할 수 있게 해주는 오픈소스 플랫폼입니다.</p>
  </li>
  <li>
    <p>컨테이너라는 이름의 기원
컨테이너라는 이름은 배에 화물을 실을때 사용하는 그 컨테이너에서 왔습니다.
<img src="/assets/2024/kans-3th/w1/20240831_kans_w1_1.png" alt="컨테이너선" loading="lazy" width="1600" height="798">
과거에 컨테이너가 발명되기 이전에는 짐의 부피와 모양이 제각각이라서, 화물을 적재하기도 어렵고 
파도가 쳐서 배가 흔들릴때 짐이 이리 저리 움직여서 파손되는 경우가 많았습니다.</p>

    <p>이 문제를 해결하기 위해 Malcom McLean이라는 분이 발명한것이 직육면체의 바로 컨테이너입니다.<br>
<img src="/assets/2024/kans-3th/w1/20240831_kans_w1_2.png" alt="Shipping Container" loading="lazy" width="1400" height="875">
직육면체이기 때문에 적재가 쉽고, 파도가 치더라도 안정적으로 화물을 운반할 수 있었습니다. 
또한 크고 작은 물건도 컨테이너 안에 넣어서 운반할 수 있어서 화물의 종류에 상관없이 효율적으로 운반할 수 있었습니다.</p>

    <p>이 개념을 컴퓨팅에 도입한것이 컨테이너입니다. 
기존에는 각 리눅스 버전마다, glibc냐 musl이냐, debian 기반이냐 redhat 기반이냐 등등 
프로그램을 배포할때 환경을 맞춰야 하는것이 많았습니다. 그 뿐만아니라 각종 라이브러리들도 설치해야 하고
심지어 프로그램 마다 필요한 라이브러리 버전이 다를때도 있었습니다.</p>

    <p>이러한 문제를 해결하기위해 도커라는 컨테이너를 이용한 가상화 기술이 등장하게 되었습니다.
도커 컨테이너 이미지에는 프로그램 실행에 필요한 모든것이 포함되어 있기 때문에
마치 컨테이너에 화물을 싣듯이 프로그램을 배포할 수 있게 되었습니다. 
도커의 로고가 컨테이너를 싣고 있는 배를 형상화한것도 이러한 의미에서 나온것입니다.</p>

    <p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_3.png" alt="Docker Logo" loading="lazy" width="285" height="163"></p>
  </li>
  <li>
    <p>컨테이너 이외에도 가상 머신(Virtual Machine)이라는 기술이 있습니다. 
가상 머신은 하이퍼바이저(Hypervisor)를 이용하여 호스트 OS 위에 게스트 OS를 올리는 방식으로 가상화를 구현합니다.
가상 머신은 게스트 OS를 올리기 때문에 무겁습니다. 
반면 컨테이너는 호스트 OS의 커널을 공유하기 때문에 가볍습니다.
<img src="/assets/2024/kans-3th/w1/20240831_kans_w1_4.png" alt="img.png" loading="lazy" width="1631" height="574"></p>
  </li>
</ul>

<h3 id="컨테이너와-가상-머신">컨테이너와 가상 머신</h3>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_5.png" alt="가상머신과 컨테이너 비교" loading="lazy" width="768" height="379"></p>

<ul>
  <li>가상머신은 호스트 OS 위에 하이퍼바이저를 두고 하드웨어 일부(또는 전부)를 가상화하고, 그 위에 게스트 OS를 올립니다. 즉, <strong>하드웨어 레벨의 가상화</strong>를 지원합니다.</li>
  <li>컨테이너는 하드웨어 가상화와 게스트 OS 없이, 호스트의 리눅스 커널을 공유하여 바로 프로세스를 실행합니다. 단, 각종 라이브러리와 사용자 환경(User Land)는 컨테이너 단위로 패키징되어 <strong>OS 레벨의 가상화</strong>를 지원한다 할 수 있습니다.</li>
  <li>따라서 컨테이너는 가상머신보다 가볍고 빠르며, 낮은 격리(Weak Isolation) 수준을 가집니다.</li>
  <li>가상머신은 게스트 OS를 올리기 때문에 무겁고 느리지만, 높은 격리(Strong Isolation) 수준을 가집니다.
    <ul>
      <li>낮은 격리 수준을 보완하기 위해 리눅스의 pivot-root, namespace, cgroup 등의 기능들을 활용함으로써 프로세스 단위의 격리 환경과 리소스 제어를 제공합니다.
<img src="/assets/2024/kans-3th/w1/20240831_kans_w1_6.png" alt="img.png" loading="lazy" width="524" height="139">
</li>
    </ul>
  </li>
</ul>

<h3 id="도커-아키텍쳐">도커 아키텍쳐</h3>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_7.png" alt="도커 아키텍쳐" loading="lazy" width="2000" height="1056">
<a href="https://docs.docker.com/get-started/overview/#docker-architecture">https://docs.docker.com/get-started/overview/#docker-architecture</a></p>

<hr>

<h2 id="도커-기본-사용">도커 기본 사용</h2>

<h3 id="도커-설치-및-확인">도커 설치 및 확인</h3>

<ul>
  <li>도커 설치
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 방법1. debian 계열 리눅스에서 패키지 매니저로 설치</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt-get update
<span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> docker.io
  
<span class="c"># 방법2. 공식 사이트에서 설치</span>
<span class="nv">$ </span><span class="nb">sudo</span> <span class="nt">-i</span>
<span class="nv">$ </span>curl <span class="nt">-fsSL</span> https://get.docker.com | sh
</code></pre></div>    </div>
  </li>
  <li>기본정보 확인
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 도커 정보 확인 : Client 와 Server , Storage Driver(overlay2), Cgroup Version(2), Default Runtime(runc)</span>
<span class="nv">$ </span><span class="nb">sudo </span>docker info
<span class="c">#    Client:</span>
<span class="c">#     Context:    default</span>
<span class="c">#     Debug Mode: false</span>
<span class="c">#    </span>
<span class="c">#    Server:</span>
<span class="c">#     Containers: 0</span>
<span class="c">#     ...</span>
<span class="c">#     Server Version: 20.10.25+dfsg1</span>
<span class="c">#     Storage Driver: overlay2</span>
<span class="c">#     ...</span>
<span class="c">#     Cgroup Driver: systemd</span>
<span class="c">#     Cgroup Version: 2</span>
<span class="c">#     ...</span>
<span class="c">#     containerd version: 1.6.24~ds1-2</span>
<span class="c">#     runc version: 1.1.12+ds1-5</span>
<span class="c">#     ...</span>
  
<span class="nv">$ </span><span class="nb">sudo </span>docker version
<span class="c"># =&gt; Client:</span>
<span class="c">#     Version:           20.10.25+dfsg1</span>
<span class="c">#     API version:       1.41</span>
<span class="c">#     Go version:        go1.22.3</span>
<span class="c">#     Git commit:        b82b9f3</span>
<span class="c">#     Built:             Tue May  7 10:33:18 2024</span>
<span class="c">#     OS/Arch:           linux/amd64</span>
<span class="c">#     Context:           default</span>
<span class="c">#     Experimental:      true</span>
<span class="c">#    </span>
<span class="c">#    Server:</span>
<span class="c">#     Engine:</span>
<span class="c">#      Version:          20.10.25+dfsg1</span>
<span class="c">#      API version:      1.41 (minimum version 1.12)</span>
<span class="c">#      Go version:       go1.22.3</span>
<span class="c">#      Git commit:       5df983c</span>
<span class="c">#      Built:            Tue May  7 10:33:18 2024</span>
<span class="c">#      OS/Arch:          linux/amd64</span>
<span class="c">#      Experimental:     false</span>
<span class="c">#    ...  </span>
  
<span class="c"># 도커 서비스 상태 확인</span>
<span class="nv">$ </span><span class="nb">sudo </span>systemctl status docker <span class="nt">-l</span> <span class="nt">--no-pager</span>
  
<span class="c"># 모든 서비스의 상태 표시</span>
<span class="nv">$ </span>systemctl list-units <span class="nt">--type</span><span class="o">=</span>service
  
<span class="c"># 도커 루트 디렉터리 확인 : Docker Root Dir(/var/lib/docker)</span>
<span class="nv">$ </span><span class="nb">sudo </span>tree <span class="nt">-L</span> 3 /var/lib/docker
<span class="c"># =&gt; /var/lib/docker</span>
<span class="c">#    |-- buildkit</span>
<span class="c">#    |   ...</span>
<span class="c">#    |-- containers</span>
<span class="c">#    |-- image</span>
<span class="c">#    |   `-- overlay2</span>
<span class="c">#    |       |-- distribution</span>
<span class="c">#    |       |-- imagedb</span>
<span class="c">#    |       |-- layerdb</span>
<span class="c">#    |       `-- repositories.json</span>
<span class="c">#    |-- network</span>
<span class="c">#    |   `-- files</span>
<span class="c">#    |       `-- local-kv.db</span>
<span class="c">#    |-- overlay2</span>
<span class="c">#    |   ...</span>
<span class="c">#    `-- volumes</span>
<span class="c">#        |-- backingFsBlockDev</span>
<span class="c">#        `-- metadata.db</span>
<span class="c">#    </span>
<span class="c">#    24 directories, 8 files</span>
</code></pre></div>    </div>
  </li>
  <li>네트워크 정보 확인
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 프로세스 확인 - 셸변수</span>
<span class="nv">$ </span>ps <span class="nt">-ef</span>      <span class="c"># 프로세스 목록 보기</span>
<span class="nv">$ </span>pstree <span class="nt">-p</span>   <span class="c"># 프로세스 트리로 보기</span>
  
<span class="nv">$ </span><span class="nb">df</span> <span class="nt">-hT</span>    <span class="c"># 디스크 사용량 확인</span>

<span class="c"># 네트워크 정보 확인. 도커에서 사용하는 docker0 네트워크가 추가되어있고 현재 DOWN 상태입니다.</span>
<span class="c"># 컨테이너가 있으면 UP 상태로 변경됩니다.  </span>
<span class="nv">$ </span>ip <span class="nt">-br</span> <span class="nt">-c</span> addr
<span class="c"># =&gt; &lt;span style="color:teal;"&gt;lo               &lt;/span&gt;UNKNOWN        &lt;span style="color:purple;"&gt;127.0.0.1&lt;/span&gt;/8 &lt;span style="color:blue;"&gt;::1&lt;/span&gt;/128 </span>
<span class="c">#    &lt;span style="color:teal;"&gt;eth0             &lt;/span&gt;&lt;span style="color:green;"&gt;UP             &lt;/span&gt;&lt;span style="color:purple;"&gt;10.10.10.109&lt;/span&gt;/24 &lt;span style="color:purple;"&gt;10.10.10.51&lt;/span&gt;/24 &lt;span style="color:blue;"&gt;fe80::a70d:8639:be6:671e&lt;/span&gt;/64</span>
<span class="c">#    &lt;span style="color:teal;"&gt;docker0          &lt;/span&gt;&lt;span style="color:red;"&gt;DOWN           &lt;/span&gt;&lt;span style="color:purple;"&gt;172.17.0.1&lt;/span&gt;/16 &lt;span style="color:blue;"&gt;fe80::42:57ff:fe56:997c&lt;/span&gt;/64</span>
<span class="nv">$ </span>ip <span class="nt">-c</span> addr
<span class="nv">$ </span>ip <span class="nt">-c</span> <span class="nb">link</span>
<span class="nv">$ </span>ip <span class="nt">-br</span> <span class="nt">-c</span> <span class="nb">link</span>
<span class="nv">$ </span>ip <span class="nt">-c</span> route
  
<span class="c"># 이더넷 브릿지 정보 확인</span>
<span class="nv">$ </span>brctl show
<span class="c"># =&gt; bridge name	bridge id		STP enabled	interfaces</span>
<span class="c">#    docker0		8000.02425756997c	no</span>
  
<span class="c"># iptables 정책 확인</span>
<span class="c"># FORWARD 정책이 DROP으로 설정되어 있고, </span>
<span class="c"># docker0에서 docker0 혹은 외부로 전달되는 패킷은 허용되어 있습니다.</span>
<span class="nv">$ </span><span class="nb">sudo </span>iptables <span class="nt">-t</span> filter <span class="nt">-S</span>
<span class="c"># =&gt; -P INPUT ACCEPT</span>
<span class="c">#    &lt;span style="color: red;"&gt;-P FORWARD DROP&lt;/span&gt;</span>
<span class="c">#    -P OUTPUT ACCEPT</span>
<span class="c">#    -N DOCKER</span>
<span class="c">#    -N DOCKER-ISOLATION-STAGE-1</span>
<span class="c">#    -N DOCKER-ISOLATION-STAGE-2</span>
<span class="c">#    -N DOCKER-USER</span>
<span class="c">#    -A FORWARD -j DOCKER-USER</span>
<span class="c">#    -A FORWARD -j DOCKER-ISOLATION-STAGE-1</span>
<span class="c">#    -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span>
<span class="c">#    -A FORWARD -o docker0 -j DOCKER</span>
<span class="c">#    &lt;span style="color: red;"&gt;-A FORWARD -i docker0 ! -o docker0 -j ACCEPT&lt;/span&gt;</span>
<span class="c">#    &lt;span style="color: red;"&gt;-A FORWARD -i docker0 -o docker0 -j ACCEPT&lt;/span&gt;</span>
<span class="c">#    -A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2</span>
<span class="c">#    -A DOCKER-ISOLATION-STAGE-1 -j RETURN</span>
<span class="c">#    -A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP</span>
<span class="c">#    -A DOCKER-ISOLATION-STAGE-2 -j RETURN</span>
<span class="c">#    -A DOCKER-USER -j RETURN</span>

<span class="c"># NAT POSTROUTING에 172.17.0.0/16에서 외부로 전달시 MASQUERADE (SNAT) 정책이 설정되어 있습니다.</span>
<span class="nv">$ </span><span class="nb">sudo </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span>
<span class="c"># =&gt; -P PREROUTING ACCEPT</span>
<span class="c">#    -P INPUT ACCEPT</span>
<span class="c">#    -P OUTPUT ACCEPT</span>
<span class="c">#    -P POSTROUTING ACCEPT</span>
<span class="c">#    -N DOCKER</span>
<span class="c">#    -A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER</span>
<span class="c">#    -A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER</span>
<span class="c">#    &lt;span style="color: red;"&gt;-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE&lt;/span&gt;</span>
<span class="c">#    -A DOCKER -i docker0 -j RETURN</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="도커를-비-root-유저로-관리하기">도커를 비 root 유저로 관리하기</h3>

<p>도커는 기본적으로 root로 관리할 수 있습니다. 
root가 아닌 유저로 docker 명령을 실행하면 다음과 같은 에러가 발생합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">whoami</span>
<span class="c"># =&gt; kali</span>

<span class="nv">$ </span>docker info
<span class="c"># =&gt; ...</span>
<span class="c">#    Server:</span>
<span class="c">#    ERROR: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &amp;quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/info&amp;quot;: dial unix /var/run/docker.sock: connect: permission denied</span>
</code></pre></div></div>

<p>하지만, 다음의 방법 처럼 현재 사용자를 docker 그룹에 추가하면, root가 아닌 일반 유저로도 관리할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">whoami</span> 
<span class="c"># =&gt; kali</span>

<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$USER</span>
<span class="c"># =&gt; kali</span>

<span class="c"># 도커 그룹 추가</span>
<span class="nv">$ </span><span class="nb">sudo </span>usermod <span class="nt">-aG</span> docker <span class="nv">$USER</span>

<span class="c"># 그룹 확인</span>
<span class="nv">$ </span><span class="nb">groups</span> 
<span class="c"># =&gt; adm ... kaboxer</span>

<span class="c"># 로그아웃</span>
<span class="nb">exit</span> 

<span class="c"># ssh 재접속 후 확인</span>
<span class="nv">$ </span><span class="nb">groups</span> 
<span class="c"># =&gt; adm ... kaboxer docker</span>

<span class="nv">$ </span>docker info
<span class="c"># =&gt; Client:</span>
<span class="c">#     Context:    default</span>
<span class="c">#     Debug Mode: false</span>
<span class="c">#    </span>
<span class="c">#    Server:</span>
<span class="c">#     Containers: 0</span>
<span class="c">#     ...</span>
<span class="c">#     Cgroup Version: 2</span>
<span class="c">#     ...</span>
<span class="c">#     Default Runtime: runc</span>
<span class="c">#     Init Binary: docker-init</span>
<span class="c">#     containerd version: 1.6.24~ds1-2</span>
<span class="c">#     runc version: 1.1.12+ds1-5</span>
<span class="c">#     ...    </span>

<span class="c"># 컨테이너 확인</span>
<span class="nv">$ </span>docker run <span class="nt">--rm</span> hello-world
<span class="c"># =&gt; Hello from Docker!</span>
<span class="c">#    This message shows that your installation appears to be working correctly.</span>
<span class="c">#    ...</span>

<span class="c"># 실행중인 도커 컨테이너 확인</span>
<span class="nv">$ </span>docker ps
<span class="c"># 전체 도커 컨테이너 확인</span>
<span class="nv">$ </span>docker ps <span class="nt">-a</span>
<span class="c"># 이미지 목록 확인</span>
<span class="nv">$ </span>docker images
<span class="c"># =&gt; REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span>
<span class="c">#    hello-world   latest    d2c94e258dcb   16 months ago   13.3kB</span>

<span class="c"># 도커 컨테이너 삭제</span>
<span class="nv">$ </span>docker ps <span class="nt">-aq</span>
<span class="nv">$ </span>docker <span class="nb">rm</span> <span class="nt">-f</span> <span class="si">$(</span>docker ps <span class="nt">-aq</span><span class="si">)</span>
<span class="nv">$ </span>docker ps <span class="nt">-a</span>
</code></pre></div></div>

<h3 id="컨테이너가-host의-docker-socket-file-공유로-도커-실행">컨테이너가 host의 docker socket file 공유로 도커 실행</h3>

<ul>
  <li>
    <p>도커 컨테이너를 GUI로 관리할 수 있는 툴인 <a href="https://www.portainer.io/">portainer</a>처럼 도커 컨테이너가 호스트의 도커 소켓 파일을 공유하여 도커를 관리하는데 사용 할 수 있습니다.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 도커 컨테이너 실행</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 9000:9000 <span class="nt">-v</span> /var/run/docker.sock:/var/run/docker.sock portainer/portainer-ce
<span class="nv">$ </span>docker ps
<span class="c"># =&gt; CONTAINER ID   IMAGE                    COMMAND        CREATED         STATUS         PORTS                                                           NAMES</span>
<span class="c">#    1495728fd014   portainer/portainer-ce   &amp;quot;/portainer&amp;quot;   2 minutes ago   Up 2 minutes   8000/tcp, 9443/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp, :::9000-&amp;gt;9000/tcp   wizardly_ride</span>
  
</code></pre></div>    </div>

    <p><code class="language-plaintext highlighter-rouge">-v</code> 옵션으로 호스트의 도커 소켓 파일을 컨테이너의 도커 소켓 파일로 공유하면 아래와 같이 도커 컨테이너에서 호스트의 도커를 관리할 수 있습니다.</p>

    <p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_8.png" alt="소켓 공유를 통해 portainer 사용" loading="lazy" width="1392" height="820"></p>
  </li>
  <li>
    <p>또한 Jenkins 같은 CI/CD 툴을 사용할때도 도커 소켓 파일을 공유하여 도커 기반 워커를 사용할 수도 있습니다.</p>
  </li>
</ul>

<h3 id="cpu-아키텍쳐">CPU 아키텍쳐</h3>

<ul>
  <li>도커 허브에 등록된 이미지들은 CPU 아키텍쳐별로 이미지를 제공하는데, <strong>호스트의 CPU 아키텍쳐와 다른 이미지는 동작할 수 없습니다.</strong>
</li>
  <li>아래와 같이 docker hub에서는 지원 CPU 아키텍쳐별로 필터링하는 기능을 제공하니, 특정 아키텍쳐의 이미지가 필요한 경우 사용할 수 있습니다.
<img src="/assets/2024/kans-3th/w1/20240831_kans_w1_9.png" alt="img.png" loading="lazy" width="1392" height="820">
</li>
  <li>또한 도커이미지 페이지의 Tags 탭에서 태그의 지원하는 아키텍쳐를 확인할 수 있습니다.
<img src="../../../assets/2024/kans-3th/w1/20240831_kans_w1_10.png" alt="20240831_kans_w1_10.png" loading="lazy">
</li>
  <li>현재 리눅스의 CPU 아키텍쳐를 확인 해보겠습니다.
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>lscpu
<span class="c"># =&gt; Architecture:                       x86_64</span>
<span class="c">#    CPU op-mode(s):                     32-bit, 64-bit</span>
<span class="c">#    ...</span>
</code></pre></div>    </div>
    <p>사용중인 CPU 아키텍쳐는 x86_64 입니다.</p>
  </li>
  <li>현재 CPU 아키텍쳐와는 다른 아키텍쳐의 이미지를 설치해서 실패하는것을 확인해 보겠습니다.
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># arm64 실행 실패</span>
<span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> arm64v8/ubuntu bash
<span class="c"># =&gt; WARNING: The requested image's platform (linux/arm64/v8) does not match the detected host platform (linux/amd64) and no specific platform was requested</span>
<span class="c">#    exec /usr/bin/bash: exec format error</span>
  
<span class="c"># riscv64 실행 실패</span>
<span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> riscv64/ubuntu bash
<span class="c"># =&gt; WARNING: The requested image's platform (linux/riscv64) does not match the detected host platform (linux/amd64) and no specific platform was requested</span>
<span class="c">#    exec /usr/bin/bash: exec format error</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr>

<h2 id="컨테이너-격리">컨테이너 격리</h2>

<ul>
  <li>docker는 리눅스의 프로세스 격리 기술을 활용하는데, 프로세스 격리 기술은 chroot에서 부터 cgroup, namespace 등을 거쳐 발전하고 있습니다.</li>
  <li>주요 격리 기술들을 실습해보며 이해해보겠습니다.
<img src="/assets/2024/kans-3th/w1/20240831_kans_w1_11.png" alt="img.png" loading="lazy" width="2000" height="617">
<a href="https://speakerdeck.com/kakao/ige-dwaeyo-dokeo-eobsi-keonteineo-mandeulgi?slide=200">https://speakerdeck.com/kakao/ige-dwaeyo-dokeo-eobsi-keonteineo-mandeulgi?slide=200</a>
</li>
</ul>

<h3 id="chroot">chroot</h3>

<ul>
  <li>chroot는 리눅스의 프로세스 격리 기술 중 하나로, 프로세스가 접근할 수 있는 파일 시스템의 루트 디렉터리를 변경하는 기술입니다.</li>
  <li>1979년에 처음 등장했으며, 한계가 뚜렷하지만 다양한 목적으로 현재도 현역으로 사용되고 있습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 관리자 전환</span>
<span class="nv">$ </span><span class="nb">sudo</span> <span class="nt">-i</span>
<span class="nv">$ </span><span class="nb">whoami</span>
<span class="c"># =&gt; root</span>

<span class="nv">$ </span><span class="nb">cd</span> /tmp
<span class="nv">$ </span><span class="nb">mkdir </span>myroot

<span class="c"># chroot 실행 (chroot [새 루트] [명령])</span>
<span class="nv">$ </span><span class="nb">chroot </span>myroot /bin/bash
<span class="c"># =&gt; chroot: failed to run command ‘/bin/bash’: No such file or directory</span>
</code></pre></div></div>

<ul>
  <li>/tmp/myroot 로 chroot하려니 bash가 없어서 실행이 되지 않습니다. bash를 복사해 넣어보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># bash를 실행하는데 필요한 라이브러리를 확인하겠습니다.</span>
<span class="nv">$ </span>ldd /bin/bash
<span class="c"># =&gt; linux-vdso.so.1 (0x00007fffecfa8000)</span>
<span class="c">#    libtinfo.so.6 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007fbfe6a4f000)</span>
<span class="c">#    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbfe686a000)</span>
<span class="c">#    /lib64/ld-linux-x86-64.so.2 (0x00007fbfe6be0000)</span>

<span class="nv">$ </span><span class="nb">mkdir</span> <span class="nt">-p</span> myroot/bin
<span class="nv">$ </span><span class="nb">cp</span> /bin/bash myroot/bin
<span class="nv">$ </span><span class="nb">mkdir</span> <span class="nt">-p</span> myroot/<span class="o">{</span>lib64,lib/x86_64-linux-gnu<span class="o">}</span>
<span class="nv">$ </span><span class="nb">cp</span> /lib/x86_64-linux-gnu/libtinfo.so.6 myroot/lib/x86_64-linux-gnu
<span class="nv">$ </span><span class="nb">cp</span> /lib/x86_64-linux-gnu/libc.so.6 myroot/lib/x86_64-linux-gnu
<span class="nv">$ </span><span class="nb">cp</span> /lib64/ld-linux-x86-64.so.2 myroot/lib64
<span class="nv">$ </span>tree myroot
<span class="c"># =&gt; myroot</span>
<span class="c">#    |-- bin</span>
<span class="c">#    |   `-- bash</span>
<span class="c">#    |-- lib</span>
<span class="c">#    |   `-- x86_64-linux-gnu</span>
<span class="c">#    |       |-- libc.so.6</span>
<span class="c">#    |       `-- libtinfo.so.6</span>
<span class="c">#    `-- lib64</span>
<span class="c">#        `-- ld-linux-x86-64.so.2</span>
<span class="c">#    </span>
<span class="c">#    5 directories, 4 files</span>

<span class="nv">$ </span><span class="nb">chroot </span>myroot /bin/bash
<span class="c"># =&gt; bash-5.2# </span>
<span class="c"># bash와 bash에 필요한 라이브러리를 넣어주니 chroot로 실행할 수 있게 되었습니다.</span>
<span class="c"># ls를 실행해보겠습니다.</span>
<span class="nv">$ </span><span class="nb">ls</span>
<span class="c"># =&gt; bash: ls: command not found</span>
<span class="c"># ls가 없어서 실행이 되지 않습니다. ls를 넣기위해 chroot에서 나오겠습니다.</span>
<span class="nv">$ </span><span class="nb">exit</span>

<span class="c"># ls 위치 확인</span>
<span class="nv">$ </span>whereis <span class="nb">ls</span>
<span class="c"># =&gt; ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz</span>
<span class="nv">$ </span>ldd /usr/bin/ls
<span class="c"># ldd로 확인된 라이브러리를 포함해 ls를 myroot에 넣어보겠습니다.</span>
<span class="nv">$ </span><span class="nb">cp</span> /usr/bin/ls myroot/bin
<span class="nv">$ </span><span class="nb">cp</span> /lib/x86_64-linux-gnu/libselinux.so.1 myroot/lib/x86_64-linux-gnu
<span class="nv">$ </span><span class="nb">cp</span> /lib/x86_64-linux-gnu/libpcre2-8.so.0 myroot/lib/x86_64-linux-gnu

<span class="nv">$ </span><span class="nb">chroot </span>myroot /bin/bash
<span class="c"># ls시 /tmp/myroot에 있는 파일들을 확인할 수 있습니다.</span>
<span class="nv">$ </span><span class="nb">ls</span>
<span class="c"># =&gt; bin  lib  lib64</span>
<span class="c"># 현재 디렉터리 확인시 / 로 되어있습니다. 이 처럼 chroot로 인해 루트 디렉터리가 변경되었습니다. </span>
<span class="nv">$ </span><span class="nb">pwd</span>
<span class="c"># =&gt; /</span>
<span class="nv">$ </span><span class="nb">cd</span> ../../..
<span class="nv">$ </span><span class="nb">ls</span>
<span class="c"># =&gt; bin lib lib64</span>

<span class="c"># chroot를 종료 합니다.</span>
<span class="nv">$ </span><span class="nb">exit</span>
</code></pre></div></div>

<ul>
  <li>이 작업을 반복하면 거의 모든 프로그램을 chroot로 실행할 수 있습니다. 하지만 /proc, /dev 등의 가상 디렉터리는 다음의 방법으로 넣어주어야 합니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 다음 동작은 chroot 밖의 호스트에서 실행해야 합니다.</span>
<span class="c"># mount 할 디렉터리 만들어주기</span>
<span class="nv">$ </span><span class="nb">mkdir</span> <span class="nt">-p</span> myroot/<span class="o">{</span>proc,dev<span class="o">}</span>

<span class="c"># /proc, /dev 마운트</span>
<span class="nv">$ </span>mount <span class="nt">-t</span> proc none myroot/proc
<span class="nv">$ </span>mount <span class="nt">-o</span> <span class="nb">bind</span> /dev myroot/dev

<span class="c"># /proc 확인을 위해 ps도 chroot 환경에 넣어보겠습니다.</span>
<span class="nv">$ </span><span class="nb">cp</span> /usr/bin/ps myroot/bin
<span class="nv">$ </span><span class="nb">cp</span> /lib/x86_64-linux-gnu/<span class="o">{</span>libproc2.so.0,libc.so.6,libsystemd.so.0,libcap.so.2,libgcrypt.so.20,liblz4.so.1,liblzma.so.5,libzstd.so.1,libgpg-error.so.0<span class="o">}</span> myroot/lib/x86_64-linux-gnu/ 
<span class="nv">$ </span><span class="nb">cp</span> /lib64/ld-linux-x86-64.so.2 myroot/lib64/ 

<span class="nv">$ </span><span class="nb">chroot </span>myroot /bin/bash
<span class="nv">$ </span><span class="nb">ls</span> /proc
<span class="nv">$ </span>ps
<span class="c"># =&gt;    PID TTY          TIME CMD</span>
<span class="c">#    729517 ?        00:00:00 sudo</span>
<span class="c">#    741301 ?        00:00:00 bash</span>
<span class="c">#    741310 ?        00:00:00 ps</span>

<span class="c"># chroot 종료</span>
<span class="nv">$ </span><span class="nb">exit</span>

<span class="c"># 마운트 해제</span>
<span class="nv">$ </span>mount <span class="nt">-t</span> proc
<span class="c"># =&gt; proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)</span>
<span class="c">#    none on /tmp/myroot/proc type proc (rw,relatime)</span>
<span class="nv">$ </span>umount myroot/proc
<span class="nv">$ </span>umount myroot/dev
<span class="nv">$ </span>mount <span class="nt">-t</span> proc
<span class="c"># =&gt; proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)</span>
</code></pre></div></div>

<ul>
  <li>도커 컨테이너 이미지를 추출하여 chroot로 실행해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir </span>nginx-root

<span class="c"># nginx 컨테이너 이미지에서 파일들을 추출하여 nginx-root에 넣어줍니다.</span>
<span class="nv">$ </span>docker <span class="nb">export</span> <span class="si">$(</span>docker create nginx<span class="si">)</span> | <span class="nb">tar</span> <span class="nt">-C</span> nginx-root <span class="nt">-xvf</span> -
<span class="nv">$ </span>docker images

<span class="nv">$ </span>tree <span class="nt">-L</span> 2 nginx-root

<span class="c"># chroot로 nginx-root를 루트 디렉터리로 변경합니다.</span>
<span class="nv">$ </span><span class="nb">chroot </span>nginx-root /bin/bash
<span class="c"># nginx를 실행해봅니다.</span>
<span class="nv">$ </span>nginx <span class="nt">-g</span> <span class="s1">'daemon off;'</span>

<span class="c"># [터미널2] 터미널을 하나더 열고 nginx 동작 여부를 확인합니다.</span>
<span class="nv">$ </span>ps <span class="nt">-f</span> <span class="nt">-C</span> nginx
<span class="nv">$ </span>curl localhost
</code></pre></div></div>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_12.png" alt="img.png" loading="lazy" width="956" height="745"></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 생성된 docker 컨테이너를 확인합니다. docker create nginx로 인해 컨테이너가 생겨져있습니다.</span>
<span class="nv">$ </span>docker ps <span class="nt">-a</span>
<span class="c"># =&gt; CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS    PORTS     NAMES</span>
<span class="c">#    0b506af00006   nginx     "/docker-entrypoint.…"   About a minute ago   Created             gifted_rosalind</span>

<span class="c"># 사용하지 않는 도커이미지를 지워줍니다.</span>
<span class="nv">$ </span>docker <span class="nb">rm </span>0b5
</code></pre></div></div>

<ul>
  <li>아쉽게도 chroot는 탈옥이 가능하다고 합니다. 다음 코드를 컴파일하여 탈옥을 시도해보겠습니다.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mkdir</span><span class="p">(</span><span class="s">".out"</span><span class="p">,</span> <span class="mo">0755</span><span class="p">);</span>
  <span class="n">chroot</span><span class="p">(</span><span class="s">".out"</span><span class="p">);</span>
  <span class="n">chdir</span><span class="p">(</span><span class="s">"../../../../../"</span><span class="p">);</span>
  <span class="n">chroot</span><span class="p">(</span><span class="s">"."</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">execl</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="s">"-i"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컴파일</span>
<span class="nv">$ </span>gcc <span class="nt">-o</span> myroot/escape_chroot escape_chroot.c
<span class="nv">$ </span>file myroot/escape_chroot
<span class="c"># =&gt; myroot/escape_chroot: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=5a40e26463d1015f870c7f1b9db9be159727c250, for GNU/Linux 3.2.0, not stripped</span>

<span class="c"># chroot 실행</span>
<span class="nv">$ </span><span class="nb">chroot </span>myroot /bin/bash
<span class="nv">$ </span><span class="nb">ls</span>
<span class="nv">$ </span><span class="nb">cd</span> ../../
<span class="nv">$ </span><span class="nb">cd</span> ../../
<span class="nv">$ </span><span class="nb">ls</span>
<span class="c"># 일반적인 방법으로는 myroot에서 벗어날 수 없었습니다.</span>

<span class="c"># escape_chroot 실행해서 탈옥해보겠습니다.</span>
<span class="nv">$ </span>./escape_chroot
<span class="nv">$ </span><span class="nb">ls</span> /
<span class="c"># 탈옥이 잘 되었습니다.</span>

<span class="c"># 종료</span>
<span class="nv">$ </span><span class="nb">exit</span>
<span class="nv">$ </span><span class="nb">exit</span>
</code></pre></div></div>

<h3 id="마운트-네임스페이스--pivot_root">마운트 네임스페이스 + pivot_root</h3>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">pivot_root</code>는 루트 파일 시스템을 변경하는 시스템 콜로, 루트 디렉터리를 변경하는 chroot와 달리 루트 파일 시스템을 별도의 디렉터리로 이동시킬 수 있습니다.</li>
  <li>아래의 그림에서 처럼 /tmp/new_root가 있고 /tmp/new_root/put_old 디렉터리가 있는 경우, <code class="language-plaintext highlighter-rouge">pivot_root /tmp/new_root /tmp_new_root/put_old</code>를 하면 
/tmp/new_root가 루트 디렉터리로 변경되고, 원래의 루트 /는 /tmp/new_root/put_old로 이동됩니다.</li>
</ul>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_13.png" alt="img.png" loading="lazy" width="2000" height="987">
<a href="https://speakerdeck.com/kakao/ige-dwaeyo-dokeo-eobsi-keonteineo-mandeulgi?slide=80">https://speakerdeck.com/kakao/ige-dwaeyo-dokeo-eobsi-keonteineo-mandeulgi?slide=80</a></p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">pivot_root</code>를 사용하려면 <code class="language-plaintext highlighter-rouge">unshare</code> 명령을 통해 마운트 네임스페이스를 만들어야 합니다. 마운트 네임스페이스는 리눅스 커널에서 제공하는 기능으로, 프로세스가 마운트 정보를 독립적으로 가질 수 있게 해줍니다.</li>
  <li>또한 다음과 같은 제약사항이 적용 됩니다.
    <ul>
      <li>new_root와 put_old가 디렉터리여야 한다.</li>
      <li>new_root와 put_old가 현재 루트와 같은 마운트 상에 있어선 안 된다.</li>
      <li>put_old가 new_root와 같거나 그 아래에 있어야 한다. 즉, put_old가 가리키는 경로명 앞에 “/..”를 0개 이상 붙여서 new_root와 같은 디렉터리가 나와야 한다.</li>
      <li>new_root가 마운트 지점의 경로여야 하되, “/”일 수 없다. 마운트 지점이 아닌 경우에는 그 경로를 스스로에게 바인드 마운트 해서 마운트 지점으로 바꿀 수 있다.</li>
      <li>new_root의 부모 마운트 및 현재 작업 디렉터리의 부모 마운트의 전파 유형이 MS_SHARED여선 안 된다. 마찬가지로 put_old가 기존 마운트 지점인 경우 그 전파 유형이 MS_SHARED여선 안 된다. 이 제약은 pivot_root()로 인해 다른 마운트 네임스페이스로 어떤 변화도 전파되지 않게 한다.</li>
      <li>현재 루트 디렉터리가 마운트 지점이어야 한다.</li>
    </ul>
  </li>
  <li>실습을 통해 마운트 네임스페이스와 pivot_root를 알아보겠습니다.</li>
</ul>

<h4 id="실습">실습</h4>

<ul>
  <li>먼저 pivot_root로 root 디렉터리로 만들 /tmp/new_root를 만들어보겠습니다.</li>
  <li>위의 제약사항 중 new_root와 put_old가 현재 루트와 같은 마운트 상에 있어서는 안 되기 때문에 new_root를 tmpfs 로 마운트 하겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> /tmp/new_root
<span class="c"># 마운트</span>
<span class="nv">$ </span>mount <span class="nt">-t</span> tmpfs tmpfs /tmp/new_root 
<span class="c"># 기존 루트를 이동시킬 /tmp/new_root/put_old 디렉터리를 만들기</span>
<span class="nv">$ </span><span class="nb">mkdir</span> /tmp/new_root/put_old
<span class="c"># /bin, /lib, /lib64 등 chroot 실습때 사용했던 /tmp/myroot를 /tmp/new_root 로 복사해서 재사용합니다.</span>
<span class="nv">$ </span><span class="nb">cp</span> <span class="nt">-rv</span> /tmp/myroot/<span class="k">*</span> /tmp/new_root 

<span class="nv">$ </span>mount <span class="nt">-t</span> proc proc /tmp/new_root/proc

<span class="c"># unshare 해서 마운트 네임스페이스를 만들어줍니다.</span>
<span class="nv">$ </span>unshare <span class="nt">--mount</span> /bin/bash 

<span class="nv">$ </span><span class="nb">cd</span> /tmp/new_root

<span class="c"># pivot_root를 실행</span>
<span class="nv">$ </span>pivot_root <span class="nb">.</span> put_old

<span class="c"># 새로운 루트로 이동되었습니다.</span>

<span class="c"># 새 루트 확인</span>
<span class="nv">$ </span><span class="nb">ls</span> / 
<span class="c"># =&gt; bin  dev  escape_chroot  lib  lib64  proc  put_old</span>

<span class="c"># 기존 루트 확인</span>
<span class="nv">$ </span><span class="nb">ls</span> /put_old
<span class="c"># =&gt; bin   dev  home        lib32  lost+found   mnt     proc  run   srv	  sys       usr  vmlinuz</span>
<span class="c">#    boot  etc  initrd.img  lib	   lib64        media   opt   root  sbin  swapfile  tmp  var  </span>
</code></pre></div></div>

<ul>
  <li>새로운 루트로 이동되었지만, 기존 루트에 있는 파일들을 삭제하거나 이동하지 않았기 때문에 /put_old로 기존 루트에 있는 파일들을 확인할 수 있습니다.</li>
  <li>하지만 umount를 사용하면 /put_old와 기존 루트의 연결을 끊어서 기존 루트를 숨길 수 있습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>umount <span class="nt">-l</span> /put_old

<span class="nv">$ </span><span class="nb">ls</span> /put_old
<span class="c"># =&gt; (공백)</span>
</code></pre></div></div>

<ul>
  <li>escape_root를 통해 탈옥을 시도해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 탈옥 시도</span>
<span class="nv">$ </span>/escape_chroot
<span class="nv">$ </span><span class="nb">ls</span> /
<span class="c"># =&gt; bin  dev  escape_chroot  lib  lib64  proc  put_old</span>
<span class="nv">$ </span><span class="nb">cd</span> ../../..
<span class="nv">$ </span>/escape_chroot
<span class="nv">$ </span><span class="nb">ls</span> /
<span class="c"># =&gt; bin  dev  escape_chroot  lib  lib64  proc  put_old</span>
</code></pre></div></div>

<ul>
  <li>chroot와 달리 pivot_root는 탈옥이 불가능하고 훨씬 안전한것 같습니다.</li>
</ul>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_14.png" alt="img.png" loading="lazy" width="900" height="700"></p>

<h3 id="네임스페이스-namespace">네임스페이스 (namespace)</h3>

<ul>
  <li>여기에서의 네임스페이스는 쿠버네티스 등의 네임스페이스와는 다른,
리눅스 커널에서 제공하는 프로세스 격리 기술로, 프로세스가 각종 자원을 격리하여 사용할 수 있게 해줍니다.</li>
  <li>주요 네임스페이스의 유형은 아래와 같습니다.
    <ul>
      <li>Mount Namespace (2002년 도입)
        <ul>
          <li>pivot_root 예제에서 처럼 마운트 정보를 격리합니다.</li>
          <li>즉, 서로 다른 네임스페이스가 독립적으로 파일 시스템을 마운트 할 수 있습니다.</li>
        </ul>
      </li>
      <li>UTS Namespace (2006년 도입)
        <ul>
          <li>호스트 이름과 NIS 도메인 이름을 격리합니다. 각 네임스페이스는 자체 호스트 이름과 NIS 도메인 이름을 가질 수 있고,
이를 통해 호스트 이름을 변경하더라도 다른 네임스페이스에 영향을 주지 않습니다.</li>
        </ul>
      </li>
      <li>IPC Namespace (2006년 도입)
        <ul>
          <li>POSIX 메시지 큐, 세마포어, 공유 메모리 같은 IPC 리소스를 격리합니다.</li>
          <li>이를 통해 서로 다른 네임스페이스는 독립적으로 System V IPC 객체와 POSIX 메시지 큐를 사용할 수 있습니다.</li>
        </ul>
      </li>
      <li>PID Namespace (2008년 도입)
        <ul>
          <li>프로세스 ID를 격리합니다. 각 네임스페이스는 자체 PID를 가질 수 있으며 자체적인 PID 1을 가질 수 있습니다.</li>
          <li>프로세스 ID가 1인것은 시스템 시작시에 최초로 실행된 것이며 이를 init 프로세스라고 합니다. 이 프로세스가 종료되면 
시스템이 종료되거나 다시 부팅됩니다. 도커 컨테이너 실행시 실행되는 프로그램이 PID가 1이고, 해당 프로그램이 종료되며 
컨테이너도 종료되는게 이때문입니다.</li>
        </ul>
      </li>
      <li>Network Namespace (2009년 도입)
        <ul>
          <li>네트워크 인터페이스, IP 주소, 라우팅 테이블, 방화벽 규칙 등 네트워크 리소스를 격리합니다.</li>
          <li>각 네임스페이스는 자체 네트워크 인터페이스, IP 주소, 라우팅 테이블, 방화벽 규칙을 가질 수 있습니다.</li>
        </ul>
      </li>
      <li>USER Namespace (2012년 도입)
        <ul>
          <li>사용자 ID와 그룹 ID를 격리합니다. 각 네임스페이스는 자체 사용자 ID와 그룹 ID를 가질 수 있습니다.</li>
          <li>이를 통해 root 권한을 가진 사용자도 일반 사용자로 격리하여 사용할 수 있고, 일반 사용자도 root 인것 처럼 보이게 할 수 있습니다.</li>
          <li>실행 중인 도커컨테이너에서는 ps로 확인시 root로 실행 중인데, 호스트에서 ps로 확인시 일반 사용자로 실행 중인것 처럼 보이는것도 이것 때문입니다.</li>
        </ul>
      </li>
      <li>CGROUP Namespace (2016년 도입)
        <ul>
          <li>CGROUP은 프로세스의 그룹으로 CPU, 메모리, 디스크 I/O, 네트워크 등의 자원을 제한하거나 할당할 수 있습니다.</li>
          <li>CGROUP Namespace는 CPU, 메모리 등의 자원을 제한하거나 할당할 수 있는 CGROUP을 격리하는 기능입니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="cgroup-를-이용한-자원관리">cgroup 를 이용한 자원관리</h3>

<ul>
  <li>cgroups는 control groups의 줄일말로 리눅스 커널에서 제공하는 자원 제한 및 할당 기능으로, CPU, 메모리, 디스크 I/O, 네트워크 등의 자원을 제한하거나 할당할 수 있습니다.</li>
  <li>프로세스는 실행중인 프로그램의 인스턴스를 의미하며, OS에서는 프로세스를 관리하기 위해 프로세스 ID(PID)를 사용합니다.</li>
  <li>cgroups는 프로세스를 그룹으로 묶어서 자원을 제한하거나 할당할 수 있습니다.</li>
  <li>cgroups는 /sys/fs/cgroup 디렉터리에 마운트되어 있으며, cgroup v1과 cgroup v2가 있습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># cgroup 버전 확인</span>
<span class="nv">$ </span>mount | <span class="nb">grep </span>cgroup
<span class="c"># =&gt; cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate,memory_recursiveprot)</span>
</code></pre></div></div>

<ul>
  <li>현재 테스트 시스템에는 cgroup v2가 사용되고 있는것을 확인할 수 있습니다.</li>
  <li>cgroup v2는 v1에 비해 자원 계층구조의 가시성이 향상 되었고, memoryQoS 라는 기능이 추가되어 컨테이너에서 OOM(Out Of Memory)이
발생가능성을 줄였습니다. 최신 리눅스 배포판은 보통 cgroup v2를 사용하고 있어서 cgroup v2로 실습을 진행하겠습니다.</li>
  <li>cgroup의 계층 구조는 /sys/fs/cgroup 에서 확인할 수 있습니다.</li>
  <li>/proc는 보았지만 /sys는 눈에 익지 않습니다. 리눅스 커널 3.x 버전에서 생긴것으로 USER SPACE 쪽은 /proc에 KERNEL SPACE 쪽 정보는 /sys에 들어간다고 합니다.</li>
</ul>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_23.png" alt="img.png" class="image-center" loading="lazy" width="2000" height="954">
<em class="image-caption">출처 : <a href="https://blog.naver.com/yu3papa/223562337709">https://blog.naver.com/yu3papa/223562337709</a></em></p>

<ul>
  <li>실습을 통해 cgroup의 정보를 확인해 보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mount <span class="nt">-t</span> cgroup
<span class="nv">$ </span>mount <span class="nt">-t</span> cgroup2
<span class="c"># =&gt; cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate,memory_recursiveprot)</span>

<span class="nv">$ </span>findmnt <span class="nt">-t</span> cgroup2
<span class="c"># =&gt; TARGET         SOURCE  FSTYPE  OPTIONS</span>
<span class="c">#    /sys/fs/cgroup cgroup2 cgroup2 rw,nosuid,nodev,noexec,relatime,nsdelegate,memory_recursiveprot</span>

<span class="c"># cgroupv1 만 지원 시, cgroup2 출력되지 않음</span>
<span class="nv">$ </span><span class="nb">grep </span>cgroup /proc/filesystems
<span class="c"># =&gt; nodev   cgroup</span>
<span class="c">#    nodev   cgroup2</span>

<span class="nv">$ </span><span class="nb">stat</span> <span class="nt">-fc</span> %T /sys/fs/cgroup/
<span class="c"># =&gt; cgroup2fs</span>

<span class="c"># 터미널2</span>
<span class="nv">$ </span><span class="nb">sleep </span>100000

<span class="c"># 터미널1</span>
<span class="c"># /proc 에 cgroup 정보 확인</span>
<span class="nv">$ </span><span class="nb">cat</span> /proc/cgroups
<span class="nv">$ </span><span class="nb">cat</span> /proc/<span class="si">$(</span>pgrep <span class="nb">sleep</span><span class="si">)</span>/cgroup
<span class="c"># =&gt; 0::/user.slice/user-1000.slice/session-713.scope</span>

<span class="nv">$ </span>tree /proc/<span class="si">$(</span>pgrep <span class="nb">sleep</span><span class="si">)</span> <span class="nt">-L</span> 2
<span class="c"># =&gt; ...</span>
<span class="c">#    |-- &lt;span style="font-weight:bold;color:blue;"&gt;ns&lt;/span&gt;</span>
<span class="c">#    |   |-- &lt;span style="font-weight:bold;color:teal;"&gt;cgroup&lt;/span&gt; -&amp;gt; cgroup:[4026531835]</span>
<span class="c">#    |   |-- &lt;span style="font-weight:bold;color:teal;"&gt;ipc&lt;/span&gt; -&amp;gt; ipc:[4026531839]</span>
<span class="c">#    |   |-- &lt;span style="font-weight:bold;color:teal;"&gt;mnt&lt;/span&gt; -&amp;gt; mnt:[4026531841]</span>
<span class="c">#    |   |-- &lt;span style="font-weight:bold;color:teal;"&gt;net&lt;/span&gt; -&amp;gt; net:[4026531840]</span>
<span class="c">#    ...</span>

<span class="c"># cgroup 목록 확인</span>
<span class="nv">$ </span><span class="nb">ls</span> /sys/fs/cgroup
<span class="nv">$ </span><span class="nb">cat</span> /sys/fs/cgroup/cgroup.controllers
<span class="c"># =&gt; cpuset cpu io memory hugetlb pids rdma misc</span>
<span class="nv">$ </span>tree /sys/fs/cgroup/ <span class="nt">-L</span> 1
<span class="nv">$ </span>tree /sys/fs/cgroup/ <span class="nt">-L</span> 2
<span class="nv">$ </span>tree /sys/fs/cgroup/user.slice <span class="nt">-L</span> 1
<span class="nv">$ </span>tree /sys/fs/cgroup/user.slice/user-1000.slice <span class="nt">-L</span> 1
</code></pre></div></div>

<ul>
  <li>이번에는 cgroup을 이용하여 자원을 제한하는 실습을 진행해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 터미널 2개를 열어서 root 로 실습 하겠습니다.</span>
<span class="nv">$ </span><span class="nb">sudo</span> <span class="nt">-i</span>
<span class="nv">$ </span><span class="nb">whoami</span>
<span class="c"># =&gt; root</span>

<span class="c"># 툴 설치</span>
<span class="nv">$ </span>apt <span class="nb">install</span> <span class="nt">-y</span> cgroup-tools stress htop

<span class="c"># 터미널2</span>
<span class="c"># CPU 사용률 확인을 위해 htop을 실행합니다.</span>
<span class="nv">$ </span>htop

<span class="c"># 터미널1에서 실습 진행</span>

<span class="c"># 1개 CPU 코어에 부하 발생을 위해 stress를 실행합니다.</span>
<span class="nv">$ </span>stress <span class="nt">--cpu</span> 1
</code></pre></div></div>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_25.png" alt="img.png" loading="lazy" width="1005" height="520"></p>

<ul>
  <li>CPU 0만 100% 사용중인것을 확인할 수 있습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> /sys/fs/cgroup
<span class="nv">$ </span><span class="nb">mkdir </span>test_cgroup_parent <span class="o">&amp;&amp;</span> <span class="nb">cd </span>test_cgroup_parent
<span class="nv">$ </span>tree

<span class="c"># 제어가능한 항목 확인</span>
<span class="nv">$ </span><span class="nb">cat </span>cgroup.controllers
<span class="c"># =&gt; cpuset cpu io memory hugetlb pids rdma misc</span>

<span class="c"># cpu를 subtree이 추가하여 컨트롤 할 수 있도록 설정 : +/-(추가/삭제) </span>
<span class="nv">$ </span><span class="nb">cat </span>cgroup.subtree_control
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"+cpu"</span> <span class="o">&gt;&gt;</span> /sys/fs/cgroup/test_cgroup_parent/cgroup.subtree_control

<span class="c"># cpu.max 제한 설정 : 첫 번쨰 값은 허용된 시간(마이크로초) 두 번째 값은 총 기간 길이 &gt; 1/10 실행 설정</span>
<span class="nv">$ </span><span class="nb">echo </span>100000 1000000 <span class="o">&gt;</span> /sys/fs/cgroup/test_cgroup_parent/cpu.max

<span class="c"># test용 자식 디렉토리를 생성하고, pid를 추가하여 제한을 걸어</span>
<span class="nv">$ </span><span class="nb">mkdir </span>test_cgroup_child <span class="o">&amp;&amp;</span> <span class="nb">cd </span>test_cgroup_child
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$$</span> <span class="o">&gt;</span> /sys/fs/cgroup/test_cgroup_parent/test_cgroup_child/cgroup.procs
<span class="nv">$ </span><span class="nb">cat</span> /sys/fs/cgroup/test_cgroup_parent/test_cgroup_child/cgroup.procs
<span class="c"># =&gt; 1947587</span>
<span class="c">#    2194781</span>
<span class="nv">$ </span><span class="nb">cat</span> /proc/<span class="nv">$$</span>/cgroup
<span class="c"># =&gt; 0::/test_cgroup_parent/test_cgroup_child</span>

<span class="c"># 부하 발생 확인 : 터미널2에 htop 확인</span>
<span class="nv">$ </span>stress <span class="nt">--cpu</span> 1
</code></pre></div></div>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_26.png" alt="img.png" loading="lazy" width="1005" height="625"></p>

<ul>
  <li>cpu.max 제한 설정에서 설정한 대로 (100000/1000000 =&gt; 10%) CPU 사용량이 10%로 제한된것을 확인할 수 있습니다.</li>
  <li>값 수정을 해서 100%로 변경해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 값 수정</span>
<span class="nv">$ </span><span class="nb">echo </span>1000000 1000000 <span class="o">&gt;</span> /sys/fs/cgroup/test_cgroup_parent/cpu.max

<span class="c"># 부하 발생 확인 : 터미널2에 htop 확인</span>
<span class="nv">$ </span>stress <span class="nt">--cpu</span> 1
</code></pre></div></div>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_27.png" alt="img.png" loading="lazy" width="1005" height="625"></p>

<ul>
  <li>테스트에 사용한 cgroup 을 삭제하고 실습을 마무리하겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">exit</span>
<span class="nv">$ </span><span class="nb">sudo</span> <span class="nt">-i</span>
<span class="nv">$ </span><span class="nb">rmdir</span> /sys/fs/cgroup/test_cgroup_parent/test_cgroup_child
<span class="nv">$ </span><span class="nb">rmdir</span> /sys/fs/cgroup/test_cgroup_parent
</code></pre></div></div>

<ul>
  <li>이상과 같이 cgroup을 사용하여 cpu 자원을 제한하는것을 실습해 보았습니다.</li>
</ul>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_24.png" alt="img.png" class="image-center" loading="lazy" width="539" height="388"></p>

<hr>

<h2 id="컨테이너-네트워크--iptables">컨테이너 네트워크 &amp; Iptables</h2>

<ul>
  <li>도커는 호스트와 컨테이너간, 컨테이너 간의 네트워크를 앞에서 살펴본 네트워크 네임스페이스를 통해 격리합니다.</li>
  <li>또한 iptables를 통해 네트워크 패킷을 제어하고, 컨테이너 간의 통신을 제어합니다.</li>
  <li>실습을 통해 네트워크 네임스페이스를 통한 격리와 iptables의 사용법에 대해 알아보겠습니다.</li>
</ul>

<h3 id="red--blue-네트워크-네임스페이스-간-통신">Red &lt;=&gt; Blue 네트워크 네임스페이스 간 통신</h3>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_17.png" alt="img.png" loading="lazy" width="2000" height="1063">
<a href="https://www.slideshare.net/slideshow/make-container-withoutdocker6overlaynetwork1/248297122">출처 : 도커없이 컨테이너 만들기</a></p>

<ul>
  <li>먼저 터미널 3개를 열고 모두 관리자로 로그인 하겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo</span> <span class="nt">-i</span>
<span class="nv">$ </span><span class="nb">whoami</span>
<span class="c"># =&gt; root</span>
</code></pre></div></div>

<ul>
  <li>veth (Virtual Ethernet)를 사용하여 Red와 Blue 네트워크 네임스페이스를 만듭니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ip <span class="nb">link </span>add veth0 <span class="nb">type </span>veth peer name veth1

<span class="c"># veth 생성 확인 (상태 DOWN)</span>
<span class="nv">$ </span>ip <span class="nb">link</span>
<span class="c"># =&gt; 22: &lt;span style="color:teal;"&gt;veth1@veth0: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST,M-DOWN&amp;gt; mtu 1500 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;mode DEFAULT group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;9e:74:34:5c:70:ef&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt;</span>
<span class="c">#    23: &lt;span style="color:teal;"&gt;veth0@veth1: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST,M-DOWN&amp;gt; mtu 1500 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;mode DEFAULT group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;72:c0:05:36:cd:1b&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt;</span>
<span class="nv">$ </span>ip addr | <span class="nb">grep </span>veth
<span class="c"># =&gt; 22: &lt;span style="color:teal;"&gt;veth1@veth0: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST,M-DOWN&amp;gt; mtu 1500 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;9e:74:34:5c:70:ef&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt;</span>
<span class="c">#    23: &lt;span style="color:teal;"&gt;veth0@veth1: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST,M-DOWN&amp;gt; mtu 1500 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;72:c0:05:36:cd:1b&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt;</span>

<span class="c"># 네트워크 네임스페이스 생성</span>
<span class="nv">$ </span>ip netns add RED
<span class="nv">$ </span>ip netns add BLUE

<span class="c"># 네트워크 네임스페이스 확인</span>
<span class="nv">$ </span>ip netns
<span class="c"># =&gt; RED</span>
<span class="c">#    BLUE</span>

<span class="c"># veth0와 veth1을 각각 RED와 BLUE 네트워크 네임스페이스로 이동시킵니다.</span>
<span class="nv">$ </span>ip <span class="nb">link set </span>veth0 netns RED  
<span class="nv">$ </span>ip <span class="nb">link set </span>veth1 netns BLUE

<span class="c"># 네트워크 네임스페이스 확인. id 라는것이 추가되었습니다.</span>
<span class="nv">$ </span>ip netns list
<span class="c"># =&gt; RED (id: 0)</span>
<span class="c">#    BLUE (id: 1)</span>

<span class="c"># ip 링크를 확인하면 veth0와 veth1이 각각 RED와 BLUE 네트워크 네임스페이스로 이동되어 기본 명령에서는 보이지 않습니다.</span>
<span class="nv">$ </span>ip <span class="nb">link</span> | <span class="nb">grep</span> <span class="s2">"veth."</span>
<span class="c"># =&gt; (공백)</span>

<span class="c"># ip netns exec [네임스페이스명] [명령] 으로 네트워크 네임스페이스에서 명령을 실행할 수 있습니다.</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>RED ip <span class="nb">link</span>
<span class="c"># =&gt; 1: &lt;span style="color:teal;"&gt;lo: &lt;/span&gt;&amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;mode DEFAULT group default qlen 1000</span>
<span class="c">#        link/loopback &lt;span style="color:olive;"&gt;00:00:00:00:00:00&lt;/span&gt; brd &lt;span style="color:olive;"&gt;00:00:00:00:00:00&lt;/span&gt;</span>
<span class="c">#    23: &lt;span style="color:teal;"&gt;veth0@if22: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;mode DEFAULT group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;72:c0:05:36:cd:1b&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt; link-netns BLUE</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>BLUE ip <span class="nb">link</span>
<span class="c"># =&gt; 1: &lt;span style="color:teal;"&gt;lo: &lt;/span&gt;&amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;mode DEFAULT group default qlen 1000</span>
<span class="c">#        link/loopback &lt;span style="color:olive;"&gt;00:00:00:00:00:00&lt;/span&gt; brd &lt;span style="color:olive;"&gt;00:00:00:00:00:00&lt;/span&gt;</span>
<span class="c">#    22: &lt;span style="color:teal;"&gt;veth1@if23: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;mode DEFAULT group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;9e:74:34:5c:70:ef&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt; link-netns RED</span>

<span class="c"># veth0과 veth1을 활성화 (UP) 시키겠습니다.</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>RED ip <span class="nb">link set </span>veth0 up
<span class="c"># veth0의 IP 확인</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>RED ip addr
<span class="c"># =&gt; ...</span>
<span class="c">#    23: &lt;span style="color:teal;"&gt;veth0@if22: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state &lt;span style="color:green;"&gt;UP &lt;/span&gt;group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;72:c0:05:36:cd:1b&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt; link-netns BLUE</span>
<span class="c">#        inet6 &lt;span style="color:blue;"&gt;fe80::70c0:5ff:fe36:cd1b&lt;/span&gt;/64 scope link proto kernel_ll </span>
<span class="c">#           valid_lft forever preferred_lft forever</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>BLUE ip <span class="nb">link set </span>veth1 up
<span class="nv">$ </span>ip netns <span class="nb">exec </span>BLUE ip addr
<span class="c"># =&gt; ...</span>
<span class="c">#    22: &lt;span style="color:teal;"&gt;veth1@if23: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state &lt;span style="color:green;"&gt;UP &lt;/span&gt;group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;9e:74:34:5c:70:ef&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt; link-netns RED</span>
<span class="c">#        inet6 &lt;span style="color:blue;"&gt;fe80::9c74:34ff:fe5c:70ef&lt;/span&gt;/64 scope link proto kernel_ll </span>
<span class="c">#           valid_lft forever preferred_lft forever</span>

<span class="c"># UP 상태로 되었으나 IP가 없습니다. IP를 할당해보겠습니다.</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>RED ip addr add 11.11.11.2/24 dev veth0
<span class="nv">$ </span>ip netns <span class="nb">exec </span>BLUE ip addr add 11.11.11.3/24 dev veth1

<span class="c"># IP 를 확인해보겠습니다.</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>RED ip addr
<span class="c"># =&gt; ...</span>
<span class="c">#    23: &lt;span style="color:teal;"&gt;veth0@if22: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state &lt;span style="color:green;"&gt;UP &lt;/span&gt;group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;72:c0:05:36:cd:1b&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt; link-netns BLUE</span>
<span class="c">#        inet &lt;span style="color:purple;"&gt;11.11.11.2&lt;/span&gt;/24 scope global veth0</span>
<span class="c">#           valid_lft forever preferred_lft forever</span>
<span class="c">#        inet6 &lt;span style="color:blue;"&gt;fe80::70c0:5ff:fe36:cd1b&lt;/span&gt;/64 scope link proto kernel_ll </span>
<span class="c">#           valid_lft forever preferred_lft forever</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>BLUE ip addr
<span class="c"># =&gt; ...</span>
<span class="c">#    22: &lt;span style="color:teal;"&gt;veth1@if23: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state &lt;span style="color:green;"&gt;UP &lt;/span&gt;group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;9e:74:34:5c:70:ef&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt; link-netns RED</span>
<span class="c">#        inet &lt;span style="color:purple;"&gt;11.11.11.3&lt;/span&gt;/24 scope global veth1</span>
<span class="c">#           valid_lft forever preferred_lft forever</span>
<span class="c">#        inet6 &lt;span style="color:blue;"&gt;fe80::9c74:34ff:fe5c:70ef&lt;/span&gt;/64 scope link proto kernel_ll </span>
<span class="c">#           valid_lft forever preferred_lft forever</span>
</code></pre></div></div>

<ul>
  <li>이제 Red와 Blue 네트워크 네임스페이스 간의 통신을 테스트 해보겠습니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">nsenter</code> 명령을 사용하여 네트워크에 attach 하고, <code class="language-plaintext highlighter-rouge">tcpdump</code>와 <code class="language-plaintext highlighter-rouge">ping</code>을 사용하여 통신을 확인합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">tcpdump</code>는 네트워크 패킷을 캡처하는 명령어로, 패킷을 캡처하여 확인할 수 있고, <code class="language-plaintext highlighter-rouge">ping</code>은 네트워크 상태를 확인하는 명령어입니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>tree /var/run/netns
<span class="c"># =&gt; &lt;span style="font-weight:bold;color:blue;"&gt;/var/run/netns&lt;/span&gt;</span>
<span class="c">#    |-- BLUE</span>
<span class="c">#    `-- RED</span>
<span class="c">#    </span>
<span class="c">#    1 directory, 2 files</span>

<span class="c"># 터미널 1 (RED 11.11.11.2)</span>
<span class="c"># 네트워크 네임스페이스에 attach. </span>
<span class="c"># 이때 --net 옵션을 사용해 앞에서 확인한 /var/run/netns/RED를 사용해 네트워크 네임스페이스에 attach 합니다.</span>
<span class="nv">$ </span>nsenter <span class="nt">--net</span><span class="o">=</span>/var/run/netns/RED
<span class="c"># 이웃하는 IP/ARP 정보 확인</span>
<span class="nv">$ </span>ip neigh
<span class="c"># =&gt; (공백)</span>
<span class="c"># 라우팅 정보, iptables 정보</span>
<span class="nv">$ </span>ip route
<span class="c"># =&gt; &lt;span style="color:purple;"&gt;11.11.11.0/24 &lt;/span&gt;dev &lt;span style="color:teal;"&gt;veth0 &lt;/span&gt;proto kernel scope link src &lt;span style="color:purple;"&gt;11.11.11.2 &lt;/span&gt;</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-S</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> 

<span class="c"># 터미널 2 (호스트)</span>
<span class="c"># 네트워크 네임스페이스 상태 확인</span>
<span class="nv">$ </span>lsns <span class="nt">-t</span> net
<span class="c"># =&gt;         NS TYPE NPROCS     PID USER     NETNSID NSFS            COMMAND</span>
<span class="c">#    ...</span>
<span class="c">#    4026532444 net       1 1940569 root           0 /run/netns/RED  -zsh</span>
<span class="c">#    4026532527 net       0         root             /run/netns/BLUE</span>
<span class="c"># 네트워크 정보 확인</span>
<span class="nv">$ </span>ip addr 
<span class="nv">$ </span>ip neigh
<span class="nv">$ </span>ip route
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-S</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> 

<span class="c"># 터미널 3 (BLUE 11.11.11.3)</span>
<span class="nv">$ </span>nsenter <span class="nt">--net</span><span class="o">=</span>/var/run/netns/BLUE
<span class="nv">$ </span>ip neigh
<span class="nv">$ </span>ip route
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-S</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> 

<span class="c"># ping 통신 확인</span>

<span class="c"># 터미널3 (BLUE)</span>
<span class="nv">$ </span>tcpdump <span class="nt">-i</span> veth1
<span class="nv">$ </span>ip <span class="nt">-c</span> neigh
<span class="nv">$ </span><span class="nb">exit</span>

<span class="c"># 터미널1 (RED)</span>
<span class="nv">$ </span>ping 11.11.11.3 <span class="nt">-c</span> 1 
<span class="nv">$ </span>ip <span class="nt">-c</span> neigh
<span class="nv">$ </span><span class="nb">exit</span>

<span class="c"># 네임스페이스 삭제</span>
<span class="nv">$ </span>ip netns del RED
<span class="nv">$ </span>ip netns del BLUE 
</code></pre></div></div>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_15.png" alt="img.png" loading="lazy" width="1005" height="1015"></p>

<ul>
  <li>위의 캡쳐와 같이 통신이 되어서 tcpdump에 ARP, ICMP 패킷이 잡히는것을 확인할 수 있습니다.</li>
  <li>또한 <code class="language-plaintext highlighter-rouge">ip neigh</code> 명령을 확인했을때 ARP 테이블에 상대방의 IP와 MAC 주소가 등록되어 있는것을 확인할 수 있습니다.</li>
</ul>

<h3 id="red---bridge-br0---blue-네트워크-네임스페이스-간-통신">Red &lt;- Bridge (br0) -&gt; Blue 네트워크 네임스페이스 간 통신</h3>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_16.png" alt="img.png" loading="lazy" width="2000" height="1310">
<a href="https://www.slideshare.net/slideshow/make-container-withoutdocker6overlaynetwork1/248297122">출처 : 도커없이 컨테이너 만들기</a></p>

<ul>
  <li>이전 실습에서는 Red와 Blue를 연결하여 peer 네트워크로 구성하였는데, 
이번에는 각각 독립적인 네트워크로 구성하여 Bridge를 사용하여 Red와 Blue 네트워크 네임스페이스 간의 통신을 확인해보겠습니다.</li>
  <li>왜 Bridge를 두는가 하면, peer 네트워크를 구성할 경우 구성원들 간의 통신을 위해서는 모든 노드가 서로서로 연결되어야 하기 때문입니다.
<img src="/assets/2024/kans-3th/w1/20240831_kans_w1_18.png" alt="img.png" class="image-center" loading="lazy" width="624" height="250">
</li>
  <li>Bridge를 두면 각 노드는 Bridge와만 연결되어 있으면 통신이 가능하므로 효율적입니다.</li>
  <li>실습을 통해 아래의 그림과 같이 격리된 네트워크 네임스페이스를 만들고 브릿지를 통해 통신해보겠습니다.
<img src="/assets/2024/kans-3th/w1/20240831_kans_w1_19.png" alt="img.png" loading="lazy" width="2000" height="1008">
</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 터미널 3개를 root 로 엽니다.</span>
<span class="nv">$ </span><span class="nb">sudo</span> <span class="nt">-i</span>
<span class="nv">$ </span><span class="nb">whoami</span>
<span class="c"># =&gt; root</span>

<span class="c"># 네트워크 네임스페이스 및 veth 생성</span>
<span class="nv">$ </span>ip netns add RED
<span class="nv">$ </span>ip <span class="nb">link </span>add reth0 <span class="nb">type </span>veth peer name reth1
<span class="nv">$ </span>ip <span class="nb">link set </span>reth0 netns RED
<span class="nv">$ </span>ip netns add BLUE
<span class="nv">$ </span>ip <span class="nb">link </span>add beth0 <span class="nb">type </span>veth peer name beth1
<span class="nv">$ </span>ip <span class="nb">link set </span>beth0 netns BLUE

<span class="c"># 확인</span>
<span class="nv">$ </span>ip netns list
<span class="nv">$ </span>ip <span class="nb">link</span>
<span class="c"># =&gt; ...</span>
<span class="c">#    26: &lt;span style="color:teal;"&gt;reth1@if27: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;mode DEFAULT group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;9a:1f:bf:6f:fe:64&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt; link-netns RED</span>
<span class="c">#    28: &lt;span style="color:teal;"&gt;beth1@if29: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;mode DEFAULT group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;7e:31:cf:5f:00:8f&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt; link-netns BLUE</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>RED ip addr
<span class="c"># =&gt; ...</span>
<span class="c">#    27: &lt;span style="color:teal;"&gt;reth0@if26: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;ea:7f:a0:1f:00:3d&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt; link-netnsid 0</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>BLUE ip addr
<span class="c"># =&gt; ...</span>
<span class="c">#    29: &lt;span style="color:teal;"&gt;beth0@if28: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state &lt;span style="color:red;"&gt;DOWN &lt;/span&gt;group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;66:23:89:a6:f7:70&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt; link-netnsid 0</span>

<span class="c"># 브릿지 정보 확인 </span>
<span class="nv">$ </span>brctl show
<span class="c"># =&gt; bridge name	bridge id		STP enabled	interfaces</span>
<span class="c">#    docker0		8000.02425756997c	no		</span>

<span class="c"># br0 브릿지 생성</span>
<span class="nv">$ </span>ip <span class="nb">link </span>add br0 <span class="nb">type </span>bridge

<span class="c"># br0 브릿지 정보 확인</span>
<span class="nv">$ </span>brctl show br0
<span class="c"># =&gt; bridge name	bridge id		STP enabled	interfaces</span>
<span class="c">#    br0		8000.000000000000	no		</span>
<span class="nv">$ </span>brctl showmacs br0
<span class="nv">$ </span>brctl showstp br0

<span class="c"># reth1과 beth1을 br0 브릿지에 연결</span>
<span class="nv">$ </span>ip <span class="nb">link set </span>reth1 master br0
<span class="nv">$ </span>ip <span class="nb">link set </span>beth1 master br0
<span class="nv">$ </span>brctl show br0
<span class="c"># =&gt; bridge name     bridge id               STP enabled     interfaces</span>
<span class="c">#    br0             8000.7e31cf5f008f       no              beth1</span>
<span class="c">#                                                            reth1</span>
<span class="nv">$ </span>brctl showmacs br0
<span class="c"># =&gt; port no mac addr                is local?       ageing timer</span>
<span class="c">#      2     7e:31:cf:5f:00:8f       yes                0.00</span>
<span class="c">#      2     7e:31:cf:5f:00:8f       yes                0.00</span>
<span class="c">#      1     9a:1f:bf:6f:fe:64       yes                0.00</span>
<span class="c">#      1     9a:1f:bf:6f:fe:64       yes                0.00</span>
<span class="nv">$ </span>ip <span class="nt">-br</span> <span class="nb">link</span>
<span class="c"># =&gt; ... </span>
<span class="c">#    &lt;span style="color:teal;"&gt;reth1@if27       &lt;/span&gt;&lt;span style="color:red;"&gt;DOWN           &lt;/span&gt;&lt;span style="color:olive;"&gt;9a:1f:bf:6f:fe:64 &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST&amp;gt; </span>
<span class="c">#    &lt;span style="color:teal;"&gt;beth1@if29       &lt;/span&gt;&lt;span style="color:red;"&gt;DOWN           &lt;/span&gt;&lt;span style="color:olive;"&gt;7e:31:cf:5f:00:8f &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST&amp;gt; </span>
<span class="c">#    &lt;span style="color:teal;"&gt;br0              &lt;/span&gt;&lt;span style="color:red;"&gt;DOWN           &lt;/span&gt;&lt;span style="color:olive;"&gt;7e:31:cf:5f:00:8f &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST&amp;gt; </span>

<span class="c"># reth0과 beth0에 IP 설정 및 활성화(UP) 시키고, reth1, beth1, br0를 활성화(UP) 합니다.</span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>RED  ip addr add 11.11.11.2/24 dev reth0
<span class="nv">$ </span>ip netns <span class="nb">exec </span>BLUE ip addr add 11.11.11.3/24 dev beth0
<span class="nv">$ </span>ip netns <span class="nb">exec </span>RED  ip <span class="nb">link set </span>reth0 up
<span class="nv">$ </span>ip <span class="nb">link set </span>reth1 up
<span class="nv">$ </span>ip netns <span class="nb">exec </span>BLUE ip <span class="nb">link set </span>beth0 up
<span class="nv">$ </span>ip <span class="nb">link set </span>beth1 up
<span class="nv">$ </span>ip <span class="nb">link set </span>br0 up
<span class="nv">$ </span>ip <span class="nt">-br</span> addr
<span class="c"># =&gt; ... </span>
<span class="c">#    &lt;span style="color:teal;"&gt;reth1@if27       &lt;/span&gt;&lt;span style="color:green;"&gt;UP             &lt;/span&gt;&lt;span style="color:blue;"&gt;fe80::981f:bfff:fe6f:fe64&lt;/span&gt;/64 </span>
<span class="c">#    &lt;span style="color:teal;"&gt;beth1@if29       &lt;/span&gt;&lt;span style="color:green;"&gt;UP             &lt;/span&gt;&lt;span style="color:blue;"&gt;fe80::7c31:cfff:fe5f:8f&lt;/span&gt;/64 </span>
<span class="c">#    &lt;span style="color:teal;"&gt;br0              &lt;/span&gt;&lt;span style="color:green;"&gt;UP             &lt;/span&gt;&lt;span style="color:blue;"&gt;fe80::7c31:cfff:fe5f:8f&lt;/span&gt;/64 </span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>RED ip <span class="nt">-br</span> addr
<span class="c"># =&gt; ...</span>
<span class="c">#    &lt;span style="color:teal;"&gt;reth0@if26       &lt;/span&gt;&lt;span style="color:green;"&gt;UP             &lt;/span&gt;&lt;span style="color:purple;"&gt;11.11.11.2&lt;/span&gt;/24 &lt;span style="color:blue;"&gt;fe80::e87f:a0ff:fe1f:3d&lt;/span&gt;/64 </span>
<span class="nv">$ </span>ip netns <span class="nb">exec </span>BLUE ip <span class="nt">-br</span> addr
<span class="c"># =&gt; ...</span>
<span class="c">#    &lt;span style="color:teal;"&gt;beth0@if28       &lt;/span&gt;&lt;span style="color:green;"&gt;UP             &lt;/span&gt;&lt;span style="color:purple;"&gt;11.11.11.3&lt;/span&gt;/24 &lt;span style="color:blue;"&gt;fe80::6423:89ff:fea6:f770&lt;/span&gt;/64 </span>

<span class="c"># 터미널1 (RED 11.11.11.2)</span>
<span class="nv">$ </span>nsenter <span class="nt">--net</span><span class="o">=</span>/var/run/netns/RED
<span class="nv">$ </span>ip <span class="nt">-c</span> a<span class="p">;</span><span class="nb">echo</span><span class="p">;</span> ip <span class="nt">-c</span> route<span class="p">;</span><span class="nb">echo</span><span class="p">;</span> ip <span class="nt">-c</span> neigh
<span class="c"># 현재 네트워크 네임스페이스 확인</span>
<span class="nv">$ </span>ip netns identify <span class="nv">$$</span>
<span class="c"># =&gt; RED</span>

<span class="c"># 터미널2 (호스트)</span>
<span class="nv">$ </span>brctl showmacs br0
<span class="nv">$ </span>bridge fdb show
<span class="nv">$ </span>bridge fdb show dev br0

<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-S</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-L</span> <span class="nt">-n</span> <span class="nt">-v</span>

<span class="c"># 터미널3 (BLUE 11.11.11.3)</span>
<span class="nv">$ </span>nsenter <span class="nt">--net</span><span class="o">=</span>/var/run/netns/BLUE
<span class="nv">$ </span>ip <span class="nt">-c</span> a<span class="p">;</span><span class="nb">echo</span><span class="p">;</span> ip <span class="nt">-c</span> route<span class="p">;</span><span class="nb">echo</span><span class="p">;</span> ip <span class="nt">-c</span> neigh
<span class="c"># 현재 네트워크 네임스페이스 확인</span>
<span class="nv">$ </span>ip netns identify <span class="nv">$$</span>
<span class="c"># =&gt; BLUE</span>

<span class="c"># 터미널2 (호스트)</span>
<span class="c"># ping 통신 전 사전 설정</span>
<span class="c">## iptables 정보 확인</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-S</span> | <span class="nb">grep</span> <span class="s1">'\-P'</span>
<span class="c"># =&gt; -P INPUT ACCEPT</span>
<span class="c">#    -P FORWARD DROP</span>
<span class="c">#    -P OUTPUT ACCEPT</span>
<span class="nv">$ </span>iptables <span class="nt">-nvL</span> <span class="nt">-t</span> filter

<span class="c"># 호스트에서 패킷 라우팅 설정 확인 - 0(off), 1(on)</span>
<span class="nv">$ </span><span class="nb">cat</span> /proc/sys/net/ipv4/ip_forward
<span class="c"># =&gt; 1</span>
<span class="c"># 위의 결과가 0인 경우 아래의 명령을 실행</span>
<span class="c"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span>

<span class="c"># ping 통신 확인</span>
<span class="c"># 터미널2 (호스트)</span>
<span class="nv">$ </span>tcpdump <span class="nt">-l</span> <span class="nt">-i</span> br0
<span class="c"># =&gt; tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span>
<span class="c">#    listening on br0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span>
<span class="c">#    (터미널1에서 ping 실행시)</span>
<span class="c">#    08:40:00.413198 IP 11.11.11.2 &gt; 11.11.11.3: ICMP echo request, id 41028, seq 1, length 64</span>
<span class="c">#    08:40:05.455528 ARP, Request who-has 11.11.11.3 tell 11.11.11.2, length 28</span>
<span class="c">#    08:40:05.455556 ARP, Reply 11.11.11.3 is-at 66:23:89:a6:f7:70 (oui Unknown), length 28</span>
<span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'iptables -v --numeric --table filter --list FORWARD'</span>
<span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'iptables -v --numeric --table filter --list FORWARD;echo;iptables -v --numeric --table filter --list DOCKER-USER;echo;iptables -v --numeric --table filter --list DOCKER-ISOLATION-STAGE-1'</span>

<span class="c"># 터미널3 (BLUE 11.11.11.3)</span>
<span class="nv">$ </span>tcpdump <span class="nt">-l</span> <span class="nt">-i</span> beth0

<span class="c"># 터미널1 (RED 11.11.11.2)</span>
<span class="nv">$ </span>ping 11.11.11.3 <span class="nt">-c</span> 1
<span class="c"># =&gt; 실패</span>
</code></pre></div></div>

<p>위의 캡쳐와 같이 브릿지에서는 패킷이 잡히지만, 브릿지를 통해 Blue로 패킷이 전달되지 않는것을 확인할 수 있습니다.
그렇다면 왜 패킷이 전달되지 않을까요? 그것은 <code class="language-plaintext highlighter-rouge">iptables -t filter -S | grep '\-P'</code> 명령을 통해 확인했을때 FORWARD 체인이 DROP으로 설정되어 있기 때문입니다.
패킷이 브릿지를 통해 전달되려면 FORWARD 체인을 통해야 하는데 DROP이면 패킷이 전달되지 않습니다.</p>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_20.png" alt="img.png" class="image-center" loading="lazy" width="1000" height="555">
<em class="image-caption">Iptables 처리 흐름도 (<a href="https://natnat1.medium.com/iptables-b9ce0602253f">https://natnat1.medium.com/iptables-b9ce0602253f</a>)</em></p>

<ul>
  <li>위의 그림과 같이 iptables는 패킷이 들어오면 PREROUTING 체인을 통해 패킷을 처리하고, FORWARD 체인을 통해 패킷을 전달합니다.</li>
</ul>

<p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_21.png" alt="img.png" loading="lazy" width="750" height="416"></p>

<ul>
  <li>br0 입장에서 살펴보면 위와 같습니다. 그렇다면 11.11.11.2 &lt;=&gt; 11.11.11.3으로 FORWARD를 허용하면 되는데 방법을 살펴보면 아래와 같습니다.
    <ul>
      <li>출발지 11.11.11.2와 11.11.11.3 허용</li>
      <li>도착지 11.11.11.0/24 대역 출발지 허용</li>
      <li>FORWARD 기본 정책을 ACCEPT로 변경</li>
      <li>등등 기타 어떤 방법으로든 11.11.11.2와 11.11.11.3이 FORWARD 체인을 통해 패킷이 전달되도록 설정하면 됩니다.</li>
    </ul>
  </li>
  <li>실습을 통해 iptables를 통해 패킷이 전달되도록 설정해보겠습니다.</li>
  <li>방법1. 11.11.11.2와 11.11.11.3 허용하기
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 터미널2 (호스트)</span>
<span class="c"># 출발지 11.11.11.2 허용하기</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-A</span> FORWARD <span class="nt">-s</span> 11.11.11.2/32 <span class="nt">-j</span> ACCEPT
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-A</span> FORWARD <span class="nt">-s</span> 11.11.11.3/32 <span class="nt">-j</span> ACCEPT
<span class="nv">$ </span>tcpdump <span class="nt">-l</span> <span class="nt">-i</span> br0
  
<span class="c"># 터미널3 (BLUE 11.11.11.3)</span>
<span class="nv">$ </span>tcpdump <span class="nt">-l</span> <span class="nt">-i</span> beth0
<span class="c"># =&gt; tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span>
<span class="c">#    listening on beth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span>
<span class="c">#    10:39:20.225225 IP 11.11.11.2 &gt; 11.11.11.3: ICMP echo request, id 33335, seq 1, length 64</span>
<span class="c">#    10:39:20.225233 IP 11.11.11.3 &gt; 11.11.11.2: ICMP echo reply, id 33335, seq 1, length 64</span>
  
<span class="c"># 터미널1 (RED 11.11.11.2)</span>
<span class="nv">$ </span>ping 11.11.11.3
<span class="c"># =&gt; PING 11.11.11.3 (11.11.11.3) 56(84) bytes of data.</span>
<span class="c">#    64 bytes from 11.11.11.3: icmp_seq=1 ttl=64 time=0.055 ms</span>
<span class="c">#    </span>
<span class="c">#    --- 11.11.11.3 ping statistics ---</span>
<span class="c">#    1 packets transmitted, 1 received, 0% packet loss, time 0ms</span>
<span class="c">#    rtt min/avg/max/mdev = 0.055/0.055/0.055/0.000 ms</span>
  
<span class="c"># 터미널2 (호스트)</span>
<span class="c"># 허용 룰 제거</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-D</span> FORWARD <span class="nt">-s</span> 11.11.11.2/32 <span class="nt">-j</span> ACCEPT
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-D</span> FORWARD <span class="nt">-s</span> 11.11.11.3/32 <span class="nt">-j</span> ACCEPT
</code></pre></div>    </div>

    <p><img src="/assets/2024/kans-3th/w1/20240831_kans_w1_22.png" alt="img.png" loading="lazy" width="1005" height="805"></p>
  </li>
  <li>방법2. 도착지 11.11.11.0/24 대역 허용하기
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 터미널2 (호스트)</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-A</span> FORWARD <span class="nt">-d</span> 11.11.11.0/24 <span class="nt">-j</span> ACCEPT
<span class="c"># 테스트 후 허용 룰 제거</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-D</span> FORWARD <span class="nt">-d</span> 11.11.11.0/24 <span class="nt">-j</span> ACCEPT
</code></pre></div>    </div>
  </li>
  <li>방법3. FORWARD 기본 정책을 ACCEPT로 변경하기
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 터미널2 (호스트)</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-P</span> FORWARD ACCEPT
<span class="c"># 테스트 후 허용 룰 제거</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-P</span> FORWARD DROP
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="호스트--redblue-네트워크-네임스페이스로-접근하기">호스트 &lt;=&gt; RED/BLUE 네트워크 네임스페이스로 접근하기</h3>

<ul>
  <li>“Red &lt;- Bridge (br0) -&gt; Blue 네트워크 네임스페이스 간 통신”을 실습한 환경에 이어서 실습해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 터미널1 (RED 11.11.11.2)</span>
<span class="nv">$ </span>nsenter <span class="nt">--net</span><span class="o">=</span>/var/run/netns/RED
<span class="nv">$ </span>tcpdump <span class="nt">-i</span> any

<span class="c"># 터미널3를 호스트 네트워크로 변경합니다.</span>
<span class="nv">$ </span><span class="nb">exit</span>
<span class="nv">$ </span>ip netns identify <span class="nv">$$</span>
<span class="c"># =&gt; (공백)</span>
<span class="nv">$ </span>tcpdump <span class="nt">-i</span> br0 <span class="nt">-n</span>

<span class="c"># 터미널2 (호스트)</span>
<span class="nv">$ </span>ping <span class="nt">-c</span> 1 11.11.11.2
<span class="c"># =&gt; 1 packets transmitted, 0 received, 100% packet loss, time 0ms</span>
<span class="c"># (ping 이 실패합니다.)</span>
</code></pre></div></div>

<ul>
  <li>호스트에서 RED (11.11.11.2) 로 ping시 패킷이 전달되지 않는것을 확인할 수 있습니다.</li>
  <li>그 이유는 RED 네트워크로 접근하기 위해서는 br0를 거쳐서 접근해야하는데, br0는 ip가 없기 때문에 패킷이 전달되지 않습니다.</li>
  <li>br0에 ip를 할당하고, RED와 BLUE 네트워크 네임스페이스로 접근해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 터미널2 (호스트)</span>
<span class="nv">$ </span>ip addr add 11.11.11.1/24 dev br0
<span class="nv">$ </span>ip addr
<span class="c"># =&gt; ...</span>
<span class="c">#    30: &lt;span style="color:teal;"&gt;br0: &lt;/span&gt;&amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state &lt;span style="color:green;"&gt;UP &lt;/span&gt;group default qlen 1000</span>
<span class="c">#        link/ether &lt;span style="color:olive;"&gt;7e:31:cf:5f:00:8f&lt;/span&gt; brd &lt;span style="color:olive;"&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt;</span>
<span class="c">#        inet &lt;span style="color:purple;"&gt;11.11.11.1&lt;/span&gt;/24 scope global br0</span>
<span class="c">#           valid_lft forever preferred_lft forever</span>
<span class="nv">$ </span>ping 11.11.11.2 <span class="nt">-c</span> 1
<span class="c"># =&gt; PING 11.11.11.2 (11.11.11.2) 56(84) bytes of data.</span>
<span class="c">#    64 bytes from 11.11.11.2: icmp_seq=1 ttl=64 time=0.044 ms</span>
<span class="c">#    </span>
<span class="c">#    --- 11.11.11.2 ping statistics ---</span>
<span class="c">#    1 packets transmitted, 1 received, 0% packet loss, time 0ms</span>
<span class="c">#    rtt min/avg/max/mdev = 0.044/0.044/0.044/0.000 ms</span>
<span class="nv">$ </span>ping 11.11.11.3 <span class="nt">-c</span> 1
<span class="c"># =&gt; PING 11.11.11.3 (11.11.11.3) 56(84) bytes of data.</span>
<span class="c">#    64 bytes from 11.11.11.3: icmp_seq=1 ttl=64 time=0.052 ms</span>
<span class="c">#    </span>
<span class="c">#    --- 11.11.11.3 ping statistics ---</span>
<span class="c">#    1 packets transmitted, 1 received, 0% packet loss, time 0ms</span>
<span class="c">#    rtt min/avg/max/mdev = 0.052/0.052/0.052/0.000 ms</span>
</code></pre></div></div>

<ul>
  <li>이번에는 RED에서 호스트로 ping이 되는것을 확인해 보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 터미널1 (RED 11.11.11.2)</span>
<span class="c"># br0 에 ping 테스트</span>
<span class="nv">$ </span>ping 11.11.11.1 <span class="nt">-c</span> 1
<span class="c"># =&gt; PING 11.11.11.1 (11.11.11.1) 56(84) bytes of data.</span>
<span class="c">#    64 bytes from 11.11.11.1: icmp_seq=1 ttl=64 time=0.041 ms</span>
<span class="c">#    </span>
<span class="c">#    --- 11.11.11.1 ping statistics ---</span>
<span class="c">#    1 packets transmitted, 1 received, 0% packet loss, time 0ms</span>
<span class="c">#    rtt min/avg/max/mdev = 0.041/0.041/0.041/0.000 ms</span>

<span class="c"># 호스트로 ping 테스트</span>
<span class="nv">$ </span>ping 10.10.10.51 <span class="nt">-c</span> 1
<span class="c"># =&gt; ping: connect: Network is unreachable</span>
</code></pre></div></div>

<ul>
  <li>br0에는 ping 이 성공하는데 호스트로는 Network is unreachable 에러가 발생하는것을 확인할 수 있습니다.</li>
  <li>그 이유는 11.11.11.0/24에서 호스트 네트워크인 10.10.10.0/24로 패킷을 라우팅하는 정보가 없기 때문입니다.</li>
  <li>RED나 BLUE에서 호스트로 패킷을 전달하기 위해서는 br0를 통해야 하는데, RED와 BLUE에 기본 게이트웨이를 br0로 설정하여 테스트해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 터미널1 (RED 11.11.11.2)</span>
<span class="nv">$ </span>ip route add default via 11.11.11.1
<span class="nv">$ </span>ip route
<span class="c"># =&gt; default via 11.11.11.1 dev reth0</span>
<span class="c">#    11.11.11.0/24 dev reth0 proto kernel scope link src 11.11.11.2</span>
<span class="nv">$ </span>ping 10.10.10.51 <span class="nt">-c</span> 1
<span class="c"># =&gt; PING 10.10.10.51 (10.10.10.51) 56(84) bytes of data.</span>
<span class="c">#    64 bytes from 10.10.10.51: icmp_seq=1 ttl=64 time=0.041 ms</span>
<span class="c">#    </span>
<span class="c">#    --- 10.10.10.51 ping statistics ---</span>
<span class="c">#    1 packets transmitted, 1 received, 0% packet loss, time 0ms</span>
<span class="nv">$ </span><span class="nb">exit</span>

<span class="c"># BLUE에서도 동일하게 테스트해보겠습니다</span>

<span class="c"># 터미널1 (BLUE 11.11.11.3)</span>
<span class="nv">$ </span>nsenter <span class="nt">--net</span><span class="o">=</span>/var/run/netns/BLUE
<span class="nv">$ </span>ip netns identify <span class="nv">$$</span>
<span class="c"># =&gt; BLUE</span>
<span class="nv">$ </span>ping 10.10.10.51 <span class="nt">-c</span> 1
<span class="c"># =&gt; ping: connect: Network is unreachable</span>
<span class="nv">$ </span>ip route add default via 11.11.11.1
<span class="nv">$ </span>ip route
<span class="c"># =&gt; default via 11.11.11.1 dev beth0</span>
<span class="c">#    11.11.11.0/24 dev beth0 proto kernel scope link src 11.11.11.3</span>
<span class="nv">$ </span>ping 10.10.10.51 <span class="nt">-c</span> 1
<span class="c"># =&gt; PING 10.10.10.51 (10.10.10.51) 56(84) bytes of data.</span>
<span class="c">#    64 bytes from 10.10.10.51: icmp_seq=1 ttl=64 time=0.049 ms</span>
<span class="c">#    </span>
<span class="c">#    --- 10.10.10.51 ping statistics ---</span>
<span class="c">#    1 packets transmitted, 1 received, 0% packet loss, time 0ms</span>
<span class="c">#    rtt min/avg/max/mdev = 0.049/0.049/0.049/0.000 ms</span>
</code></pre></div></div>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">ip route add default via 11.11.11.1</code> 로 기본 게이트웨이를 br0로 설정하고, 호스트로 ping이 되는것을 확인할 수 있습니다.</li>
</ul>

<h3 id="redblue에서-외부-인터넷-통신">RED/BLUE에서 외부 인터넷 통신</h3>

<ul>
  <li>이번에는 RED와 BLUE 네트워크 네임스페이스에서 외부 인터넷으로 통신하는 방법을 실습해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 터미널1 (RED 11.11.11.2)</span>
<span class="nv">$ </span>nsenter <span class="nt">--net</span><span class="o">=</span>/var/run/netns/RED
<span class="nv">$ </span>ping 8.8.8.8 <span class="nt">-c</span> 1
<span class="c"># =&gt; PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</span>
<span class="c">#    </span>
<span class="c">#    --- 8.8.8.8 ping statistics ---</span>
<span class="c">#    1 packets transmitted, 0 received, 100% packet loss, time 0ms</span>
</code></pre></div></div>

<ul>
  <li>RED에서 외부 인터넷으로 ping이 되지 않는것을 확인할 수 있습니다.</li>
  <li>RED/BLUE와 같이 호스트 아래의 내부 네트워크에서 외부 인터넷으로 패킷을 전달하기 위해서는
호스트의 IP로 패킷을 전달하고, 응답을 호스트 IP로 받아서 내부 네트워크(RED/BLUE)로 전달해야하는데, 
이러한 과정을 SNAT (Source Network Address Translation) 또는 MASQUERADE라고 합니다.</li>
  <li>nat 테이블의 POSTROUTING 체인에 MASQUERADE 룰을 추가하면 SNAT이 적용되어서 외부 인터넷으로 패킷을 전달할 수 있습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 터미널2 (호스트)</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-A</span> POSTROUTING <span class="nt">-s</span> 11.11.11.0/24 <span class="nt">-j</span> MASQUERADE
<span class="c"># SNAT 통계 모니터링</span>
<span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'iptables -v --numeric --table nat --list POSTROUTING'</span>
<span class="nv">$ </span>iptables <span class="nt">-nvL</span> <span class="nt">-t</span> nat
<span class="nv">$ </span>conntrack <span class="nt">-L</span> <span class="nt">--src-nat</span>
<span class="c"># =&gt; icmp     1 29 src=11.11.11.2 dst=8.8.8.8 type=8 code=0 id=62779 src=8.8.8.8 dst=10.10.10.109 type=0 code=0 id=62779 mark=0 use=1</span>
<span class="c">#    conntrack v1.4.8 (conntrack-tools): 1 flow entries have been shown.</span>

<span class="c"># 터미널1 (RED 11.11.11.2)</span>
<span class="nv">$ </span>ping 8.8.8.8 <span class="nt">-c</span> 1
<span class="c"># =&gt; PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</span>
<span class="c">#    64 bytes from 8.8.8.8: icmp_seq=1 ttl=113 time=26.3 ms</span>
<span class="c">#    </span>
<span class="c">#    --- 8.8.8.8 ping statistics ---</span>
<span class="c">#    1 packets transmitted, 1 received, 0% packet loss, time 0ms</span>
<span class="c">#    rtt min/avg/max/mdev = 26.277/26.277/26.277/0.000 ms</span>
<span class="nv">$ </span><span class="nb">exit</span>

<span class="c"># 터미널1 (BLUE 11.11.11.3)</span>
<span class="nv">$ </span>nsenter <span class="nt">--net</span><span class="o">=</span>/var/run/netns/BLUE
<span class="nv">$ </span>ip route add default via 11.11.11.1
<span class="nv">$ </span>ping 8.8.8.8 <span class="nt">-c</span> 1
<span class="nv">$ </span><span class="nb">exit</span>

<span class="c"># 삭제</span>
<span class="nv">$ </span>ip netns delete RED
<span class="nv">$ </span>ip netns delete BLUE
<span class="nv">$ </span>ip <span class="nb">link </span>delete br0

<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-D</span> POSTROUTING <span class="nt">-s</span> 11.11.11.0/24 <span class="nt">-j</span> MASQUERADE
</code></pre></div></div>

<ul>
  <li>SNAT 추가한 이후 ping이 잘 되는것을 확인할 수 있었습니다.</li>
</ul>

<hr>

<h2 id="마치며">마치며</h2>

<p>첫주부터 이론과 실습할것이 굉장히 많았습니다. 테라폼 스터디가 순한맛으로 보일 정도입니다. 😅
하지만 그동안 막연하게 알고 있었던 도커 컨테이너의 격리 원리와 리눅스 네트워크와 iptables에 
대해 더 깊게 이해할 수 있어서 좋았습니다.</p>

<p><del>개인적으로 *BSD를 좋아하는데 이 정도면 FreeBSD에서도 BSD만의 docker 같은 에코시스템 구축이 가능할것 같은데
왜 못하고 있는지 의문입니다. 비슷하게 돌릴 수 있는 다양한 시도들은 많은데 흐지부지 되는 이유는 대체 무엇인지..</del></p>

<p>항상 무언가를 배우는것은 즐겁습니다. 다음 스터디도 기대됩니다! <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20" loading="lazy"></p>

  </div>

  <div id="toc-minimap" class="toc-minimap collapsed">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0">들어가며</a></li>
<li class="toc-entry toc-h2">
<a href="#%EB%8F%84%EC%BB%A4-%EC%86%8C%EA%B0%9C">도커 소개</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%EB%8F%84%EC%BB%A4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">도커란 무엇인가?</a></li>
<li class="toc-entry toc-h3"><a href="#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0">컨테이너와 가상 머신</a></li>
<li class="toc-entry toc-h3"><a href="#%EB%8F%84%EC%BB%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90">도커 아키텍쳐</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%EB%8F%84%EC%BB%A4-%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9">도커 기본 사용</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%EB%8F%84%EC%BB%A4-%EC%84%A4%EC%B9%98-%EB%B0%8F-%ED%99%95%EC%9D%B8">도커 설치 및 확인</a></li>
<li class="toc-entry toc-h3"><a href="#%EB%8F%84%EC%BB%A4%EB%A5%BC-%EB%B9%84-root-%EC%9C%A0%EC%A0%80%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0">도커를 비 root 유저로 관리하기</a></li>
<li class="toc-entry toc-h3"><a href="#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EA%B0%80-host%EC%9D%98-docker-socket-file-%EA%B3%B5%EC%9C%A0%EB%A1%9C-%EB%8F%84%EC%BB%A4-%EC%8B%A4%ED%96%89">컨테이너가 host의 docker socket file 공유로 도커 실행</a></li>
<li class="toc-entry toc-h3"><a href="#cpu-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90">CPU 아키텍쳐</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B2%A9%EB%A6%AC">컨테이너 격리</a>
<ul>
<li class="toc-entry toc-h3"><a href="#chroot">chroot</a></li>
<li class="toc-entry toc-h3">
<a href="#%EB%A7%88%EC%9A%B4%ED%8A%B8-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4--pivot_root">마운트 네임스페이스 + pivot_root</a>
<ul>
<li class="toc-entry toc-h4"><a href="#%EC%8B%A4%EC%8A%B5">실습</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-namespace">네임스페이스 (namespace)</a></li>
<li class="toc-entry toc-h3"><a href="#cgroup-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9E%90%EC%9B%90%EA%B4%80%EB%A6%AC">cgroup 를 이용한 자원관리</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC--iptables">컨테이너 네트워크 &amp; Iptables</a>
<ul>
<li class="toc-entry toc-h3"><a href="#red--blue-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B0%84-%ED%86%B5%EC%8B%A0">Red &lt;=&gt; Blue 네트워크 네임스페이스 간 통신</a></li>
<li class="toc-entry toc-h3"><a href="#red---bridge-br0---blue-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B0%84-%ED%86%B5%EC%8B%A0">Red &lt;- Bridge (br0) -&gt; Blue 네트워크 네임스페이스 간 통신</a></li>
<li class="toc-entry toc-h3"><a href="#%ED%98%B8%EC%8A%A4%ED%8A%B8--redblue-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A1%9C-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0">호스트 &lt;=&gt; RED/BLUE 네트워크 네임스페이스로 접근하기</a></li>
<li class="toc-entry toc-h3"><a href="#redblue%EC%97%90%EC%84%9C-%EC%99%B8%EB%B6%80-%EC%9D%B8%ED%84%B0%EB%84%B7-%ED%86%B5%EC%8B%A0">RED/BLUE에서 외부 인터넷 통신</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
</ul>
  </div>
<a class="u-url" href="/posts/2024-08-27-KANS-Study-Week1/" hidden></a>
</article>



<div class="PageNavigation">
  
  <a class="prev" href="/posts/2024-08-03-T101-Study-Terraform-Week-8/">« [T101 4기] OpenTofu</a>
  
  
</div>

<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = "https://sweetlittlebird.github.io/posts/2024-08-27-KANS-Study-Week1/";
this.page.identifier = "/posts/KANS Study - Week1";
};
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Sweet Little Bird</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Sweet Little Bird</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/sweetlittlebird"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">sweetlittlebird</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>공부 기록과 개발 이야기를 담은 블로그입니다.</p>
      </div>
    </div>

  </div>

</footer>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EWGY9N8QXY"></script>

    
    <script src="/assets/dist/app.min.js"></script>
    
  
    <a href="#" id="back-to-top"><span>Back to Top</span></a>
  </body>

</html>
