<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[KANS 3기] K8S Service : ClusterIP, NodePort | Sweet Little Bird</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="[KANS 3기] K8S Service : ClusterIP, NodePort">
<meta property="og:locale" content="ko">
<meta name="description" content="지난주에 이어 이번주에는 Kubernetes의 Service, 그 중에 ClusterIP, NodePort에 대해 알아보겠습니다.">
<meta property="og:description" content="지난주에 이어 이번주에는 Kubernetes의 Service, 그 중에 ClusterIP, NodePort에 대해 알아보겠습니다.">
<link rel="canonical" href="https://sweetlittlebird.github.io/posts/2024-09-27-KANS-Study-Week4/">
<meta property="og:url" content="https://sweetlittlebird.github.io/posts/2024-09-27-KANS-Study-Week4/">
<meta property="og:site_name" content="Sweet Little Bird">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-09-27T01:00:18+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="[KANS 3기] K8S Service : ClusterIP, NodePort">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-27T01:00:18+09:00","datePublished":"2024-09-27T01:00:18+09:00","description":"지난주에 이어 이번주에는 Kubernetes의 Service, 그 중에 ClusterIP, NodePort에 대해 알아보겠습니다.","headline":"[KANS 3기] K8S Service : ClusterIP, NodePort","mainEntityOfPage":{"@type":"WebPage","@id":"https://sweetlittlebird.github.io/posts/2024-09-27-KANS-Study-Week4/"},"url":"https://sweetlittlebird.github.io/posts/2024-09-27-KANS-Study-Week4/"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/dist/photoswipe.min.css">
  <link rel="stylesheet" href="/assets/dist/main.min.css">
  <link rel="stylesheet" href="/assets/dist/main_dark.min.css" media="(prefers-color-scheme: dark)">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pretendard/1.3.9/static/pretendard.css" integrity="sha512-NzqTHTrO48HsIamogmIaVhTXoSgRF24Cn+ynrNYrFuKrY0AdDbmcNieiOHsQARS/r0Gax9VwV3/rVMHs3ipUlg==" crossorigin="anonymous" referrerpolicy="no-referrer">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!--  <link href="https://fonts.googleapis.com/css2?family=Elsie+Swash+Caps:wght@400;900&display=swap" rel="stylesheet">-->
  <link href="https://fonts.googleapis.com/css2?family=Elsie+Swash+Caps:wght@400;900&amp;family=Milonga&amp;display=swap" rel="stylesheet">

  <link rel="shortcut icon" href="/assets/favicon/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/favicon/favicon.ico" type="image/x-icon">
<link type="application/atom+xml" rel="alternate" href="https://sweetlittlebird.github.io/feed.xml" title="Sweet Little Bird">
</head>
<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/">Sweet Little Bird</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
<a class="page-link" href="/about/">소개</a><a class="page-link" href="/posts/">글 목록</a>
</div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">[KANS 3기] K8S Service : ClusterIP, NodePort</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-09-27T01:00:18+09:00" itemprop="datePublished">2024년 09월 27일에 작성
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div class="table-of-content">
      <header>목차</header>
      <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0">들어가며</a></li>
<li class="toc-entry toc-h2">
<a href="#k8s-service">K8S Service</a>
<ul>
<li class="toc-entry toc-h3"><a href="#service%EC%9D%98-%ED%83%84%EC%83%9D-%EB%B0%B0%EA%B2%BD">Service의 탄생 배경</a></li>
<li class="toc-entry toc-h3">
<a href="#k8s-service-%EC%A2%85%EB%A5%98">K8S Service 종류</a>
<ul>
<li class="toc-entry toc-h4"><a href="#clusterip">ClusterIP</a></li>
<li class="toc-entry toc-h4"><a href="#nodeport">NodePort</a></li>
<li class="toc-entry toc-h4"><a href="#loadbalancer">LoadBalancer</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EA%B5%AC%EC%A1%B0">서비스의 구조</a></li>
<li class="toc-entry toc-h3">
<a href="#kube-proxy-%EB%AA%A8%EB%93%9C">kube-proxy 모드</a>
<ul>
<li class="toc-entry toc-h4"><a href="#userspace-proxy-%EB%AA%A8%EB%93%9C">userspace proxy 모드</a></li>
<li class="toc-entry toc-h4"><a href="#iptables-proxy-%EB%AA%A8%EB%93%9C">iptables proxy 모드</a></li>
<li class="toc-entry toc-h4"><a href="#ipvs-proxy-%EB%AA%A8%EB%93%9C">ipvs proxy 모드</a></li>
<li class="toc-entry toc-h4"><a href="#nftables-proxy-%EB%AA%A8%EB%93%9C">nftables proxy 모드</a></li>
<li class="toc-entry toc-h4"><a href="#ebpf-%EB%AA%A8%EB%93%9C--xdp">eBPF 모드 + XDP</a></li>
</ul>
</li>
<li class="toc-entry toc-h3">
<a href="#%EC%8B%A4%EC%8A%B5">실습</a>
<ul>
<li class="toc-entry toc-h4"><a href="#%EC%8B%A4%EC%8A%B5%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95">실습환경 구축</a></li>
<li class="toc-entry toc-h4"><a href="#clusterip-%EC%8B%A4%EC%8A%B5">ClusterIP 실습</a></li>
<li class="toc-entry toc-h4"><a href="#nodeport-%EC%8B%A4%EC%8A%B5">NodePort 실습</a></li>
<li class="toc-entry toc-h4"><a href="#%ED%8C%8C%EB%93%9C%EA%B0%84-%EC%86%8D%EB%8F%84-%EC%B8%A1%EC%A0%95">파드간 속도 측정</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
</ul>
    </div>
    <h2 id="들어가며">들어가며</h2>

<p>지난주에 이어 이번주에는 Kubernetes의 Service, 그 중에 ClusterIP, NodePort에 대해 알아보겠습니다.
KANS 3기 4주차 스터디를 시작하겠습니다.</p>

<hr>

<h2 id="k8s-service">K8S Service</h2>

<p>Kubernetes의 Service는 개별 Pod에 접근하기 위한 추상화된 방법을 제공합니다.
Pod는 생성될 때마다 IP가 동적으로 할당되기 때문에 Pod의 IP를 직접 사용하는 것은 좋은 방법이 아닙니다.
Service는 Pod의 IP를 추상화하여 Pod에 접근할 수 있도록 해줍니다.</p>

<h3 id="service의-탄생-배경">Service의 탄생 배경</h3>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_4.png" alt="img.png" loading="lazy" width="766" height="228"></p>

<p>위의 그림과 같이 하나의 파드의 엔드포인트를 다른 파드 (또는 외부)에서 사용할때, 해당 파드의 IP로 지정을 하면, 파드가 재실행 될 때 IP가 변경되어 접속이 안 되서 장애가 발생하는 현상이 생깁니다.</p>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_5.png" alt="img.png" loading="lazy" width="948" height="213"></p>

<p>그래서 고정된 IP의 서비스를 만들고 서비스의 IP로 접속시 파드가 재실행되어도 안정적으로 접속할 수 있도록 하기위해서 만들어졌습니다.</p>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_6.png" alt="img.png" loading="lazy" width="741" height="241"></p>

<p>서비스는 또한 부하분산의 기능도 할 수 있습니다. 위의 그림과 같이 파드가 여러개일때 서비스 IP로 접속시 각 파드들에 부하를 분산시킬 수 있게 됩니다.</p>

<h3 id="k8s-service-종류">K8S Service 종류</h3>

<h4 id="clusterip">ClusterIP</h4>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_1.png" alt="img.png" class="w-80 image-center" loading="lazy" width="1111" height="382"></p>

<ul>
  <li>동일한 애플리케이션을 실행하는 여러 Pod에 접속을 용이하기 위해 사용합니다.</li>
  <li>ClusterIP는 Cluster 내부에서만 접근이 가능하며 외부에서는 접근이 불가능합니다.</li>
  <li>iptables 의 NAT 기능을 이용하여 Pod에 접근하며, 동일한 iptables 분산룰을 각 노드에 적용합니다.</li>
</ul>

<h4 id="nodeport">NodePort</h4>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_2.png" alt="img.png" class="w-80 image-center" loading="lazy" width="972" height="375"></p>

<ul>
  <li>NodePort는 ClusterIP와 같이 Cluster 내부에서 접근이 가능하며, 외부에서도 접근이 가능합니다.</li>
  <li>NodePort도 ClusterIP와 같이 iptables의 NAT 기능을 이용하여 Pod에 접근하며, 각 노드에 NodePort를 할당합니다.</li>
  <li>외부에서는 NodePort를 통해 각 노드에 접근 할 수 있습니다.</li>
</ul>

<h4 id="loadbalancer">LoadBalancer</h4>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_3.png" alt="img.png" class="w-80 image-center" loading="lazy" width="1157" height="362"></p>

<ul>
  <li>LoadBalancer도 외부에서 접근이 가능하며, 클라우드 서비스에서 제공하는 LoadBalancer를 사용합니다. (AWS의 경우 ELB(Elastic Load Balancer)가 사용됩니다.)</li>
  <li>온프레미스 환경에서도 MetalLB와 같은 LoadBalancer를 사용할 수 있습니다.</li>
</ul>

<h3 id="서비스의-구조">서비스의 구조</h3>

<p>서비스를 선언시 <code class="language-plaintext highlighter-rouge">port</code>와 <code class="language-plaintext highlighter-rouge">targetPort</code>, 그리고 <code class="language-plaintext highlighter-rouge">label</code> <code class="language-plaintext highlighter-rouge">selector</code> 를 사용합니다. 각각의 역할은 다음과 같습니다.</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">port</code> : 서비스가 listen 할 포트를 지정합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">targetPort</code> : 대상 파드의 port를 지정합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">label selector</code>  : 대상 파드를 특정합니다.</li>
</ul>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_7.png" alt="img.png" loading="lazy" width="824" height="221"></p>

<h3 id="kube-proxy-모드">kube-proxy 모드</h3>

<ul>
  <li>kube-proxy는 서비스 통신 동작에 대한 설정을 관리합니다. 데몬셋으로 배포되어 모든 노드에 파드가 생성됩니다.</li>
  <li>kube-proxy 모드의 종류는 userspace proxy 모드, iptables proxy 모드, ipvs proxy 모드, nftables proxy 모드 등이 있습니다.</li>
</ul>

<h4 id="userspace-proxy-모드">userspace proxy 모드</h4>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_8.png" alt="img.png" loading="lazy" width="941" height="271"></p>

<ul>
  <li>기초적인 모드이며 사용자 영역의 kube-proxy를 통해 NIC1으로 들어온 패킷을 NIC2로 전달하여 목적 파드로 전달합니다.</li>
  <li>이렇게 하는 과정에서 커널영역(netfilter)과 사용자영역(kube-proxy)를 오가는 과정에서 스위칭에 의한 오버헤드가 발생하는 단점이 있습니다.</li>
</ul>

<h4 id="iptables-proxy-모드">iptables proxy 모드</h4>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_9.png" alt="img.png" loading="lazy" width="949" height="278"></p>

<ul>
  <li>쿠버네티스 설치시 기본 모드이며, kube-proxy는  트래픽 전달에 직접 관여하지는 않고, iptables 규칙을 관리하는 역할을 합니다.</li>
  <li>iptables proxy 모드는 트래픽 전달 과정에서 kube-proxy를 경유하지 않고, 커널 영역과 사용자 영역 전환이 필요하지 않아서, 유저스페이스 proxy 모드에 비해 오버헤드가 줄어듭니다.</li>
  <li>단점으로는 iptables 규칙이 많아 질 경우 모든 규칙 평가 하는데 지연이 발생할 수 있습니다.</li>
  <li>또한 장애시 모든 규칙을 확인하기 어려워 장애 처리에 불리합니다.</li>
</ul>

<h4 id="ipvs-proxy-모드">ipvs proxy 모드</h4>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_10.png" alt="img.png" loading="lazy" width="939" height="274"></p>

<ul>
  <li>ipvs proxy 모드는 지금까지의 모드 중 가장 효율적인 모드입니다. IPVS(IP Virtual Server)는 넷필터에서 동작하는 Layer 4 로드밸런서입니다. iptables 보다 더 높은 성능 처리를 보여주고, 규칙 갯수를 줄일 수 있습니다. 또한 다양한 부하분산 알고리즘을 제공합니다.</li>
</ul>

<h4 id="nftables-proxy-모드">nftables proxy 모드</h4>
<ul>
  <li>nftables 는 iptables를 대체하기 위해 개발된 패킷 필터링 프레임워크로, iptables 보다 더 유연하고 강력한 규칙 설정을 제공합니다.</li>
  <li>하지만 아직  실험적으로 개발중인 단계로 실무에서는 ipvs proxy 모드를 권장합니다.</li>
</ul>

<h4 id="ebpf-모드--xdp">eBPF 모드 + XDP</h4>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_11.png" alt="img.png" class="w-90 image-center" loading="lazy" width="1205" height="1232"></p>

<ul>
  <li>앞에서 알아보았던 모든 모드들이 netfilter 기반인데 반해, eBPF 모드 +  XDP 는 netfilter 전 단계에서 트래픽 라우팅을 처리하여 훨씬 효율 적입니다. calico나 cilium을 사용하여서 eBPF 모드를 사용할 수 있습니다.</li>
</ul>

<h3 id="실습">실습</h3>

<h4 id="실습환경-구축">실습환경 구축</h4>

<ul>
  <li>이번 실습은 실습환경 구축의 용이성을 위해서 kind를 이용하여 실습하였습니다.</li>
  <li>실습 환경 구축은 다음과 같이 진행 하였습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># kind 클러스터 정의 파일 생성</span>
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOT</span><span class="sh">&gt; kind-svc-w3.yaml
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
featureGates:
  "InPlacePodVerticalScaling": true
  "MultiCIDRServiceAllocator": true
nodes:
- role: control-plane
  labels:
    mynode: control-plane
  extraPortMappings:
  - containerPort: 30000
    hostPort: 30000
  - containerPort: 30001
    hostPort: 30001
  - containerPort: 30002
    hostPort: 30002
  kubeadmConfigPatches:
  - |
    kind: ClusterConfiguration
    apiServer:
      extraArgs:
        runtime-config: api/all=true
- role: worker
  labels:
    mynode: worker1
- role: worker
  labels:
    mynode: worker2
- role: worker
  labels:
    mynode: worker3
networking:
  podSubnet: 10.10.0.0/16
  serviceSubnet: 10.200.1.0/24
</span><span class="no">EOT

</span><span class="c"># k8s 클러스터 설치</span>
<span class="nv">$ </span>kind create cluster <span class="nt">--config</span> kind-svc-w3.yaml <span class="nt">--name</span> myk8s <span class="nt">--image</span> kindest/node:v1.31.0
<span class="c"># =&gt; Creating cluster "myk8s" ...</span>
<span class="c">#     ✓ Ensuring node image (kindest/node:v1.31.0) 🖼</span>
<span class="c">#     ✓ Preparing nodes 📦 📦 📦 📦</span>
<span class="c">#     ✓ Writing configuration 📜</span>
<span class="c">#     ✓ Starting control-plane 🕹️</span>
<span class="c">#     ✓ Installing CNI 🔌</span>
<span class="c">#     ✓ Installing StorageClass 💾</span>
<span class="c">#     ✓ Joining worker nodes 🚜</span>
<span class="c">#    Set kubectl context to "kind-myk8s"</span>
<span class="c">#    You can now use your cluster with:</span>
<span class="c">#    </span>
<span class="c">#    kubectl cluster-info --context kind-myk8s</span>

<span class="nv">$ </span>docker ps
<span class="c"># =&gt; CONTAINER ID   IMAGE                                COMMAND                  CREATED          STATUS                 PORTS                                                            NAMES</span>
<span class="c">#    1b7e6b646e48   kindest/node:v1.31.0                 "/usr/local/bin/entr…"   18 minutes ago   Up 18 minutes                                                                           myk8s-worker</span>
<span class="c">#    5406c013a571   kindest/node:v1.31.0                 "/usr/local/bin/entr…"   18 minutes ago   Up 18 minutes          0.0.0.0:30000-30002-&gt;30000-30002/tcp, 127.0.0.1:43315-&gt;6443/tcp  myk8s-control-plane</span>
<span class="c">#    4134657c5a70   kindest/node:v1.31.0                 "/usr/local/bin/entr…"   18 minutes ago   Up 18 minutes                                                                           myk8s-worker3</span>
<span class="c">#    6caf2b177502   kindest/node:v1.31.0                 "/usr/local/bin/entr…"   18 minutes ago   Up 18 minutes                                                                           myk8s-worker2</span>

<span class="c"># 노드에 기본 툴 설치</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane sh <span class="nt">-c</span> <span class="s1">'apt update &amp;&amp; apt install tree psmisc lsof wget bridge-utils net-tools ipset ipvsadm nfacct tcpdump ngrep iputils-ping arping git vim arp-scan -y'</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> sh <span class="nt">-c</span> <span class="s1">'apt update &amp;&amp; apt install tree psmisc lsof wget bridge-utils net-tools ipset ipvsadm nfacct tcpdump ngrep iputils-ping arping -y'</span><span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>

<span class="c"># k8s v1.31.0 버전 확인</span>
<span class="nv">$ </span>kubectl get node
<span class="c"># =&gt; NAME                  STATUS   ROLES           AGE   VERSION</span>
<span class="c">#    myk8s-control-plane   Ready    control-plane   40m   v1.31.0</span>
<span class="c">#    myk8s-worker          Ready    &lt;none&gt;          40m   v1.31.0</span>
<span class="c">#    myk8s-worker2         Ready    &lt;none&gt;          40m   v1.31.0</span>
<span class="c">#    myk8s-worker3         Ready    &lt;none&gt;          40m   v1.31.0</span>

<span class="c"># 노드 labels 확인</span>
<span class="nv">$ </span>kubectl get nodes <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.items[*].metadata.labels}"</span> | <span class="nb">grep </span>mynode
<span class="nv">$ </span>kubectl get nodes <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.items[*].metadata.labels}"</span> | jq | <span class="nb">grep </span>mynode
<span class="c"># =&gt;   "mynode": "control-plane",</span>
<span class="c">#      "mynode": "worker1"</span>
<span class="c">#      "mynode": "worker2"</span>
<span class="c">#      "mynode": "worker3"</span>

<span class="c"># kind network 중 컨테이너(노드) IP(대역) 확인 : 172.18.0.2~ 부터 할당되며, control-plane 이 꼭 172.18.0.2가 안될 수 도 있음</span>
<span class="nv">$ </span>docker ps <span class="nt">-q</span> | xargs docker inspect <span class="nt">--format</span> <span class="s1">' '</span>
<span class="c"># =&gt; /myk8s-control-plane 172.23.0.2</span>
<span class="c">#    /myk8s-worker 172.23.0.4</span>
<span class="c">#    /myk8s-worker2 172.23.0.5</span>
<span class="c">#    /myk8s-worker3 172.23.0.3</span>
    
<span class="c"># 파드CIDR 과 Service 대역 확인 : CNI는 kindnet 사용</span>
<span class="nv">$ </span>kubectl get cm <span class="nt">-n</span> kube-system kubeadm-config <span class="nt">-oyaml</span> | <span class="nb">grep</span> <span class="nt">-i</span> subnet
<span class="c"># =&gt;       podSubnet: 10.10.0.0/16</span>
<span class="c">#          serviceSubnet: 10.200.1.0/24</span>
<span class="nv">$ </span>kubectl cluster-info dump | <span class="nb">grep</span> <span class="nt">-m</span> 2 <span class="nt">-E</span> <span class="s2">"cluster-cidr|service-cluster-ip-range"</span>
<span class="c"># =&gt;                             "--service-cluster-ip-range=10.200.1.0/24",</span>
<span class="c">#                                "--cluster-cidr=10.10.0.0/16",</span>

<span class="c"># feature-gates 확인 : https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/</span>
<span class="nv">$ </span>kubectl describe pod <span class="nt">-n</span> kube-system | <span class="nb">grep </span>feature-gates
<span class="c"># =&gt;       --feature-gates=InPlacePodVerticalScaling=true,MultiCIDRServiceAllocator=true</span>
<span class="nv">$ </span>kubectl describe pod <span class="nt">-n</span> kube-system | <span class="nb">grep </span>runtime-config
<span class="c"># =&gt;       --runtime-config=api/all=true</span>

<span class="c"># MultiCIDRServiceAllocator : https://kubernetes.io/docs/tasks/network/extend-service-ip-ranges/</span>
<span class="nv">$ </span>kubectl get servicecidr
<span class="c"># =&gt; NAME         CIDRS           AGE</span>
<span class="c">#    kubernetes   10.200.1.0/24   62m</span>

<span class="c"># 노드마다 할당된 dedicated subnet (podCIDR) 확인</span>
<span class="nv">$ </span>kubectl get nodes <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.items[*].spec.podCIDR}"</span>
<span class="c"># =&gt; 10.10.0.0/24 10.10.4.0/24 10.10.1.0/24 10.10.2.0/24</span>

<span class="c"># kube-proxy configmap 확인</span>
<span class="nv">$ </span>kubectl describe cm <span class="nt">-n</span> kube-system kube-proxy
<span class="c"># =&gt; ...</span>
<span class="c">#    iptables:</span>
<span class="c">#      localhostNodePorts: null</span>
<span class="c">#      masqueradeAll: false</span>
<span class="c">#      masqueradeBit: null</span>
<span class="c">#      minSyncPeriod: 1s</span>
<span class="c">#      syncPeriod: 0s</span>
<span class="c">#    mode: iptables</span>
<span class="c">#    ...</span>

<span class="c"># kube-proxy가 iptables 모드로 동작중임을 확인할 수 있습니다.</span>

<span class="c"># 노드 별 네트워트 정보 확인 : CNI는 kindnet 사용</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> <span class="nb">ls</span> /opt/cni/bin/<span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> <span class="nb">cat</span> /etc/cni/net.d/10-kindnet.conflist<span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> ip <span class="nt">-c</span> route<span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> ip <span class="nt">-c</span> addr<span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> ip <span class="nt">-c</span> <span class="nt">-4</span> addr show dev eth0<span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>

<span class="c"># iptables 정보 확인</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>filter nat mangle raw <span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; IPTables Type : </span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane  iptables <span class="nt">-t</span> <span class="nv">$i</span> <span class="nt">-S</span> <span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>filter nat mangle raw <span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; IPTables Type : </span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker  iptables <span class="nt">-t</span> <span class="nv">$i</span> <span class="nt">-S</span> <span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>filter nat mangle raw <span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; IPTables Type : </span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker2 iptables <span class="nt">-t</span> <span class="nv">$i</span> <span class="nt">-S</span> <span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>filter nat mangle raw <span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; IPTables Type : </span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker3 iptables <span class="nt">-t</span> <span class="nv">$i</span> <span class="nt">-S</span> <span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>

<span class="c"># 각 노드 bash 접속</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane bash
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker bash
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker2 bash
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker3 bash
<span class="nt">----------------------------------------</span>
<span class="nv">$ </span><span class="nb">exit</span>
<span class="nt">----------------------------------------</span>

<span class="c"># kind 설치 시 kind 이름의 도커 브리지가 생성됩니다. : 172.18.0.0/16 대역</span>
<span class="nv">$ </span>docker network <span class="nb">ls</span>
<span class="c"># =&gt; NETWORK ID     NAME                           DRIVER    SCOPE</span>
<span class="c">#    ...</span>
<span class="c">#    1c5d73657215   kind                           bridge    local</span>

<span class="nv">$ </span>docker inspect kind
<span class="c"># =&gt; [</span>
<span class="c">#        {</span>
<span class="c">#            "Name": "kind",</span>
<span class="c">#            ...</span>
<span class="c">#            "IPAM": {</span>
<span class="c">#                ...</span>
<span class="c">#                "Config": [</span>
<span class="c">#                    {</span>
<span class="c">#                        "Subnet": "172.23.0.0/16",</span>
<span class="c">#                        "Gateway": "172.23.0.1"</span>
<span class="c">#                    }</span>
<span class="c">#                ]</span>
<span class="c">#            },</span>
<span class="c">#            ...</span>
<span class="c">#            "Containers": {</span>
<span class="c">#                "1b7e6b646e4867591b5dd2a3bb4fcd2223dfcfd36dc08d86c8efc8fdc2112462": {</span>
<span class="c">#                    "Name": "myk8s-worker",</span>
<span class="c">#                    "IPv4Address": "172.23.0.4/16",</span>
<span class="c">#                },</span>
<span class="c">#                "4134657c5a7049d20944c2f80d3a3183a91a70107a47be72888e5c5fa972312a": {</span>
<span class="c">#                    "Name": "myk8s-worker3",</span>
<span class="c">#                    "IPv4Address": "172.23.0.3/16",</span>
<span class="c">#                },</span>
<span class="c">#                "5406c013a57167caf9a94ee9e89e550899a6efed9386f35548f03d2f670e8196": {</span>
<span class="c">#                    "Name": "myk8s-control-plane",</span>
<span class="c">#                    "IPv4Address": "172.23.0.2/16",</span>
<span class="c">#                },</span>
<span class="c">#                "6caf2b177502b92eccd4353ae3f4b3ac2da2949fc840225a02c9e83e1d24b09a": {</span>
<span class="c">#                    "Name": "myk8s-worker2",</span>
<span class="c">#                    "IPv4Address": "172.23.0.5/16",</span>
<span class="c">#                }</span>
<span class="c">#            },</span>
<span class="c">#            ...</span>
<span class="c">#        }</span>
<span class="c">#    ]</span>

<span class="c"># arp scan 해두기</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane arp-scan <span class="nt">--interfac</span><span class="o">=</span>eth0 <span class="nt">--localnet</span>
<span class="c"># =&gt; Interface: eth0, type: EN10MB, MAC: 02:42:ac:17:00:02, IPv4: 172.23.0.2</span>
<span class="c">#    Starting arp-scan 1.10.0 with 65536 hosts (https://github.com/royhills/arp-scan)</span>
<span class="c">#    172.23.0.1	02:42:a4:3f:b3:d9	(Unknown: locally administered)</span>
<span class="c">#    172.23.0.3	02:42:ac:17:00:03	(Unknown: locally administered)</span>
<span class="c">#    172.23.0.4	02:42:ac:17:00:04	(Unknown: locally administered)</span>
<span class="c">#    172.23.0.5	02:42:ac:17:00:05	(Unknown: locally administered)</span>

<span class="c"># mypc 컨테이너 기동 : kind 도커 브리지를 사용하고, 컨테이너 IP를 직접 지정</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">--rm</span> <span class="nt">--name</span> mypc <span class="nt">--network</span> kind <span class="nt">--ip</span> 172.23.0.100 nicolaka/netshoot <span class="nb">sleep </span>infinity
<span class="nv">$ </span>docker ps
<span class="c">## 만약 kind 네트워크 대역이 다를 경우 위 IP 지정이 실패할 수 있으니, 그냥 IP 지정 없이 mypc 컨테이너 기동 할 것</span>
<span class="c">## docker run -d --rm --name mypc --network kind nicolaka/netshoot sleep infinity</span>

<span class="c"># 통신 확인</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc ping <span class="nt">-c</span> 1 172.23.0.1
<span class="c"># =&gt; PING 172.23.0.1 (172.23.0.1) 56(84) bytes of data.</span>
<span class="c">#    64 bytes from 172.23.0.1: icmp_seq=1 ttl=64 time=0.154 ms</span>
<span class="c">#    </span>
<span class="c">#    --- 172.23.0.1 ping statistics ---</span>
<span class="c">#    1 packets transmitted, 1 received, 0% packet loss, time 0ms</span>
<span class="c">#    rtt min/avg/max/mdev = 0.154/0.154/0.154/0.000 ms</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..5<span class="o">}</span> <span class="p">;</span> <span class="k">do </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc ping <span class="nt">-c</span> 1 172.23.0.<span class="nv">$i</span><span class="p">;</span> <span class="k">done</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc zsh
<span class="nt">-------------</span>
<span class="nv">$ </span>ifconfig
<span class="c"># =&gt; eth0      Link encap:Ethernet  HWaddr 02:42:AC:17:00:06  </span>
<span class="c">#              inet addr:172.23.0.6  Bcast:172.23.255.255  Mask:255.255.0.0</span>
<span class="c">#    ...</span>
<span class="nv">$ </span>ping <span class="nt">-c</span> 1 172.23.0.2
<span class="c"># =&gt; PING 172.23.0.2 (172.23.0.2) 56(84) bytes of data.</span>
<span class="c">#    64 bytes from 172.23.0.2: icmp_seq=1 ttl=64 time=0.258 ms</span>
<span class="c">#    </span>
<span class="c">#    --- 172.23.0.2 ping statistics ---</span>
<span class="c">#    1 packets transmitted, 1 received, 0% packet loss, time 0ms</span>
<span class="c">#    rtt min/avg/max/mdev = 0.258/0.258/0.258/0.000 ms</span>
<span class="nv">$ </span><span class="nb">exit</span>
<span class="nt">-------------</span>

<span class="c"># kube-ops-view 설치</span>
<span class="nv">$ </span>helm repo add geek-cookbook https://geek-cookbook.github.io/charts/
<span class="c"># =&gt; "geek-cookbook" has been added to your repositories</span>
<span class="nv">$ </span>helm <span class="nb">install </span>kube-ops-view geek-cookbook/kube-ops-view <span class="nt">--version</span> 1.2.2 <span class="nt">--set</span> service.main.type<span class="o">=</span>NodePort,service.main.ports.http.nodePort<span class="o">=</span>30000 <span class="nt">--set</span> env.TZ<span class="o">=</span><span class="s2">"Asia/Seoul"</span> <span class="nt">--namespace</span> kube-system
<span class="c"># =&gt; NAME: kube-ops-view</span>
<span class="c">#    ...</span>
<span class="c">#    1. Get the application URL by running these commands:</span>
<span class="c">#      export NODE_PORT=$(kubectl get --namespace kube-system -o jsonpath="{.spec.ports[0].nodePort}" services kube-ops-view)</span>
<span class="c">#      export NODE_IP=$(kubectl get nodes --namespace kube-system -o jsonpath="{.items[0].status.addresses[0].address}")</span>
<span class="c">#      echo http://$NODE_IP:$NODE_PORT</span>

<span class="c"># myk8s-control-plane 배치</span>
<span class="nv">$ </span>kubectl <span class="nt">-n</span> kube-system edit deploy kube-ops-view
<span class="nt">---</span>
spec:
  ...
  template:
    ...
    spec:
      nodeSelector:
        mynode: control-plane
      tolerations:
      - key: <span class="s2">"node-role.kubernetes.io/control-plane"</span>
        operator: <span class="s2">"Equal"</span>
        effect: <span class="s2">"NoSchedule"</span>
<span class="nt">---</span>

<span class="c"># 설치 확인</span>
<span class="nv">$ </span>kubectl <span class="nt">-n</span> kube-system get pod <span class="nt">-o</span> wide <span class="nt">-l</span> app.kubernetes.io/instance<span class="o">=</span>kube-ops-view
<span class="c"># =&gt; NAME                             READY   STATUS    RESTARTS   AGE   IP          NODE                  NOMINATED NODE   READINESS GATES</span>
<span class="c">#    kube-ops-view-58f96c464d-t5t68   1/1     Running   0          30s   10.10.0.5   myk8s-control-plane   &lt;none&gt;           &lt;none&gt;</span>

<span class="c"># kube-ops-view 접속 URL 확인 (1.5 , 2 배율) : macOS 사용자</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"KUBE-OPS-VIEW URL = http://localhost:30000/#scale=1.5"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"KUBE-OPS-VIEW URL = http://localhost:30000/#scale=2"</span>

<span class="c"># kube-ops-view 접속 URL 확인 (1.5 , 2 배율) : Windows 사용자</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"KUBE-OPS-VIEW URL = http://192.168.50.10:30000/#scale=1.5"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"KUBE-OPS-VIEW URL = http://192.168.50.10:30000/#scale=2"</span>

</code></pre></div></div>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_12.png" alt="img.png" loading="lazy" width="698" height="265"></p>

<h4 id="clusterip-실습">ClusterIP 실습</h4>

<ul>
  <li>앞에서 알아본 ClusterIP 타입에 대해 실습해 보겠습니다.</li>
  <li>다음의 사항들을 살펴볼 것입니다.
    <ul>
      <li>ClusterIP의 서비스의 경우 클러스터 내부에서만 접근이 가능한 특성이 있습니다.</li>
      <li>IP로도 접속할 수 있지만 도메인 명으로도 접속이 가능합니다.</li>
      <li>서비스 타입(ClusterIP)을 생성하면 apiserver ⇒ (kubelet) ⇒ kube-proxy ⇒ iptables 에 rule 이 생성 됩니다.</li>
      <li>모든 노드(컨트롤 플레인 포함) 에 iptables rule이 설정 되므로, 파드에서 접속 시 해당 노드에 존재하는 iptables rule 에 의해 분산 접속됩니다.</li>
    </ul>
  </li>
  <li>실습 구성
    <ul>
      <li>
        <p>목적지(backend) 파드 (pod) 생성 : 3pod.yml</p>

        <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c1"># 3pod.yml</span>
  <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
  <span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">webpod1</span>
    <span class="na">labels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">webpod</span>
  <span class="na">spec</span><span class="pi">:</span>
    <span class="na">nodeName</span><span class="pi">:</span> <span class="s">myk8s-worker</span>
    <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">container</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">traefik/whoami</span>
    <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">0</span>
  <span class="s">---</span>
  <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
  <span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">webpod2</span>
    <span class="na">labels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">webpod</span>
  <span class="na">spec</span><span class="pi">:</span>
    <span class="na">nodeName</span><span class="pi">:</span> <span class="s">myk8s-worker2</span>
    <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">container</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">traefik/whoami</span>
    <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">0</span>
  <span class="s">---</span>
  <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
  <span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">webpod3</span>
    <span class="na">labels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">webpod</span>
  <span class="na">spec</span><span class="pi">:</span>
    <span class="na">nodeName</span><span class="pi">:</span> <span class="s">myk8s-worker3</span>
    <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">container</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">traefik/whoami</span>
    <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">0</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>클라이언트 생성 : netpod.yml</p>

        <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c1"># netpod.yml</span>
  <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
  <span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">net-pod</span>
  <span class="na">spec</span><span class="pi">:</span>
    <span class="na">nodeName</span><span class="pi">:</span> <span class="s">myk8s-control-plane</span>
    <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">netshoot-pod</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">nicolaka/netshoot</span>
      <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">tail"</span><span class="pi">]</span>
      <span class="na">args</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">-f"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">/dev/null"</span><span class="pi">]</span>
    <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">0</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>서비스(ClusterIP) 생성 : svc-clusterip.yml</p>

        <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c1"># svc-clusterip.yml</span>
  <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
  <span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">svc-clusterip</span>
  <span class="na">spec</span><span class="pi">:</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">svc-webport</span>
        <span class="na">port</span><span class="pi">:</span> <span class="m">9000</span>        <span class="c1"># 서비스 IP 에 접속 시 사용하는 포트 port 를 의미</span>
        <span class="na">targetPort</span><span class="pi">:</span> <span class="m">80</span>    <span class="c1"># 타킷 targetPort 는 서비스를 통해서 목적지 파드로 접속 시 해당 파드로 접속하는 포트를 의미</span>
    <span class="na">selector</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">webpod</span>         <span class="c1"># 셀렉터 아래 app:webpod 레이블이 설정되어 있는 파드들은 해당 서비스에 연동됨</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">ClusterIP</span>       <span class="c1"># 서비스 타입</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>생성 및 확인</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># 모니터링</span>
  <span class="nv">$ </span><span class="k">**</span>watch <span class="nt">-d</span> <span class="s1">'kubectl get pod -owide ;echo; kubectl get svc,ep svc-clusterip'</span><span class="k">**</span>
      
  <span class="c"># 생성</span>
  <span class="nv">$ </span>kubectl apply <span class="nt">-f</span> 3pod.yml,netpod.yml,svc-clusterip.yml
  <span class="c"># =&gt; pod/webpod1 created</span>
  <span class="c">#    pod/webpod2 created</span>
  <span class="c">#    pod/webpod3 created</span>
  <span class="c">#    pod/net-pod created</span>
  <span class="c">#    service/svc-clusterip created</span>
      
  <span class="c"># 파드와 서비스 사용 네트워크 대역 정보 확인 </span>
  <span class="nv">$ </span>kubectl cluster-info dump | <span class="nb">grep</span> <span class="nt">-m</span> 2 <span class="nt">-E</span> <span class="s2">"cluster-cidr|service-cluster-ip-range"</span>
  <span class="c"># =&gt; "--service-cluster-ip-range=10.200.1.0/24",</span>
  <span class="c">#    "--cluster-cidr=10.10.0.0/16",</span>
      
  <span class="c"># 확인</span>
  <span class="nv">$ </span>kubectl get pod <span class="nt">-owide</span>
  <span class="c"># =&gt; NAME      READY   STATUS    RESTARTS   AGE    IP          NODE                  NOMINATED NODE   READINESS GATES</span>
  <span class="c">#    net-pod   1/1     Running   0          2m8s   10.10.0.7   myk8s-control-plane   &lt;none&gt;           &lt;none&gt;</span>
  <span class="c">#    webpod1   1/1     Running   0          2m8s   10.10.4.3   myk8s-worker          &lt;none&gt;           &lt;none&gt;</span>
  <span class="c">#    webpod2   1/1     Running   0          2m8s   10.10.1.4   myk8s-worker2         &lt;none&gt;           &lt;none&gt;</span>
  <span class="c">#    webpod3   1/1     Running   0          2m8s   10.10.2.3   myk8s-worker3         &lt;none&gt;           &lt;none&gt;</span>
  <span class="nv">$ </span>kubectl get svc svc-clusterip
  <span class="c"># =&gt; NAME            TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE</span>
  <span class="c">#    svc-clusterip   ClusterIP   10.200.1.96   &lt;none&gt;        9000/TCP   2m15s</span>
      
  <span class="c"># spec.ports.port 와 spec.ports.targetPort 가 어떤 의미인지 꼭 이해하자!</span>
  <span class="nv">$ </span>kubectl describe svc svc-clusterip
  <span class="c"># =&gt; Name:              svc-clusterip</span>
  <span class="c">#    Namespace:         default</span>
  <span class="c">#    Labels:            &lt;none&gt;</span>
  <span class="c">#    Annotations:       &lt;none&gt;</span>
  <span class="c">#    Selector:          app=webpod</span>
  <span class="c">#    Type:              ClusterIP</span>
  <span class="c">#    IP Family Policy:  SingleStack</span>
  <span class="c">#    IP Families:       IPv4</span>
  <span class="c">#    IP:                10.200.1.96</span>
  <span class="c">#    IPs:               10.200.1.96</span>
  <span class="c">#    Port:              svc-webport  9000/TCP                    # service의 listening port</span>
  <span class="c">#    TargetPort:        80/TCP                                   # pod의 실제 port</span>
  <span class="c">#    Endpoints:         10.10.1.4:80,10.10.2.3:80,10.10.4.3:80   # pod의 ip:port 목록</span>
  <span class="c">#    Session Affinity:  None</span>
  <span class="c">#    Events:            &lt;none&gt;</span>
      
  <span class="c"># 서비스 생성 시 엔드포인트를 자동으로 생성, 물론 수동으로 설정 생성도 가능</span>
  <span class="nv">$ </span>kubectl get endpoints svc-clusterip
  <span class="c"># =&gt; NAME            ENDPOINTS                                AGE</span>
  <span class="c">#    svc-clusterip   10.10.1.4:80,10.10.2.3:80,10.10.4.3:80   3m32s</span>
  <span class="nv">$ </span>kubectl get endpointslices <span class="nt">-l</span> kubernetes.io/service-name<span class="o">=</span>svc-clusterip
  <span class="c"># =&gt; NAME                  ADDRESSTYPE   PORTS   ENDPOINTS                       AGE</span>
  <span class="c">#    svc-clusterip-xxvws   IPv4          80      10.10.4.3,10.10.1.4,10.10.2.3   3m39s</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_13.png" alt="img.png" loading="lazy" width="799" height="270"></p>

<ul>
  <li>서비스 (ClusterIP) 접속 확인
    <ul>
      <li>
        <p>클라이언트 (TestPod)의 Shell 에 접속하여 서비스(ClusterIP) 부하분산 접속 확인</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># webpod 파드의 IP 를 출력</span>
  <span class="nv">$ </span>kubectl get pod <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>webpod <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.items[*].status.podIP}"</span>
  <span class="c"># =&gt; 10.10.4.3 10.10.1.4 10.10.2.3</span>
      
  <span class="c"># webpod 파드의 IP를 변수에 지정</span>
  <span class="nv">$ WEBPOD1</span><span class="o">=</span><span class="si">$(</span>kubectl get pod webpod1 <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">={</span>.status.podIP<span class="o">}</span><span class="si">)</span>
  <span class="nv">$ WEBPOD2</span><span class="o">=</span><span class="si">$(</span>kubectl get pod webpod2 <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">={</span>.status.podIP<span class="o">}</span><span class="si">)</span>
  <span class="nv">$ WEBPOD3</span><span class="o">=</span><span class="si">$(</span>kubectl get pod webpod3 <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">={</span>.status.podIP<span class="o">}</span><span class="si">)</span>
  <span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$WEBPOD1</span> <span class="nv">$WEBPOD2</span> <span class="nv">$WEBPOD3</span>
  <span class="c"># =&gt; 10.10.4.3 10.10.1.4 10.10.2.3</span>
      
  <span class="c"># net-pod 파드에서 webpod 파드의 IP로 직접 curl 로 반복 접속</span>
  <span class="nv">$ </span><span class="k">for </span>pod <span class="k">in</span> <span class="nv">$WEBPOD1</span> <span class="nv">$WEBPOD2</span> <span class="nv">$WEBPOD3</span><span class="p">;</span> <span class="k">do </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> curl <span class="nt">-s</span> <span class="nv">$pod</span><span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; Hostname: webpod1</span>
  <span class="c">#    IP: 10.10.4.3</span>
  <span class="c">#    RemoteAddr: 10.10.0.7:56374</span>
  <span class="c">#    GET / HTTP/1.1</span>
  <span class="c">#    Host: 10.10.4.3</span>
  <span class="c">#    User-Agent: curl/8.7.1</span>
  <span class="c">#    Accept: */*</span>
  <span class="c">#    </span>
  <span class="c">#    Hostname: webpod2</span>
  <span class="c">#    ...</span>
  <span class="c">#    Hostname: webpod3</span>
  <span class="c">#    ...</span>
  <span class="nv">$ </span><span class="k">for </span>pod <span class="k">in</span> <span class="nv">$WEBPOD1</span> <span class="nv">$WEBPOD2</span> <span class="nv">$WEBPOD3</span><span class="p">;</span> <span class="k">do </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> curl <span class="nt">-s</span> <span class="nv">$pod</span> | <span class="nb">grep </span>Hostname<span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; Hostname: webpod1</span>
  <span class="c">#    Hostname: webpod2</span>
  <span class="c">#    Hostname: webpod3</span>
  <span class="nv">$ </span><span class="k">for </span>pod <span class="k">in</span> <span class="nv">$WEBPOD1</span> <span class="nv">$WEBPOD2</span> <span class="nv">$WEBPOD3</span><span class="p">;</span> <span class="k">do </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> curl <span class="nt">-s</span> <span class="nv">$pod</span> | <span class="nb">grep </span>Host<span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; Hostname: webpod1</span>
  <span class="c">#    Host: 10.10.4.3</span>
  <span class="c">#    Hostname: webpod2</span>
  <span class="c">#    Host: 10.10.1.4</span>
  <span class="c">#    Hostname: webpod3</span>
  <span class="c">#    Host: 10.10.2.3</span>
  <span class="nv">$ </span><span class="k">for </span>pod <span class="k">in</span> <span class="nv">$WEBPOD1</span> <span class="nv">$WEBPOD2</span> <span class="nv">$WEBPOD3</span><span class="p">;</span> <span class="k">do </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> curl <span class="nt">-s</span> <span class="nv">$pod</span> | egrep <span class="s1">'Host|RemoteAddr'</span><span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; Hostname: webpod1</span>
  <span class="c">#    RemoteAddr: 10.10.0.7:36382</span>
  <span class="c">#    Host: 10.10.4.3</span>
  <span class="c">#    Hostname: webpod2</span>
  <span class="c">#    RemoteAddr: 10.10.0.7:52122</span>
  <span class="c">#    Host: 10.10.1.4</span>
  <span class="c">#    Hostname: webpod3</span>
  <span class="c">#    RemoteAddr: 10.10.0.7:55962</span>
  <span class="c">#    Host: 10.10.2.3</span>
      
  <span class="c"># 서비스 IP 변수 지정 : svc-clusterip 의 ClusterIP주소</span>
  <span class="nv">$ SVC1</span><span class="o">=</span><span class="si">$(</span>kubectl get svc svc-clusterip <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">={</span>.spec.clusterIP<span class="o">}</span><span class="si">)</span>
  <span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$SVC1</span>
  <span class="c"># =&gt; 10.200.1.96</span>
      
  <span class="c"># 위 서비스 생성 시 kube-proxy 에 의해서 iptables 규칙이 모든 노드에 추가됨 </span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep</span> <span class="nv">$SVC1</span>
  <span class="c"># =&gt; -A KUBE-SERVICES -d 10.200.1.96/32 -p tcp -m comment --comment "default/svc-clusterip:svc-webport cluster IP" -m tcp --dport 9000 -j KUBE-SVC-KBDEBIL6IU6WL7RF</span>
  <span class="c">#    -A KUBE-SVC-KBDEBIL6IU6WL7RF ! -s 10.10.0.0/16 -d 10.200.1.96/32 -p tcp -m comment --comment "default/svc-clusterip:svc-webport cluster IP" -m tcp --dport 9000 -j KUBE-MARK-MASQ</span>
  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep</span> <span class="nv">$SVC1</span><span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; &gt;&gt; node myk8s-control-plane &lt;&lt;</span>
  <span class="c">#    -A KUBE-SERVICES -d 10.200.1.96/32 -p tcp -m comment --comment "default/svc-clusterip:svc-webport cluster IP" -m tcp --dport 9000 -j KUBE-SVC-KBDEBIL6IU6WL7RF</span>
  <span class="c">#    -A KUBE-SVC-KBDEBIL6IU6WL7RF ! -s 10.10.0.0/16 -d 10.200.1.96/32 -p tcp -m comment --comment "default/svc-clusterip:svc-webport cluster IP" -m tcp --dport 9000 -j KUBE-MARK-MASQ</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker &lt;&lt;</span>
  <span class="c">#    -A KUBE-SERVICES -d 10.200.1.96/32 -p tcp -m comment --comment "default/svc-clusterip:svc-webport cluster IP" -m tcp --dport 9000 -j KUBE-SVC-KBDEBIL6IU6WL7RF</span>
  <span class="c">#    -A KUBE-SVC-KBDEBIL6IU6WL7RF ! -s 10.10.0.0/16 -d 10.200.1.96/32 -p tcp -m comment --comment "default/svc-clusterip:svc-webport cluster IP" -m tcp --dport 9000 -j KUBE-MARK-MASQ</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker2 &lt;&lt;</span>
  <span class="c">#    -A KUBE-SERVICES -d 10.200.1.96/32 -p tcp -m comment --comment "default/svc-clusterip:svc-webport cluster IP" -m tcp --dport 9000 -j KUBE-SVC-KBDEBIL6IU6WL7RF</span>
  <span class="c">#    -A KUBE-SVC-KBDEBIL6IU6WL7RF ! -s 10.10.0.0/16 -d 10.200.1.96/32 -p tcp -m comment --comment "default/svc-clusterip:svc-webport cluster IP" -m tcp --dport 9000 -j KUBE-MARK-MASQ</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker3 &lt;&lt;</span>
  <span class="c">#    -A KUBE-SERVICES -d 10.200.1.96/32 -p tcp -m comment --comment "default/svc-clusterip:svc-webport cluster IP" -m tcp --dport 9000 -j KUBE-SVC-KBDEBIL6IU6WL7RF</span>
  <span class="c">#    -A KUBE-SVC-KBDEBIL6IU6WL7RF ! -s 10.10.0.0/16 -d 10.200.1.96/32 -p tcp -m comment --comment "default/svc-clusterip:svc-webport cluster IP" -m tcp --dport 9000 -j KUBE-MARK-MASQ</span>
      
  <span class="c">## (참고) ss 툴로 tcp listen 정보에는 없음 , 별도 /32 host 라우팅 추가 없음 -&gt; 즉, iptables rule 에 의해서 처리됨을 확인</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane ss <span class="nt">-tnlp</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane ip <span class="nt">-c</span> route
      
  <span class="c"># TCP 80,9000 포트별 접속 확인 : 출력 정보 의미 확인</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$SVC1</span>:80
  <span class="c"># =&gt; (공백)</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$SVC1</span>:9000
  <span class="c"># =&gt; Hostname: webpod2</span>
  <span class="c">#    ...</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$SVC1</span>:9000 | <span class="nb">grep </span>Hostname
  <span class="c"># =&gt; Hostname: webpod3</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$SVC1</span>:9000 | <span class="nb">grep </span>Hostname
  <span class="c"># =&gt; Hostname: webpod1 </span>
      
  <span class="c"># curl로 접속했을때 컨테이너의 포트인 targetPort 80으로는 접속이 안 되고 port 9000로는 접속이 됩니다.</span>
  <span class="c"># 또한 접속시마다 각 pod에 부하가 분산되어 HostName: 이 변경됨을 확인할 수 있습니다.</span>
      
  <span class="c"># 서비스(ClusterIP) 부하분산 접속 확인</span>
  <span class="c">## for 문을 이용하여 SVC1 IP 로 100번 접속을 시도 후 출력되는 내용 중 반복되는 내용의 갯수 출력</span>
  <span class="c">## 반복해서 실행을 해보면, SVC1 IP로 curl 접속 시 3개의 파드로 대략 33% 정도로 부하분산 접속됨을 확인</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"for i in {1..10};   do curl -s </span><span class="nv">$SVC1</span><span class="s2">:9000 | grep Hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt;       4 Hostname: webpod3</span>
  <span class="c">#          4 Hostname: webpod2</span>
  <span class="c">#          2 Hostname: webpod1</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100};  do curl -s </span><span class="nv">$SVC1</span><span class="s2">:9000 | grep Hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt;      38 Hostname: webpod3</span>
  <span class="c">#         35 Hostname: webpod1</span>
  <span class="c">#         27 Hostname: webpod2</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"for i in {1..1000}; do curl -s </span><span class="nv">$SVC1</span><span class="s2">:9000 | grep Hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt;     346 Hostname: webpod2</span>
  <span class="c">#        336 Hostname: webpod1</span>
  <span class="c">#        318 Hostname: webpod3</span>
  <span class="c"># 혹은</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100};   do curl -s </span><span class="nv">$SVC1</span><span class="s2">:9000 | grep Hostname; sleep 1; done"</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100};   do curl -s </span><span class="nv">$SVC1</span><span class="s2">:9000 | grep Hostname; sleep 0.1; done"</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"for i in {1..10000}; do curl -s </span><span class="nv">$SVC1</span><span class="s2">:9000 | grep Hostname; sleep 0.01; done"</span>
      
  <span class="c"># conntrack 확인</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane bash
  <span class="nt">----------------------------------------</span>
  <span class="nv">$ </span>conntrack <span class="nt">-h</span>
  <span class="nv">$ </span>conntrack <span class="nt">-E</span>
  <span class="c"># =&gt;     [NEW] tcp      6 120 SYN_SENT src=172.23.0.2 dst=172.23.0.2 sport=45466 dport=6443 [UNREPLIED] src=172.23.0.2 dst=172.23.0.2 sport=6443 dport=45466</span>
  <span class="c">#     [UPDATE] tcp      6 60 SYN_RECV src=172.23.0.2 dst=172.23.0.2 sport=45466 dport=6443 src=172.23.0.2 dst=172.23.0.2 sport=6443 dport=45466</span>
  <span class="nv">$ </span>conntrack <span class="nt">-C</span>
  <span class="c"># =&gt; 2763</span>
  <span class="nv">$ </span>conntrack <span class="nt">-S</span>
  <span class="c"># =&gt; cpu=0           found=0 invalid=0 insert=0 insert_failed=0 drop=0 early_drop=0 error=0 search_restart=3 clash_resolve=0 chaintoolong=0</span>
  <span class="c">#    cpu=1           found=0 invalid=0 insert=0 insert_failed=0 drop=0 early_drop=0 error=0 search_restart=0 clash_resolve=0 chaintoolong=0</span>
  <span class="nv">$ </span>conntrack <span class="nt">-L</span> <span class="nt">--src</span> 10.200.0.7 <span class="c"># net-pod IP</span>
  <span class="c"># =&gt; tcp      6 93 TIME_WAIT src=10.10.0.7 dst=10.200.1.96 sport=37008 dport=9000 src=10.10.2.3 dst=10.10.0.7 sport=80 dport=37008 [ASSURED] mark=0 use=1</span>
  <span class="c">#    tcp      6 93 TIME_WAIT src=10.10.0.7 dst=10.200.1.96 sport=36584 dport=9000 src=10.10.2.3 dst=10.10.0.7 sport=80 dport=36584 [ASSURED] mark=0 use=1</span>
  <span class="nv">$ SVC1</span><span class="o">=</span><span class="si">$(</span>kubectl get svc svc-clusterip <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">={</span>.spec.clusterIP<span class="o">}</span><span class="si">)</span>
  <span class="nv">$ </span>conntrack <span class="nt">-L</span> <span class="nt">--dst</span> <span class="nv">$SVC1</span>     <span class="c"># service ClusterIP</span>
  <span class="c"># =&gt; tcp      6 31 TIME_WAIT src=10.10.0.7 dst=10.200.1.96 sport=37008 dport=9000 src=10.10.2.3 dst=10.10.0.7 sport=80 dport=37008 [ASSURED] mark=0 use=1</span>
  <span class="c">#    tcp      6 31 TIME_WAIT src=10.10.0.7 dst=10.200.1.96 sport=36584 dport=9000 src=10.10.2.3 dst=10.10.0.7 sport=80 dport=36584 [ASSURED] mark=0 use=1</span>
  <span class="nv">$ </span><span class="nb">exit</span>
  <span class="nt">----------------------------------------</span>
      
  <span class="c"># (참고) Link layer 에서 동작하는 ebtables</span>
  <span class="nv">$ </span>ebtables <span class="nt">-L</span>
  <span class="c"># =&gt; Bridge table: filter</span>
  <span class="c">#    Bridge chain: INPUT, entries: 0, policy: ACCEPT</span>
  <span class="c">#    Bridge chain: FORWARD, entries: 0, policy: ACCEPT</span>
  <span class="c">#    Bridge chain: OUTPUT, entries: 0, policy: ACCEPT</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>각 워커 노드에서 패킷  덤프 확인</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># 방안1 : 1대 혹은 3대 bash 진입 후 tcpdump 해둘 것</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker bash
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker2 bash
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker3 bash
  <span class="nt">----------------------------------</span>
  <span class="c"># nic 정보 확인</span>
  <span class="nv">$ </span>ip <span class="nt">-c</span> <span class="nb">link</span>
  <span class="c"># =&gt; &lt;&lt;myk8s-worker&gt;&gt;</span>
  <span class="c">#    3: veth9a888981@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span>
  <span class="c">#        link/ether 26:a5:d2:44:f4:b4 brd ff:ff:ff:ff:ff:ff link-netns cni-0b7e59c3-3920-ce1f-874a-9e228adf3b72</span>
  <span class="c">#    134: eth0@if135: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span>
  <span class="c">#        link/ether 02:42:ac:17:00:04 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span>
  <span class="c">#    </span>
  <span class="c">#    &lt;&lt;myk8s-worker2&gt;&gt;</span>
  <span class="c">#    4: veth570fce87@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span>
  <span class="c">#        link/ether a6:8a:d8:a3:f4:ac brd ff:ff:ff:ff:ff:ff link-netns cni-8dcb2d16-f339-2571-03d2-d6b0f850878d</span>
  <span class="c">#    136: eth0@if137: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span>
  <span class="c">#        link/ether 02:42:ac:17:00:05 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span>
  <span class="c">#    </span>
  <span class="c">#    &lt;&lt;myk8s-worker3&gt;&gt;</span>
  <span class="c">#    3: veth2e19df47@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span>
  <span class="c">#        link/ether da:5e:a5:14:62:7b brd ff:ff:ff:ff:ff:ff link-netns cni-1f44bebd-9ebf-6af4-7888-945649a2b5c8</span>
  <span class="c">#    132: eth0@if133: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span>
  <span class="c">#        link/ether 02:42:ac:17:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span>
      
  <span class="nv">$ </span>ip <span class="nt">-c</span> route
  <span class="c"># =&gt; &lt;&lt;myk8s-worker&gt;&gt;</span>
  <span class="c">#    default via 172.23.0.1 dev eth0</span>
  <span class="c">#    10.10.0.0/24 via 172.23.0.2 dev eth0</span>
  <span class="c">#    10.10.1.0/24 via 172.23.0.5 dev eth0</span>
  <span class="c">#    10.10.2.0/24 via 172.23.0.3 dev eth0</span>
  <span class="c">#    10.10.4.3 dev veth9a888981 scope host</span>
  <span class="c">#    172.23.0.0/16 dev eth0 proto kernel scope link src 172.23.0.4</span>
  <span class="c">#</span>
  <span class="c">#    &lt;&lt;myk8s-worker2&gt;&gt;</span>
  <span class="c">#    default via 172.23.0.1 dev eth0</span>
  <span class="c">#    10.10.0.0/24 via 172.23.0.2 dev eth0</span>
  <span class="c">#    10.10.1.4 dev veth570fce87 scope host</span>
  <span class="c">#    10.10.2.0/24 via 172.23.0.3 dev eth0</span>
  <span class="c">#    10.10.4.0/24 via 172.23.0.4 dev eth0</span>
  <span class="c">#    172.23.0.0/16 dev eth0 proto kernel scope link src 172.23.0.5</span>
  <span class="c">#    </span>
  <span class="c">#    &lt;&lt;myk8s-worker3&gt;&gt;</span>
  <span class="c">#    default via 172.23.0.1 dev eth0</span>
  <span class="c">#    10.10.0.0/24 via 172.23.0.2 dev eth0</span>
  <span class="c">#    10.10.1.0/24 via 172.23.0.5 dev eth0</span>
  <span class="c">#    10.10.2.3 dev veth2e19df47 scope host</span>
  <span class="c">#    10.10.4.0/24 via 172.23.0.4 dev eth0</span>
  <span class="c">#    172.23.0.0/16 dev eth0 proto kernel scope link src 172.23.0.3</span>
      
  <span class="nv">$ </span>ip <span class="nt">-c</span> addr
  <span class="c"># =&gt; &lt;&lt;myk8s-worker&gt;&gt;</span>
  <span class="c">#    3: veth9a888981@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span>
  <span class="c">#        link/ether 26:a5:d2:44:f4:b4 brd ff:ff:ff:ff:ff:ff link-netns cni-0b7e59c3-3920-ce1f-874a-9e228adf3b72</span>
  <span class="c">#        inet 10.10.4.1/32 scope global veth9a888981</span>
  <span class="c">#           valid_lft forever preferred_lft forever</span>
  <span class="c">#    134: eth0@if135: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span>
  <span class="c">#        link/ether 02:42:ac:17:00:04 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span>
  <span class="c">#        inet 172.23.0.4/16 brd 172.23.255.255 scope global eth0</span>
  <span class="c">#           valid_lft forever preferred_lft forever</span>
  <span class="c">#    </span>
  <span class="c">#    &lt;&lt;myk8s-worker2&gt;&gt;</span>
  <span class="c">#    4: veth570fce87@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span>
  <span class="c">#        link/ether a6:8a:d8:a3:f4:ac brd ff:ff:ff:ff:ff:ff link-netns cni-8dcb2d16-f339-2571-03d2-d6b0f850878d</span>
  <span class="c">#        inet 10.10.1.1/32 scope global veth570fce87</span>
  <span class="c">#           valid_lft forever preferred_lft forever</span>
  <span class="c">#    136: eth0@if137: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span>
  <span class="c">#        link/ether 02:42:ac:17:00:05 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span>
  <span class="c">#        inet 172.23.0.5/16 brd 172.23.255.255 scope global eth0</span>
  <span class="c">#           valid_lft forever preferred_lft forever</span>
  <span class="c">#    </span>
  <span class="c">#    &lt;&lt;myk8s-worker3&gt;&gt;</span>
  <span class="c">#    3: veth2e19df47@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span>
  <span class="c">#        link/ether da:5e:a5:14:62:7b brd ff:ff:ff:ff:ff:ff link-netns cni-1f44bebd-9ebf-6af4-7888-945649a2b5c8</span>
  <span class="c">#        inet 10.10.2.1/32 scope global veth2e19df47</span>
  <span class="c">#           valid_lft forever preferred_lft forever</span>
  <span class="c">#    132: eth0@if133: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span>
  <span class="c">#        link/ether 02:42:ac:17:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span>
  <span class="c">#        inet 172.23.0.3/16 brd 172.23.255.255 scope global eth0</span>
  <span class="c">#           valid_lft forever preferred_lft forever</span>
      
  <span class="c"># tcpdump/ngrep : eth0 &gt;&gt; tcp 9000 포트 트래픽은 왜 없을까? iptables rule 동작 그림을 한번 더 확인하고 이해해보자</span>
  <span class="c">## ngrep 네트워크 패킷 분석기 활용해보기 : 특정 url 호출에 대해서만 필터 등 깔끔하게 볼 수 있음 - 링크</span>
  <span class="nv">$ </span>tcpdump <span class="nt">-i</span> eth0 tcp port 80 <span class="nt">-nnq</span>
  <span class="nv">$ </span>tcpdump <span class="nt">-i</span> eth0 tcp port 80 <span class="nt">-w</span> /root/svc1-1.pcap
  <span class="nv">$ </span>tcpdump <span class="nt">-i</span> eth0 tcp port 9000 <span class="nt">-nnq</span>
  <span class="nv">$ </span>ngrep <span class="nt">-tW</span> byline <span class="nt">-d</span> eth0 <span class="s1">''</span> <span class="s1">'tcp port 80'</span>
      
  <span class="c"># tcpdump/ngrep : vethX</span>
  <span class="c"># $ VETH1=&lt;각자 자신의 veth 이름&gt;</span>
  <span class="nv">$ VETH1</span><span class="o">=</span>veth9a888981
  <span class="nv">$ </span>tcpdump <span class="nt">-i</span> <span class="nv">$VETH1</span> tcp port 80 <span class="nt">-nn</span>
  <span class="nv">$ </span>tcpdump <span class="nt">-i</span> <span class="nv">$VETH1</span> tcp port 80 <span class="nt">-w</span> /root/svc1-2.pcap
  <span class="nv">$ </span>tcpdump <span class="nt">-i</span> <span class="nv">$VETH1</span> tcp port 9000 <span class="nt">-nn</span>
  <span class="nv">$ </span>ngrep <span class="nt">-tW</span> byline <span class="nt">-d</span> <span class="nv">$VETH1</span> <span class="s1">''</span> <span class="s1">'tcp port 80'</span>
      
  <span class="nv">$ </span><span class="nb">exit</span>
  <span class="nt">----------------------------------</span>
      
  <span class="c"># 방안2 : kind 노드 컨테이너 bash 직접 접속하지 않고 호스트에서 tcpdump 하기</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker tcpdump <span class="nt">-i</span> eth0 tcp port 80 <span class="nt">-nnq</span>
  <span class="nv">$ VETH1</span><span class="o">=</span>&lt;각자 자신의 veth 이름&gt; docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker ip <span class="nt">-c</span> route
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker tcpdump <span class="nt">-i</span> <span class="nv">$VETH1</span> tcp port 80 <span class="nt">-nnq</span>
      
  <span class="c"># 호스트PC에 pcap 파일 복사 &gt;&gt; wireshark 에서 분석</span>
  <span class="nv">$ </span>docker <span class="nb">cp </span>myk8s-worker:/root/svc1-1.pcap <span class="nb">.</span>
  <span class="nv">$ </span>docker <span class="nb">cp </span>myk8s-worker:/root/svc1-2.pcap <span class="nb">.</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>net-pod 포드에 접속 후 10개 curl 요청</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh
<span class="nt">----------------------------------</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..10<span class="o">}</span><span class="p">;</span>   <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$SVC1</span>:9000 | <span class="nb">grep </span>Hostname<span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;       4 Hostname: webpod3</span>
<span class="c">#          3 Hostname: webpod2</span>
<span class="c">#          3 Hostname: webpod1</span>
    
<span class="nv">$ </span><span class="nb">exit</span>
<span class="nt">----------------------------------</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>각각 net-pod와 워커 노드들의 패킷캡쳐파일(*.pcap)를 받아서 와이어샤크로 확인해보겠습니다.</p>
        <ul>
          <li>
            <p>net-pod(10.10.0.7)에서 서비스:9000 (IP:10.200.1.96)으로 요청된 패킷이 DNAT 되어 k8s-worker의 webpod1:80 (IP:10.10.4.3)으로 전달되고, 응답은 그 반대로 전달 되는 것을 확인 할 수 있습니다.</p>

            <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_14.png" alt="img.png" loading="lazy" width="1123" height="122"></p>
          </li>
          <li>
            <p>또한 Stastics 메뉴의→ Flow Graph 기능을 통해 패킷의 흐름을 확인할 수 있었습니다.</p>

            <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_15.png" alt="img.png" loading="lazy" width="1498" height="314"></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>iptables 정책 확인
    <ul>
      <li>kubernetes에서 service는 다음의 iptables 과정을 거칩니다.
        <ul>
          <li>(1) PREROUTING ⇒ (2) KUBE-SERVICES ⇒ (3) KUBE-SVC-YYY ⇒ (4) KUBE-SEP-#파드1, KUBE-SEP-#파드2, KUBE-SEP-#파드3</li>
          <li>그림으로 나타내면 다음과 같습니다.</li>
        </ul>

        <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_16.png" alt="img.png" loading="lazy" width="828" height="195"></p>

        <ul>
          <li>
            <p>각각에 대하여 iptables 룰을 확인해보겠습니다.</p>

            <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># 컨트롤플레인에서 확인하겠습니다.</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane bash
  <span class="nt">----------------------------------------</span>
        
  <span class="c"># iptables 확인</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-S</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">wc</span> <span class="nt">-l</span>
  <span class="c"># =&gt; 97</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> mangle <span class="nt">-S</span>
        
  <span class="c"># iptables 상세 확인 - 매칭 패킷 카운트, 인터페이스 정보 등 포함</span>
  <span class="nv">$ </span>iptables <span class="nt">-nvL</span> <span class="nt">-t</span> filter
  <span class="nv">$ </span>iptables <span class="nt">-nvL</span> <span class="nt">-t</span> nat
  <span class="nv">$ </span>iptables <span class="nt">-nvL</span> <span class="nt">-t</span> mangle
        
  <span class="c"># rule 갯수 확인</span>
  <span class="nv">$ </span>iptables <span class="nt">-nvL</span> <span class="nt">-t</span> filter | <span class="nb">wc</span> <span class="nt">-l</span>
  <span class="c"># =&gt; 47</span>
  <span class="nv">$ </span>iptables <span class="nt">-nvL</span> <span class="nt">-t</span> nat | <span class="nb">wc</span> <span class="nt">-l</span>
  <span class="c"># =&gt; 158</span>
        
  <span class="c"># 규칙 패킷 바이트 카운트 초기화</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">--zero</span><span class="p">;</span> iptables <span class="nt">-t</span> nat <span class="nt">--zero</span><span class="p">;</span> iptables <span class="nt">-t</span> mangle <span class="nt">--zero</span>
        
  <span class="c"># 정책 확인 : 아래 정책 내용은 핵심적인 룰(rule)만 표시했습니다!</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-nvL</span>
  <span class="c"># =&gt; Chain PREROUTING (policy ACCEPT 121 packets, 7260 bytes) &lt;&lt;1. PREROUTING&gt;&gt;</span>
  <span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
  <span class="c">#      121  7260 KUBE-SERVICES  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */</span>
  <span class="c">#    ...</span>
  <span class="c">#    </span>
  <span class="c">#    Chain INPUT (policy ACCEPT 121 packets, 7260 bytes)</span>
  <span class="c">#    </span>
  <span class="c">#    Chain OUTPUT (policy ACCEPT 392 packets, 23520 bytes)</span>
  <span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
  <span class="c">#      392 23520 KUBE-SERVICES  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */</span>
  <span class="c">#    ...</span>
  <span class="c">#    </span>
  <span class="c">#    Chain KUBE-MARK-MASQ (18 references)</span>
  <span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
  <span class="c">#        0     0 MARK       0    --  *      *       0.0.0.0/0            0.0.0.0/0            MARK or 0x4000</span>
  <span class="c">#    </span>
  <span class="c">#    Chain KUBE-SERVICES (2 references) &lt;&lt;2. SERVICES&gt;&gt;</span>
  <span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
  <span class="c">#        0     0 KUBE-SVC-KBDEBIL6IU6WL7RF  6    --  *      *       0.0.0.0/0            10.200.1.96          /* default/svc-clusterip:svc-webport cluster IP */ tcp dpt:9000</span>
  <span class="c">#    ...</span>
  <span class="c">#    </span>
  <span class="c">#    Chain KUBE-SVC-KBDEBIL6IU6WL7RF (1 references) &lt;&lt;3. KUBE-SVC-YYY&gt;&gt;</span>
  <span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
  <span class="c">#        0     0 KUBE-MARK-MASQ  6    --  *      *      !10.10.0.0/16         10.200.1.96          /* default/svc-clusterip:svc-webport cluster IP */ tcp dpt:9000</span>
  <span class="c">#        0     0 KUBE-SEP-T7YVH2JOMUTQFUDU  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.1.4:80 */ statistic mode random probability 0.33333333349</span>
  <span class="c">#        0     0 KUBE-SEP-SZHENXPAXVOCHRDA  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.2.3:80 */ statistic mode random probability 0.50000000000</span>
  <span class="c">#        0     0 KUBE-SEP-X47GKN7LA32LZ4H7  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.4.3:80 */</span>
  <span class="c">#    </span>
  <span class="c">#    Chain KUBE-SEP-X47GKN7LA32LZ4H7 (1 references) &lt;&lt;4. KUBE-SEP-#WEBPOD1&gt;&gt;</span>
  <span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
  <span class="c">#        0     0 KUBE-MARK-MASQ  0    --  *      *       10.10.4.3            0.0.0.0/0            /* default/svc-clusterip:svc-webport */</span>
  <span class="c">#        0     0 DNAT       6    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport */ tcp to:10.10.4.3:80</span>
  <span class="c">#    </span>
  <span class="c">#    Chain KUBE-SEP-T7YVH2JOMUTQFUDU (1 references) &lt;&lt;4. KUBE-SEP-#WEBPOD2&gt;&gt;</span>
  <span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
  <span class="c">#        0     0 KUBE-MARK-MASQ  0    --  *      *       10.10.1.4            0.0.0.0/0            /* default/svc-clusterip:svc-webport */</span>
  <span class="c">#        0     0 DNAT       6    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport */ tcp to:10.10.1.4:80</span>
  <span class="c">#</span>
  <span class="c">#    Chain KUBE-SEP-SZHENXPAXVOCHRDA (1 references) &lt;&lt;4. KUBE-SEP-#WEBPOD3&gt;&gt;</span>
  <span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
  <span class="c">#        0     0 KUBE-MARK-MASQ  0    --  *      *       10.10.2.3            0.0.0.0/0            /* default/svc-clusterip:svc-webport */</span>
  <span class="c">#        0     0 DNAT       6    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport */ tcp to:10.10.2.3:80</span>
        
  <span class="nv">$ </span>iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> PREROUTING | column <span class="nt">-t</span>
  <span class="c"># =&gt; Chain  PREROUTING  (policy        ACCEPT  777  packets,  46620  bytes)</span>
  <span class="c">#    pkts   bytes       target         prot    opt  in        out    source     destination</span>
  <span class="c">#    777    46620       KUBE-SERVICES  0       --   *         *      0.0.0.0/0  0.0.0.0/0    /*  kubernetes  service  portals  */</span>
  <span class="c">#    0      0           DOCKER_OUTPUT  0       --   *         *      0.0.0.0/0  172.23.0.1</span>
        
  <span class="nv">$ </span>iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> KUBE-SERVICES | column
  <span class="c"># 바로 아래 룰(rule)에 의해서 서비스(ClusterIP)를 인지하고 처리를 합니다</span>
  <span class="c"># =&gt; Chain  KUBE-SERVICES  (2                         references)</span>
  <span class="c">#    pkts   bytes          target                     prot         opt  in  out  source     destination</span>
  <span class="c">#    0      0              KUBE-SVC-KBDEBIL6IU6WL7RF  6            --   *   *    0.0.0.0/0  10.200.1.96   /*  default/svc-clusterip:svc-webport  cluster  IP          */     tcp   dpt:9000</span>
        
  <span class="nv">$ </span>iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> KUBE-SVC-KBDEBIL6IU6WL7RF | column
  <span class="c"># =&gt; Chain  KUBE-SVC-KBDEBIL6IU6WL7RF  (1                         references)</span>
  <span class="c">#    pkts   bytes                      target                     prot         opt  in  out  source         destination</span>
  <span class="c">#    0      0                          KUBE-SEP-T7YVH2JOMUTQFUDU  0            --   *   *    0.0.0.0/0      0.0.0.0/0    /*  default/svc-clusterip:svc-webport  -&gt;       10.10.1.4:80  */  statistic  mode      random  probability  0.33333333349</span>
  <span class="c">#    0      0                          KUBE-SEP-SZHENXPAXVOCHRDA  0            --   *   *    0.0.0.0/0      0.0.0.0/0    /*  default/svc-clusterip:svc-webport  -&gt;       10.10.2.3:80  */  statistic  mode      random  probability  0.50000000000</span>
  <span class="c">#    0      0                          KUBE-SEP-X47GKN7LA32LZ4H7  0            --   *   *    0.0.0.0/0      0.0.0.0/0    /*  default/svc-clusterip:svc-webport  -&gt;       10.10.4.3:80  */</span>
        
  <span class="c"># 패킷 전달 수를 확인 하기 위해 watch를 겁니다.</span>
  <span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'iptables -v --numeric --table nat --list KUBE-SVC-KBDEBIL6IU6WL7RF'</span>
        
  <span class="c"># control-plane 에서 테스트 패킷을 보냅니다.</span>
  <span class="nv">$ SVC1</span><span class="o">=</span><span class="si">$(</span>kubectl get svc svc-clusterip <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">={</span>.spec.clusterIP<span class="o">}</span><span class="si">)</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100};   do curl -s </span><span class="nv">$SVC1</span><span class="s2">:9000 | grep Hostname; sleep 1; done"</span>
</code></pre></div>            </div>

            <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_17.png" alt="img.png" loading="lazy" width="1940" height="756"></p>
          </li>
          <li>
            <p>iptables에서  카운트가 증가함을 확인 할 수 있습니다.</p>

            <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># SVC-### 에서 랜덤 확률(대략 33%)로 SEP(Service EndPoint)인 각각 파드 IP로 DNAT 됩니다!</span>
<span class="c">## 첫번째 룰에 일치 확률은 33% 이고, 매칭되지 않을 경우 아래 2개 남을때는 룰 일치 확률은 50%가 됩니다. 이것도 매칭되지 않으면 마지막 룰로 100% 일치됩니다</span>
<span class="c">#    Chain KUBE-SVC-KBDEBIL6IU6WL7RF (1 references)</span>
<span class="c">#     pkts bytes target     prot opt in     out     source               destination</span>
<span class="c">#        0     0 KUBE-MARK-MASQ  6    --  *      *      !10.10.0.0/16         10.200.1.96          /* default/svc-clusterip:svc-webport cluster IP */ tcp dpt:9000</span>
<span class="c">#       41  2460 KUBE-SEP-T7YVH2JOMUTQFUDU  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.1.4:80 */ statistic mode random probability 0.33333333349</span>
<span class="c">#       47  2820 KUBE-SEP-SZHENXPAXVOCHRDA  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.2.3:80 */ statistic mode random probability 0.50000000000</span>
<span class="c">#       45  2700 KUBE-SEP-X47GKN7LA32LZ4H7  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.4.3:80 */</span>
      
<span class="c"># $ iptables -v --numeric --table nat --list KUBE-SEP-&lt;각자 값 입력&gt;</span>
<span class="nv">$ </span>iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> KUBE-SEP-T7YVH2JOMUTQFUDU
<span class="c"># =&gt; Chain  KUBE-SEP-T7YVH2JOMUTQFUDU  (1              references)</span>
<span class="c">#    pkts   bytes                      target          prot         opt  in  out  source     destination</span>
<span class="c">#    49     2940                       DNAT            6            --   *   *    0.0.0.0/0  0.0.0.0/0    /*  default/svc-clusterip:svc-webport  */  tcp  to:10.10.1.4:80</span>
      
<span class="nv">$ </span>iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> KUBE-SEP-SZHENXPAXVOCHRDA  | column <span class="nt">-t</span>
<span class="c"># =&gt; Chain  KUBE-SEP-SZHENXPAXVOCHRDA  (1              references)</span>
<span class="c">#    pkts   bytes                      target          prot         opt  in  out  source     destination</span>
<span class="c">#    0      0                          KUBE-MARK-MASQ  0            --   *   *    10.10.2.3  0.0.0.0/0    /*  default/svc-clusterip:svc-webport  */</span>
<span class="c">#    56     3360                       DNAT            6            --   *   *    0.0.0.0/0  0.0.0.0/0    /*  default/svc-clusterip:svc-webport  */  tcp  to:10.10.2.3:80</span>
      
<span class="nv">$ </span>iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> KUBE-SEP-X47GKN7LA32LZ4H7  | column <span class="nt">-t</span>
<span class="c"># =&gt; Chain  KUBE-SEP-X47GKN7LA32LZ4H7  (1              references)</span>
<span class="c">#    pkts   bytes                      target          prot         opt  in  out  source     destination</span>
<span class="c">#    0      0                          KUBE-MARK-MASQ  0            --   *   *    10.10.4.3  0.0.0.0/0    /*  default/svc-clusterip:svc-webport  */</span>
<span class="c">#    48     2880                       DNAT            6            --   *   *    0.0.0.0/0  0.0.0.0/0    /*  default/svc-clusterip:svc-webport  */  tcp  to:10.10.4.3:80</span>
      
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">--zero</span>
<span class="nv">$ </span>iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> POSTROUTING | column<span class="p">;</span> <span class="nb">echo</span> <span class="p">;</span> iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> KUBE-POSTROUTING | column
<span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'iptables -v --numeric --table nat --list POSTROUTING; echo ; iptables -v --numeric --table nat --list KUBE-POSTROUTING'</span>
<span class="c"># POSTROUTE(nat) : 0x4000 마킹 되어 있지 않으니 RETURN 되고 그냥 빠져나가서 SNAT 되지 않는다!</span>
<span class="c"># =&gt; Chain  POSTROUTING  (policy             ACCEPT  0    packets,  0    bytes)</span>
<span class="c">#    pkts   bytes        target              prot    opt  in        out  source     destination</span>
<span class="c">#    0      0            KUBE-POSTROUTING    0       --   *         *    0.0.0.0/0  0.0.0.0/0    /*        kubernetes  postrouting  rules   */</span>
<span class="c">#    0      0            DOCKER_POSTROUTING  0       --   *         *    0.0.0.0/0  172.23.0.1</span>
<span class="c">#    0      0            KIND-MASQ-AGENT     0       --   *         *    0.0.0.0/0  0.0.0.0/0    ADDRTYPE  match       dst-type     !LOCAL  /*  kind-masq-agent:  ensure  nat  POSTROUTING  directs  all  non-LOCAL  destination  traffic  to  our  custom  KIND-MASQ-AGENT  chain  */</span>
<span class="c"># =&gt; Chain  KUBE-POSTROUTING  (1          references)</span>
<span class="c">#    pkts   bytes             target      prot         opt  in  out  source     destination</span>
<span class="c">#    0      0                 RETURN      0            --   *   *    0.0.0.0/0  0.0.0.0/0    mark  match       !        0x4000/0x4000</span>
<span class="c">#    0      0                 MARK        0            --   *   *    0.0.0.0/0  0.0.0.0/0    MARK  xor         0x4000</span>
<span class="c">#    0      0                 MASQUERADE  0            --   *   *    0.0.0.0/0  0.0.0.0/0    /*    kubernetes  service  traffic        requiring  SNAT  */  random-fully</span>
      
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep </span>KUBE-POSTROUTING
<span class="c"># =&gt; -N KUBE-POSTROUTING</span>
<span class="c">#    -A POSTROUTING -m comment --comment "kubernetes postrouting rules" -j KUBE-POSTROUTING</span>
<span class="c">#    -A KUBE-POSTROUTING -m mark ! --mark 0x4000/0x4000 -j RETURN</span>
<span class="c">#    -A KUBE-POSTROUTING -j MARK --set-xmark 0x4000/0x0</span>
<span class="c">#    -A KUBE-POSTROUTING -m comment --comment "kubernetes service traffic requiring SNAT" -j MASQUERADE --random-fully</span>
      
<span class="nv">$ </span><span class="nb">exit</span>
<span class="nt">----------------------------------------</span>
      
<span class="c"># 위 서비스 생성 시 kube-proxy 에 의해서 iptables 규칙이 모든 노드에 추가됨을 한번 더 확인</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> KUBE-SVC-KBDEBIL6IU6WL7RF
<span class="c"># =&gt; Chain KUBE-SVC-KBDEBIL6IU6WL7RF (1 references)</span>
<span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
<span class="c">#        0     0 KUBE-MARK-MASQ  6    --  *      *      !10.10.0.0/16         10.200.1.96          /* default/svc-clusterip:svc-webport cluster IP */ tcp dpt:9000</span>
<span class="c">#        0     0 KUBE-SEP-T7YVH2JOMUTQFUDU  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.1.4:80 */ statistic mode random probability 0.33333333349</span>
<span class="c">#        0     0 KUBE-SEP-SZHENXPAXVOCHRDA  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.2.3:80 */ statistic mode random probability 0.50000000000</span>
<span class="c">#        0     0 KUBE-SEP-X47GKN7LA32LZ4H7  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.4.3:80 */</span>
      
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> KUBE-SVC-KBDEBIL6IU6WL7RF<span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
<span class="c"># =&gt; &gt;&gt; node myk8s-control-plane &lt;&lt;</span>
<span class="c">#    Chain KUBE-SVC-KBDEBIL6IU6WL7RF (1 references)</span>
<span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
<span class="c">#        0     0 KUBE-MARK-MASQ  6    --  *      *      !10.10.0.0/16         10.200.1.96          /* default/svc-clusterip:svc-webport cluster IP */ tcp dpt:9000</span>
<span class="c">#        0     0 KUBE-SEP-T7YVH2JOMUTQFUDU  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.1.4:80 */ statistic mode random probability 0.33333333349</span>
<span class="c">#        0     0 KUBE-SEP-SZHENXPAXVOCHRDA  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.2.3:80 */ statistic mode random probability 0.50000000000</span>
<span class="c">#        0     0 KUBE-SEP-X47GKN7LA32LZ4H7  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.4.3:80 */</span>
<span class="c">#    </span>
<span class="c">#    &gt;&gt; node myk8s-worker &lt;&lt;</span>
<span class="c">#    Chain KUBE-SVC-KBDEBIL6IU6WL7RF (1 references)</span>
<span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
<span class="c">#        0     0 KUBE-MARK-MASQ  6    --  *      *      !10.10.0.0/16         10.200.1.96          /* default/svc-clusterip:svc-webport cluster IP */ tcp dpt:9000</span>
<span class="c">#        0     0 KUBE-SEP-T7YVH2JOMUTQFUDU  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.1.4:80 */ statistic mode random probability 0.33333333349</span>
<span class="c">#        0     0 KUBE-SEP-SZHENXPAXVOCHRDA  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.2.3:80 */ statistic mode random probability 0.50000000000</span>
<span class="c">#        0     0 KUBE-SEP-X47GKN7LA32LZ4H7  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.4.3:80 */</span>
<span class="c">#    </span>
<span class="c">#    &gt;&gt; node myk8s-worker2 &lt;&lt;</span>
<span class="c">#    Chain KUBE-SVC-KBDEBIL6IU6WL7RF (1 references)</span>
<span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
<span class="c">#        0     0 KUBE-MARK-MASQ  6    --  *      *      !10.10.0.0/16         10.200.1.96          /* default/svc-clusterip:svc-webport cluster IP */ tcp dpt:9000</span>
<span class="c">#        0     0 KUBE-SEP-T7YVH2JOMUTQFUDU  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.1.4:80 */ statistic mode random probability 0.33333333349</span>
<span class="c">#        0     0 KUBE-SEP-SZHENXPAXVOCHRDA  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.2.3:80 */ statistic mode random probability 0.50000000000</span>
<span class="c">#        0     0 KUBE-SEP-X47GKN7LA32LZ4H7  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.4.3:80 */</span>
<span class="c">#    </span>
<span class="c">#    &gt;&gt; node myk8s-worker3 &lt;&lt;</span>
<span class="c">#    Chain KUBE-SVC-KBDEBIL6IU6WL7RF (1 references)</span>
<span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
<span class="c">#        0     0 KUBE-MARK-MASQ  6    --  *      *      !10.10.0.0/16         10.200.1.96          /* default/svc-clusterip:svc-webport cluster IP */ tcp dpt:9000</span>
<span class="c">#        0     0 KUBE-SEP-T7YVH2JOMUTQFUDU  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.1.4:80 */ statistic mode random probability 0.33333333349</span>
<span class="c">#        0     0 KUBE-SEP-SZHENXPAXVOCHRDA  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.2.3:80 */ statistic mode random probability 0.50000000000</span>
<span class="c">#        0     0 KUBE-SEP-X47GKN7LA32LZ4H7  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/svc-clusterip:svc-webport -&gt; 10.10.4.3:80 */</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>동일한 iptables 룰이 각 노드에 있는 것을 확인할 수 있습니다.</p>
          </li>
        </ul>
      </li>
      <li>파드 1개에 장애를 발생시켜서 장애시 동작을 확인해보겠습니다.
        <ul>
          <li>
            <p>동작 확인을 위한 모니터링</p>

            <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># 터미널1 &gt;&gt; ENDPOINTS 변화를 잘 확인해보자!</span>
  <span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'kubectl get pod -owide;echo; kubectl get svc,ep svc-clusterip;echo; kubectl get endpointslices -l kubernetes.io/service-name=svc-clusterip'</span>
        
  <span class="c"># 터미널2</span>
  <span class="nv">$ SVC1</span><span class="o">=</span><span class="si">$(</span>kubectl get svc svc-clusterip <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">={</span>.spec.clusterIP<span class="o">}</span><span class="si">)</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"while true; do curl -s --connect-timeout 1 </span><span class="nv">$SVC1</span><span class="s2">:9000 | egrep 'Hostname|IP: 10'; date '+%Y-%m-%d %H:%M:%S' ; echo ;  sleep 1; done"</span>
  <span class="c"># 혹은</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100};  do curl -s </span><span class="nv">$SVC1</span><span class="s2">:9000 | grep Hostname; done | sort | uniq -c | sort -nr"</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>파드 1개 삭제 후 확인</p>

            <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># (방안1) 파드3번 삭제 &gt;&gt; 서비스의 엔드포인트가 어떻게 변경되는지 확인 하자!, 지속적인 curl 접속 결과 확인!, for 문 실행 시 결과 확인!, 절체 시간(순단) 확인!</span>
  <span class="nv">$ </span>kubectl delete pod webpod3
        
  <span class="c"># (방안1) 결과 확인 후 다시 파드 3번 생성 &gt;&gt; 서비스 디스커버리!</span>
  <span class="nv">$ </span>kubectl apply <span class="nt">-f</span> 3pod.yaml
        
  <span class="nt">---------------------------------</span>
  <span class="c"># (방안2) 파드3번에 레이블 삭제</span>
  <span class="nv">$ </span>kubectl get pod <span class="nt">--show-labels</span>
        
  <span class="c">## 레이블(라벨)의 키값 바로 뒤에 하이픈(-) 입력 시 해당 레이블 삭제됨! &gt;&gt; 레이블과 셀렉터는 쿠버네티스 환경에서 매우 많이 활용된다!</span>
  <span class="nv">$ </span>kubectl label pod webpod3 app-
  <span class="nv">$ </span>kubectl get pod <span class="nt">--show-labels</span>
        
  <span class="c"># (방안2) 결과 확인 후 파드3번에 다시 레이블 생성</span>
  <span class="nv">$ </span>kubectl label pod webpod3 <span class="nv">app</span><span class="o">=</span>webpod
</code></pre></div>            </div>

            <ul>
              <li>
                <p>파드 삭제 전</p>

                <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_18.png" alt="img.png" loading="lazy" width="1453" height="1023"></p>
              </li>
              <li>
                <p>파드 삭제 후</p>

                <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_19.png" alt="img.png" loading="lazy" width="1453" height="1023"></p>
              </li>
              <li>
                <p>파드 다시 생성 후</p>

                <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_20.png" alt="img.png" loading="lazy" width="1453" height="1023"></p>
              </li>
              <li>
                <p>레이블 삭제 후</p>

                <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_21.png" alt="img.png" loading="lazy" width="1453" height="1023"></p>
              </li>
              <li>
                <p>레이블 복구 후</p>

                <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_22.png" alt="img.png" loading="lazy" width="1453" height="1023"></p>
              </li>
            </ul>
          </li>
          <li>
            <p>파드가 삭제되고 복구 됨에 따라 서비스 엔드포인트에서 삭제되고, label selector 에 따라서도 엔드포인트에서 삭제되고 복구됨을 확인할 수 있었습니다.</p>
          </li>
        </ul>
      </li>
      <li>sessionAffinity: ClientIP
        <ul>
          <li>
<code class="language-plaintext highlighter-rouge">sessionAffinity: ClientIP</code> : 클라이언트가 접속한 목적지(파드)에 고정적인 접속을 지원하게 할 수 있습니다.</li>
          <li>
            <p>기본적으로 서비스는 파드에 랜덤으로 부하를 분산하지만 <code class="language-plaintext highlighter-rouge">sessionAffinity: ClientIP</code>를 통해 동일한 파드에 접속하도록 강제 할 수 있습니다.</p>

            <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_23.png" alt="img.png" loading="lazy" width="1092" height="366"></p>
          </li>
          <li>
            <p>설정 및 파드 접속 확인</p>

            <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># 기본 정보 확인</span>
  <span class="nv">$ </span>kubectl get svc svc-clusterip <span class="nt">-o</span> yaml
  <span class="nv">$ </span>kubectl get svc svc-clusterip <span class="nt">-o</span> yaml | <span class="nb">grep </span>sessionAffinity
  <span class="c"># =&gt;   sessionAffinity: None</span>
        
  <span class="c"># 반복 접속</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"while true; do curl -s --connect-timeout 1 </span><span class="nv">$SVC1</span><span class="s2">:9000 | egrep 'Hostname|IP: 10|Remote'; date '+%Y-%m-%d %H:%M:%S' ; echo ;  sleep 1; done"</span>
  <span class="c"># =&gt; Hostname: webpod2</span>
  <span class="c">#    IP: 10.10.1.4</span>
  <span class="c">#    RemoteAddr: 10.10.0.7:57246</span>
  <span class="c">#    2024-09-01 12:25:49</span>
  <span class="c">#    </span>
  <span class="c">#    Hostname: webpod1</span>
  <span class="c">#    IP: 10.10.4.3</span>
  <span class="c">#    RemoteAddr: 10.10.0.7:57250</span>
  <span class="c">#    2024-09-01 12:25:50</span>
  <span class="c">#    </span>
  <span class="c">#    Hostname: webpod3</span>
  <span class="c">#    IP: 10.10.2.6</span>
  <span class="c">#    RemoteAddr: 10.10.0.7:57252</span>
  <span class="c">#    2024-09-01 12:25:51</span>
        
  <span class="c"># 현재는 랜덤으로 접속 됩니다.</span>
        
  <span class="c"># sessionAffinity: ClientIP 설정 변경</span>
  <span class="nv">$ </span>kubectl patch svc svc-clusterip <span class="nt">-p</span> <span class="s1">'{"spec":{"sessionAffinity":"ClientIP"}}'</span>
  <span class="c"># =&gt; service/svc-clusterip patched</span>
  <span class="c"># 혹은</span>
  <span class="c">## $ kubectl get svc svc-clusterip -o yaml | sed -e "s/sessionAffinity: None/sessionAffinity: ClientIP/" | kubectl apply -f -</span>
        
  <span class="c">#</span>
  <span class="nv">$ </span>kubectl get svc svc-clusterip <span class="nt">-o</span> yaml
  <span class="c"># =&gt; ...</span>
  <span class="c">#      sessionAffinity: ClientIP</span>
  <span class="c">#      sessionAffinityConfig:</span>
  <span class="c">#        clientIP:</span>
  <span class="c">#          timeoutSeconds: 10800</span>
  <span class="c">#    ...</span>
        
  <span class="c"># 클라이언트(TestPod) Shell 실행</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100};  do curl -s </span><span class="nv">$SVC1</span><span class="s2">:9000 | grep Hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt; 100 Hostname: webpod2</span>
  <span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> net-pod <span class="nt">--</span> zsh <span class="nt">-c</span> <span class="s2">"for i in {1..1000}; do curl -s </span><span class="nv">$SVC1</span><span class="s2">:9000 | grep Hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt; 1000 Hostname: webpod2</span>
</code></pre></div>            </div>

            <ul>
              <li>sessionAffinity: ClientIP를 하면 spec.sessionAffinityConfig.clientIP.timeoutSeconds 시간동안 서비스를 통해 접속 되는 파드가 고정됨을 확인할 수 있었습니다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이상과 같이 ClusterIP 타입의 서비스를 확인해보았습니다.</li>
  <li>ClusterIP 타입의 서비스는 다음과 같은 단점이 있다고 합니다.
    <ul>
      <li>클러스터 외부에서는 서비스(ClusterIP)로 접속이 불가능합니다. ⇒ <strong>NodePort</strong> 타입으로 외부에서 접속 가능</li>
      <li>IPtables 는 파드에 대한 헬스체크 기능이 없어서 문제 있는 파드에 연결이 되는 경우가 있습니다. ⇒ 서비스 사용, 파드에 Readiness Probe 설정으로 파드 문제 시 서비스의 엔드포인트에서 제거되게 하자! ← 이 정도면 충분한가? 혹시 부족한 점이 없을까?</li>
      <li>서비스에 연동된 파드 갯수 퍼센트(%)로 <strong>랜덤 분산</strong> 방식, <strong>세션어피니티</strong> 이외에 <strong>다른 분산 방식 불가능합니다.</strong> ⇒ <strong>IPVS</strong> 경우 다양한 분산 방식(알고리즘) 가능
        <ul>
          <li>목적지 파드 다수가 있는 환경에서, 출발지 파드와 목적지 파드가 동일한 노드에 배치되어 있어도, 랜덤 분산으로 다른 노드에 목적지 파드로 연결 가능</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="nodeport-실습">NodePort 실습</h4>

<ul>
  <li>NodePort는 ClusterIP와 다르게 클러스터 외부에서도 접속 할 수 있습니다.</li>
  <li>컨트롤플레인을 포함한 모든 노드에 iptables rule이 적용되므로, 모든 노드에 NodePort로 접속시 iptables rule에 의해서 분산 접속이 됩니다.</li>
  <li>Node의 모든 Local IP (loopback을 포함한 각 호스트의 interface의 IP) 사용 가능하고 Local IP 지정도 가능합니다.</li>
  <li>쿠버네티스의 NodePort는 기본 30000~32767 포트에서 랜덤으로 지정됩니다.
    <ul>
      <li>
        <p>랜덤 포트 범위를 바꾸려면 다음과 같이  <code class="language-plaintext highlighter-rouge">/etc/kubernetes/manifests/kube-apiserver.yaml</code> 파일을 수정하여 kube-apiserver 의 파라메터에 <code class="language-plaintext highlighter-rouge">--service-node-port-range=시작포트-종료포트</code>를 변경하면됩니다. <a href="https://blog.frec.kr/cloud/modify_nodeport_range/">참고</a></p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># /etc/kubernetes/manifests/kube-apiserver.yaml</span>
      
  ...
  spec:
    containers:
    - <span class="nb">command</span>:
      - kube-apiserver
      - <span class="nt">--authorization-mode</span><span class="o">=</span>Node,RBAC
      ...
      - <span class="nt">--service-node-port-range</span><span class="o">=</span>30000-50000
  ...
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>실습 구성
    <ul>
      <li>
        <p>목적지(backend) 디플로이먼트 파일 생성 : echo-deploy.yml</p>

        <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
  <span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">deploy-echo</span>
  <span class="na">spec</span><span class="pi">:</span>
    <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
    <span class="na">selector</span><span class="pi">:</span>
      <span class="na">matchLabels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">deploy-websrv</span>
    <span class="na">template</span><span class="pi">:</span>
      <span class="na">metadata</span><span class="pi">:</span>
        <span class="na">labels</span><span class="pi">:</span>
          <span class="na">app</span><span class="pi">:</span> <span class="s">deploy-websrv</span>
      <span class="na">spec</span><span class="pi">:</span>
        <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">0</span>
        <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">kans-websrv</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">mendhak/http-https-echo</span>
          <span class="na">ports</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>서비스(NodePort) 파일 생성 : svc-nodeport.yml</p>

        <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="err">*</span><span class="nv">*Service</span><span class="err">**</span>
  <span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">svc-nodeport</span>
  <span class="na">spec</span><span class="pi">:</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">svc-webport</span>
        <span class="na">port</span><span class="pi">:</span> <span class="m">9000</span>        <span class="c1"># 서비스 ClusterIP 에 접속 시 사용하는 포트 port 를 의미</span>
        <span class="na">targetPort</span><span class="pi">:</span> <span class="m">8080</span>  <span class="c1"># 타킷 targetPort 는 서비스를 통해서 목적지 파드로 접속 시 해당 파드로 접속하는 포트를 의미</span>
    <span class="na">selector</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">deploy-websrv</span>
    <span class="na">**type</span><span class="pi">:</span> <span class="s">NodePort**</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>생성 및 확인</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># 생성</span>
  <span class="nv">$ </span>kubectl apply <span class="nt">-f</span> echo-deploy.yml,svc-nodeport.yml
  <span class="c"># =&gt; deployment.apps/deploy-echo created</span>
  <span class="c">#    service/svc-nodeport created</span>
      
  <span class="c"># 모니터링</span>
  <span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'kubectl get pod -owide;echo; kubectl get svc,ep svc-nodeport'</span>
      
  <span class="c"># 확인</span>
  <span class="nv">$ </span>kubectl get deploy,pod <span class="nt">-o</span> wide
  <span class="c"># =&gt; NAME                          READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS    IMAGES                    SELECTOR</span>
  <span class="c">#    deployment.apps/deploy-echo   3/3     3            3           49s   kans-websrv   mendhak/http-https-echo   app=deploy-websrv</span>
  <span class="c">#    </span>
  <span class="c">#    NAME                               READY   STATUS    RESTARTS   AGE    IP          NODE                  NOMINATED NODE   READINESS GATES</span>
  <span class="c">#    pod/deploy-echo-5c689d5454-dxf2t   1/1     Running   0          49s    10.10.4.4   myk8s-worker          &lt;none&gt;           &lt;none&gt;</span>
  <span class="c">#    pod/deploy-echo-5c689d5454-rbgcp   1/1     Running   0          49s    10.10.1.5   myk8s-worker2         &lt;none&gt;           &lt;none&gt;</span>
  <span class="c">#    pod/deploy-echo-5c689d5454-wppr8   1/1     Running   0          49s    10.10.2.7   myk8s-worker3         &lt;none&gt;           &lt;none&gt;</span>
      
  <span class="c"># 아래 31791은 서비스(NodePort) 정보!</span>
  <span class="nv">$ </span>kubectl get svc svc-nodeport
  <span class="c"># =&gt; NAME           TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span>
  <span class="c">#    svc-nodeport   NodePort   10.200.1.169   &lt;none&gt;        9000:31791/TCP   69s</span>
      
  <span class="nv">$ </span>kubectl get endpoints svc-nodeport
  <span class="c"># =&gt; NAME           ENDPOINTS                                      AGE</span>
  <span class="c">#    svc-nodeport   10.10.1.5:8080,10.10.2.7:8080,10.10.4.4:8080   85s</span>
      
  <span class="c"># Port , TargetPort , NodePort 각각의 차이점의 의미를 알자!</span>
  <span class="nv">$ </span>kubectl describe svc svc-nodeport
  <span class="c"># =&gt; Name:                     svc-nodeport</span>
  <span class="c">#    Namespace:                default</span>
  <span class="c">#    Labels:                   &lt;none&gt;</span>
  <span class="c">#    Annotations:              &lt;none&gt;</span>
  <span class="c">#    Selector:                 app=deploy-websrv</span>
  <span class="c">#    Type:                     NodePort</span>
  <span class="c">#    IP Family Policy:         SingleStack</span>
  <span class="c">#    IP Families:              IPv4</span>
  <span class="c">#    IP:                       10.200.1.169</span>
  <span class="c">#    IPs:                      10.200.1.169</span>
  <span class="c">#    Port:                     svc-webport  9000/TCP     &lt;&lt;ClusterIP와 동일하게 동작하는 클러스터 내부에서 사용하는 포트&gt;&gt;</span>
  <span class="c">#    TargetPort:               8080/TCP                  &lt;&lt;파드의 컨테이너의 포트&gt;&gt;</span>
  <span class="c">#    NodePort:                 svc-webport  31791/TCP    &lt;&lt;각 Node에서 Listening 하는 nodePort&gt;&gt;</span>
  <span class="c">#    Endpoints:                10.10.1.5:8080,10.10.2.7:8080,10.10.4.4:8080    &lt;&lt;Port Forwarding 대상이 되는 파드의 엔드포인트 파드IP:파드Port&gt;&gt;</span>
  <span class="c">#    Session Affinity:         None</span>
  <span class="c">#    External Traffic Policy:  Cluster &lt;&lt;부하 분산방식&gt;&gt;</span>
  <span class="c">#    Events:                   &lt;none&gt;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>2.3. 서비스 접속 확인
    <ul>
      <li>
        <p>NodePort의 서비스 접속을 통한 통신의 흐름</p>

        <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_24.png" alt="img.png" loading="lazy" width="825" height="203"></p>

        <ul>
          <li>Client 가상 머신(192.168.10.200)에서 컨트롤 플레인 IP(192.168.10.10)의 nodePort 접속을 시도합니다.</li>
          <li>nodePort는 서비스(NodePort) 생성시에 할당된 랜덤포트가 사용 됩니다.</li>
          <li>컨트롤 플레인의 iptables의 NAT 테이블의 규칙과 매칭되어 목적지 IP와 목적지 Port는 변환 됩니다. 목적지 IP는 app=deploy-websrv 레이블을 가지고 있는 파드 3개가 대상이 되며, 랜덤 부하분산이 선택됩니다.</li>
        </ul>
      </li>
      <li>
        <p>실습을 통해 위의 과정을 확인해보겠습니다. 단 현재 실습환경에서는 컨트롤 플레인에는 파드가 없으므로 위의 설명과는 다르게 워커노드의 파드를 접속하는것으로 실습하겠습니다.</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># NodePort 확인 : 아래 NodePort 는 범위내 랜덤 할당으로 실습 환경마다 다릅니다</span>
  <span class="nv">$ </span>kubectl get service svc-nodeport <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.ports[0].nodePort}'</span>
  <span class="c"># =&gt; 31791</span>
      
  <span class="c"># NodePort 를 변수에 지정</span>
  <span class="nv">$ NPORT</span><span class="o">=</span><span class="si">$(</span>kubectl get service svc-nodeport <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.ports[0].nodePort}'</span><span class="si">)</span>
  <span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$NPORT</span>
  <span class="c"># =&gt; 31791</span>
      
  <span class="c"># 현재 k8s 버전에서는 포트 Listen 되지 않고, iptables rules 처리됨</span>
  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> ss <span class="nt">-tlnp</span><span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; &gt;&gt; node myk8s-control-plane &lt;&lt;</span>
  <span class="c">#    State  Recv-Q Send-Q Local Address:Port  Peer Address:PortProcess                                  </span>
  <span class="c">#    LISTEN 0      4096       127.0.0.1:2381       0.0.0.0:*    users:(("etcd",pid=710,fd=15))          </span>
  <span class="c">#    ... nodePort인 31791를 LISTEN하는 건이 없음</span>
  <span class="c">#</span>
  <span class="c">#    &gt;&gt; node myk8s-worker &lt;&lt;</span>
  <span class="c">#    State  Recv-Q Send-Q Local Address:Port  Peer Address:PortProcess                              </span>
  <span class="c">#    LISTEN 0      4096      127.0.0.11:35033      0.0.0.0:*                                        </span>
  <span class="c">#    ... nodePort인 31791를 LISTEN하는 건이 없음</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker2 &lt;&lt;</span>
  <span class="c">#    State  Recv-Q Send-Q Local Address:Port  Peer Address:PortProcess                              </span>
  <span class="c">#    LISTEN 0      4096      127.0.0.11:45927      0.0.0.0:*                                        </span>
  <span class="c">#    ... nodePort인 31791를 LISTEN하는 건이 없음</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker3 &lt;&lt;</span>
  <span class="c">#    State  Recv-Q Send-Q Local Address:Port  Peer Address:PortProcess                              </span>
  <span class="c">#    LISTEN 0      4096       127.0.0.1:10248      0.0.0.0:*    users:(("kubelet",pid=262,fd=19))   </span>
  <span class="c">#    ... nodePort인 31791를 LISTEN하는 건이 없음</span>
      
  <span class="c">## (참고) 아래처럼 예전 k8s 환경에서 Service(NodePort) 생성 시, TCP Port Listen 되었었음</span>
  <span class="c"># $ root@k8s-m:~# ss -4tlnp | egrep "(Process|$NPORT)"</span>
  <span class="c"># State     Recv-Q    Send-Q        Local Address:Port        Peer Address:Port   Process</span>
  <span class="c"># LISTEN    0         4096                0.0.0.0:30466            0.0.0.0:*       users:(("kube-proxy",pid=8661,fd=10))</span>
      
  <span class="c"># 파드 로그 실시간 확인 (웹 파드에 접속자의 IP가 출력)</span>
  <span class="nv">$ </span>kubectl logs <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>deploy-websrv <span class="nt">-f</span>
  <span class="c"># =&gt; Listening on ports 8080 for http, and 8443 for https.</span>
  <span class="c">#    ...</span>
  <span class="c">#    ::ffff:172.23.0.2 - - [26/Sep/2024:04:35:00 +0000] "GET / HTTP/1.1" 200 396 "-" "curl/7.88.1"</span>
  <span class="c">#    ...</span>
      
  <span class="c"># 외부 클라이언트(mypc 컨테이너)에서 접속 시도를 해보자</span>
      
  <span class="c"># 노드의 IP와 NodePort를 변수에 지정</span>
  <span class="c">## CNODE=&lt;컨트롤플레인노드의 IP주소&gt;</span>
  <span class="c">## NODE1=&lt;노드1의 IP주소&gt;</span>
  <span class="c">## NODE2=&lt;노드2의 IP주소&gt;</span>
  <span class="c">## NODE3=&lt;노드3의 IP주소&gt;</span>
  <span class="nv">$ CNODE</span><span class="o">=</span>172.23.0.2
  <span class="nv">$ NODE1</span><span class="o">=</span>172.23.0.4
  <span class="nv">$ NODE2</span><span class="o">=</span>172.23.0.5
  <span class="nv">$ NODE3</span><span class="o">=</span>172.23.0.3
      
  <span class="nv">$ NPORT</span><span class="o">=</span><span class="si">$(</span>kubectl get service svc-nodeport <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.ports[0].nodePort}'</span><span class="si">)</span>
  <span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$NPORT</span>
      
  <span class="c"># 서비스(NodePort) 부하분산 접속 확인</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc curl <span class="nt">-s</span> <span class="nv">$CNODE</span>:<span class="nv">$NPORT</span> | jq <span class="c"># headers.host 주소는 왜 그런거죠?</span>
  <span class="c"># =&gt; {</span>
  <span class="c">#      "path": "/",</span>
  <span class="c">#      "headers": {</span>
  <span class="c">#        "host": "172.23.0.2:31791",  &lt;&lt;여기의 headers.host는 요청하는 url의 주소인데, 우리가 $CNODE(컨트롤플레인의 IP)의 url로 접속했기 때문입니다.&gt;&gt;</span>
  <span class="c">#        "user-agent": "curl/8.7.1",</span>
  <span class="c">#        "accept": "*/*"</span>
  <span class="c">#      },</span>
  <span class="c">#      "method": "GET",</span>
  <span class="c">#      "body": "",</span>
  <span class="c">#      "fresh": false,</span>
  <span class="c">#      "hostname": "172.23.0.2",   &lt;&lt;이 hostname과&gt;&gt;</span>
  <span class="c">#      "ip": "::ffff:172.23.0.2",  &lt;&lt;이 ip는 접속하는 클라이언트의 ip인데 부하분산 과정에서 목적지가 Local Pod가 아닌 경우 Node IP로 POSTROUTING(SNAT) 되기 때문입니다.&gt;&gt;</span>
  <span class="c">#      "ips": [],</span>
  <span class="c">#      "protocol": "http",</span>
  <span class="c">#      "query": {},</span>
  <span class="c">#      "subdomains": [],</span>
  <span class="c">#      "xhr": false,</span>
  <span class="c">#      "os": {</span>
  <span class="c">#        "hostname": "deploy-echo-5c689d5454-dxf2t"</span>
  <span class="c">#      },</span>
  <span class="c">#      "connection": {}</span>
  <span class="c">#    }</span>
      
  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="nv">$CNODE</span> <span class="nv">$NODE1</span> <span class="nv">$NODE2</span> <span class="nv">$NODE3</span> <span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node </span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> mypc curl <span class="nt">-s</span> <span class="nv">$i</span>:<span class="nv">$NPORT</span><span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; &gt;&gt; node 172.23.0.2 &lt;&lt;</span>
  <span class="c">#    {</span>
  <span class="c">#      "headers": {</span>
  <span class="c">#        "host": "172.23.0.2:31791",</span>
  <span class="c">#        ...</span>
  <span class="c">#      },</span>
  <span class="c">#      ...</span>
  <span class="c">#      "hostname": "172.23.0.2",</span>
  <span class="c">#      "ip": "::ffff:172.23.0.2",</span>
  <span class="c">#      ...</span>
  <span class="c">#      "os": {</span>
  <span class="c">#        "hostname": "deploy-echo-5c689d5454-dxf2t" </span>
  <span class="c">#      }</span>
  <span class="c">#    }</span>
  <span class="c">#    &gt;&gt; node 172.23.0.4 &lt;&lt;</span>
  <span class="c">#    {</span>
  <span class="c">#      "headers": {</span>
  <span class="c">#        "host": "172.23.0.4:31791",</span>
  <span class="c">#        ...</span>
  <span class="c">#      },</span>
  <span class="c">#      ...</span>
  <span class="c">#      "hostname": "172.23.0.4",</span>
  <span class="c">#      "ip": "::ffff:10.10.4.1",</span>
  <span class="c">#      ...</span>
  <span class="c">#      "os": {</span>
  <span class="c">#        "hostname": "deploy-echo-5c689d5454-dxf2t"</span>
  <span class="c">#      }</span>
  <span class="c">#    }</span>
  <span class="c">#    &gt;&gt; node 172.23.0.5 &lt;&lt;</span>
  <span class="c">#    {</span>
  <span class="c">#      "headers": {</span>
  <span class="c">#        "host": "172.23.0.5:31791",</span>
  <span class="c">#        ...</span>
  <span class="c">#      },</span>
  <span class="c">#      ...</span>
  <span class="c">#      "hostname": "172.23.0.5",</span>
  <span class="c">#      "ip": "::ffff:10.10.1.1",</span>
  <span class="c">#      ...</span>
  <span class="c">#      "os": {</span>
  <span class="c">#        "hostname": "deploy-echo-5c689d5454-rbgcp"</span>
  <span class="c">#      }</span>
  <span class="c">#    }</span>
  <span class="c">#    &gt;&gt; node 172.23.0.3 &lt;&lt;</span>
  <span class="c">#    {</span>
  <span class="c">#      "headers": {</span>
  <span class="c">#        "host": "172.23.0.3:31791",</span>
  <span class="c">#        ...</span>
  <span class="c">#      },</span>
  <span class="c">#      ...</span>
  <span class="c">#      "hostname": "172.23.0.3",</span>
  <span class="c">#      "ip": "::ffff:10.10.2.1",</span>
  <span class="c">#      ...</span>
  <span class="c">#      "os": {</span>
  <span class="c">#        "hostname": "deploy-echo-5c689d5454-wppr8"</span>
  <span class="c">#      }</span>
  <span class="c">#    }</span>
      
  <span class="c"># 컨트롤플레인 노드에는 목적지 파드가 없는데도, 접속을 받아줍니다! 이유는 서비스(nodePort)의 endpoint로 로드밸런싱 되기 때문입니다.</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100}; do curl -s </span><span class="nv">$CNODE</span><span class="s2">:</span><span class="nv">$NPORT</span><span class="s2"> | grep hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt;     100   "hostname": "172.23.0.2",</span>
  <span class="c">#         37     "hostname": "deploy-echo-5c689d5454-wppr8"</span>
  <span class="c">#         33     "hostname": "deploy-echo-5c689d5454-rbgcp"</span>
  <span class="c">#         30     "hostname": "deploy-echo-5c689d5454-dxf2t"</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100}; do curl -s </span><span class="nv">$NODE1</span><span class="s2">:</span><span class="nv">$NPORT</span><span class="s2"> | grep hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt;     100   "hostname": "172.23.0.4",</span>
  <span class="c">#         40     "hostname": "deploy-echo-5c689d5454-wppr8"</span>
  <span class="c">#         32     "hostname": "deploy-echo-5c689d5454-dxf2t"</span>
  <span class="c">#         28     "hostname": "deploy-echo-5c689d5454-rbgcp"$ docker exec -it mypc zsh -c "for i in {1..100}; do curl -s $NODE2:$NPORT | grep hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100}; do curl -s </span><span class="nv">$NODE3</span><span class="s2">:</span><span class="nv">$NPORT</span><span class="s2"> | grep hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt;     100   "hostname": "172.23.0.3",</span>
  <span class="c">#         43     "hostname": "deploy-echo-5c689d5454-wppr8"</span>
  <span class="c">#         34     "hostname": "deploy-echo-5c689d5454-dxf2t"</span>
  <span class="c">#         23     "hostname": "deploy-echo-5c689d5454-rbgcp"</span>
  <span class="c"># 아래 반복 접속 실행 해두자</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc zsh <span class="nt">-c</span> <span class="s2">"while true; do curl -s --connect-timeout 1 </span><span class="nv">$CNODE</span><span class="s2">:</span><span class="nv">$NPORT</span><span class="s2"> | grep hostname; date '+%Y-%m-%d %H:%M:%S' ; echo ;  sleep 1; done"</span>
      
  <span class="c"># NodePort 서비스는 ClusterIP 를 포함</span>
  <span class="c"># CLUSTER-IP:PORT 로 접속 가능! &lt;- 컨트롤노드에서 아래 실행 해보자</span>
  <span class="nv">$ </span>kubectl get svc svc-nodeport
  <span class="c"># =&gt; NAME           TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span>
  <span class="c">#    svc-nodeport   NodePort   10.200.1.169   &lt;none&gt;        9000:31791/TCP   51m</span>
      
  <span class="nv">$ CIP</span><span class="o">=</span><span class="si">$(</span>kubectl get service svc-nodeport <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.spec.clusterIP}"</span><span class="si">)</span>
  <span class="nv">$ CIPPORT</span><span class="o">=</span><span class="si">$(</span>kubectl get service svc-nodeport <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.spec.ports[0].port}"</span><span class="si">)</span>
  <span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$CIP</span> <span class="nv">$CIPPORT</span>
  <span class="c"># =&gt; 10.200.1.169 9000</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane curl <span class="nt">-s</span> <span class="nv">$CIP</span>:<span class="nv">$CIPPORT</span> | jq
  <span class="c"># =&gt; {</span>
  <span class="c">#      "path": "/",</span>
  <span class="c">#      "headers": {</span>
  <span class="c">#        "host": "10.200.1.169:9000",</span>
  <span class="c">#        "user-agent": "curl/7.88.1",</span>
  <span class="c">#        "accept": "*/*"</span>
  <span class="c">#      },</span>
  <span class="c">#      "method": "GET",</span>
  <span class="c">#      "body": "",</span>
  <span class="c">#      "fresh": false,</span>
  <span class="c">#      "hostname": "10.200.1.169",</span>
  <span class="c">#      "ip": "::ffff:172.23.0.2",</span>
  <span class="c">#      "ips": [],</span>
  <span class="c">#      "protocol": "http",</span>
  <span class="c">#      "query": {},</span>
  <span class="c">#      "subdomains": [],</span>
  <span class="c">#      "xhr": false,</span>
  <span class="c">#      "os": {</span>
  <span class="c">#        "hostname": "deploy-echo-5c689d5454-rbgcp"</span>
  <span class="c">#      },</span>
  <span class="c">#      "connection": {}</span>
  <span class="c">#    }</span>
      
  <span class="c"># mypc에서 CLUSTER-IP:PORT 로 접속 가능할까?</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc curl <span class="nt">-s</span> <span class="nv">$CIP</span>:<span class="nv">$CIPPORT</span>
  <span class="c"># =&gt; (에러)</span>
      
  <span class="c"># mypc에서 cluster ip port로의 접속은 불가능합니다. mypc는 kubernetes 클러스터 내부에 있지 않기 때문입니다.</span>
      
  <span class="c"># (옵션) 노드에서 Network Connection</span>
  <span class="nv">$ </span>conntrack <span class="nt">-E</span>
  <span class="c"># =&gt;     [NEW] tcp      6 120 SYN_SENT src=172.23.0.2 dst=10.10.4.4 sport=36907 dport=8080 [UNREPLIED] src=10.10.4.4 dst=172.23.0.2 sport=8080 dport=36907</span>
  <span class="c">#     [UPDATE] tcp      6 60 SYN_RECV src=172.23.0.2 dst=10.10.4.4 sport=36907 dport=8080 src=10.10.4.4 dst=172.23.0.2 sport=8080 dport=36907</span>
  <span class="c">#     [UPDATE] tcp      6 86400 ESTABLISHED src=172.23.0.2 dst=10.10.4.4 sport=36907 dport=8080 src=10.10.4.4 dst=172.23.0.2 sport=8080 dport=36907 [ASSURED]</span>
  <span class="c">#     [UPDATE] tcp      6 120 FIN_WAIT src=172.23.0.2 dst=10.10.4.4 sport=36907 dport=8080 src=10.10.4.4 dst=172.23.0.2 sport=8080 dport=36907 [ASSURED]</span>
  <span class="c">#     [UPDATE] tcp      6 30 LAST_ACK src=172.23.0.2 dst=10.10.4.4 sport=36907 dport=8080 src=10.10.4.4 dst=172.23.0.2 sport=8080 dport=36907 [ASSURED]</span>
  <span class="c">#     [UPDATE] tcp      6 120 TIME_WAIT src=172.23.0.2 dst=10.10.4.4 sport=36907 dport=8080 src=10.10.4.4 dst=172.23.0.2 sport=8080 dport=36907 [ASSURED]</span>
  <span class="c">#      ...</span>
  <span class="c"># SNAT나 빠른 iptables 룰 처리등을 위해 접속 정보가 추적됨을 알 수 있습니다.</span>
      
  <span class="nv">$ </span>conntrack <span class="nt">-L</span> <span class="nt">--any-nat</span>
</code></pre></div>        </div>
      </li>
      <li>파드에서 바라본 클라이언트의 주소가 실제 클라이언트가 아닌 node의 ip로 표시되는데 그 이유를 살펴보겠습니다.
        <ul>
          <li>
            <p>컨트롤 플레인에서 iptables의 nat 테이블의 KUBE-POSTROUTING 룰을 확인하면 다음과 같습니다.</p>

            <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>iptables <span class="nt">-v</span> <span class="nt">--numeric</span> <span class="nt">--table</span> nat <span class="nt">--list</span> 
  <span class="c"># =&gt; Chain POSTROUTING (policy ACCEPT 5813 packets, 349K bytes)</span>
  <span class="c">#     pkts bytes target     prot opt in     out     source               destination         </span>
  <span class="c">#    37925 2276K KUBE-POSTROUTING  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */</span>
  <span class="c">#    ...</span>
  <span class="c">#    Chain KUBE-POSTROUTING (1 references)</span>
  <span class="c">#     pkts bytes target     prot opt in     out     source               destination</span>
  <span class="c">#     5343  321K RETURN     0    --  *      *       0.0.0.0/0            0.0.0.0/0            mark match ! 0x4000/0x4000</span>
  <span class="c">#     1265 75900 MARK       0    --  *      *       0.0.0.0/0            0.0.0.0/0            MARK xor 0x4000</span>
  <span class="c">#     1265 75900 MASQUERADE  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service traffic requiring SNAT */ random-fully</span>
</code></pre></div>            </div>

            <p>확인 결과 POSTROUTING시 KUBE-POSTROUTING을 통해 SNAT 되고 있음을 알 수 있습니다.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>외부 클라이언트 → 서비스(NodePort) 접속 시 : 3개의 목적지(backend) 파드로 <strong>랜덤 부하 분산</strong> 접속됨을 확인해보겠습니다.</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$CNODE</span>:<span class="nv">$NPORT</span> | <span class="nb">grep hostname</span><span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
  <span class="c"># =&gt;    100   "hostname": "172.23.0.2",</span>
  <span class="c">#        42     "hostname": "deploy-echo-5c689d5454-wppr8"</span>
  <span class="c">#        31     "hostname": "deploy-echo-5c689d5454-dxf2t"</span>
  <span class="c">#        27     "hostname": "deploy-echo-5c689d5454-rbgcp"</span>
      
  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$NODE1</span>:<span class="nv">$NPORT</span> | <span class="nb">grep hostname</span><span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
  <span class="c"># =&gt;     100   "hostname": "172.23.0.4",</span>
  <span class="c">#         37     "hostname": "deploy-echo-5c689d5454-dxf2t"</span>
  <span class="c">#         34     "hostname": "deploy-echo-5c689d5454-rbgcp"</span>
  <span class="c">#         29     "hostname": "deploy-echo-5c689d5454-wppr8"</span>
      
  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$NODE2</span>:<span class="nv">$NPORT</span> | <span class="nb">grep hostname</span><span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
  <span class="c"># =&gt;     100   "hostname": "172.23.0.5",</span>
  <span class="c">#         41     "hostname": "deploy-echo-5c689d5454-wppr8"</span>
  <span class="c">#         32     "hostname": "deploy-echo-5c689d5454-rbgcp"</span>
  <span class="c">#         27     "hostname": "deploy-echo-5c689d5454-dxf2t"</span>
      
  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$NODE3</span>:<span class="nv">$NPORT</span> | <span class="nb">grep hostname</span><span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
  <span class="c"># =&gt;     100   "hostname": "172.23.0.3",</span>
  <span class="c">#         39     "hostname": "deploy-echo-5c689d5454-dxf2t"</span>
  <span class="c">#         34     "hostname": "deploy-echo-5c689d5454-wppr8"</span>
  <span class="c">#         27     "hostname": "deploy-echo-5c689d5454-rbgcp"</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>웹 파드에서  log를 통해 접속자의 IP 확인시 외부 클라이언트 IP가 아닌, 노드의 IP로 SNAT 되어서 접속됨을 확인할 수 있습니다.</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>kubectl logs <span class="nt">-f</span> deploy-echo-5c689d5454-dxf2t | <span class="nb">grep </span>HTTP
  <span class="c"># =&gt; ::ffff:172.23.0.3 - - [01/Sep/2024:05:28:36 +0000] "GET / HTTP/1.1" 200 398 "-" "curl/7.88.1"</span>
  <span class="c">#    ::ffff:172.23.0.3 - - [01/Sep/2024:05:28:36 +0000] "GET / HTTP/1.1" 200 398 "-" "curl/7.88.1"</span>
  <span class="c">#    ::ffff:172.23.0.3 - - [01/Sep/2024:05:28:36 +0000] "GET / HTTP/1.1" 200 398 "-" "curl/7.88.1"</span>
  <span class="c">#    ::ffff:172.23.0.3 - - [01/Sep/2024:05:28:36 +0000] "GET / HTTP/1.1" 200 398 "-" "curl/7.88.1"</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>2.4.  IPTABLES 정책 확인
    <ul>
      <li>
        <p>iptables 정책 적용 순서는 다음과 같습니다.</p>

        <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_25.png" alt="img.png" loading="lazy" width="829" height="245"></p>

        <ul>
          <li>PREROUTING → KUBE-SERVICES → KUBE-NODEPORTS → <strong>KUBE-EXT-#(MARK)</strong> → KUBE-SVC-# → KUBE-SEP-#  ⇒ KUBE-POSTROUTING (MASQUERADE) <strong>**</strong>
</li>
          <li>
<code class="language-plaintext highlighter-rouge">KUBE-EXT-#(MARK)</code> 규칙 과정이 추가됨을 확인할 수 있습니다.</li>
        </ul>
      </li>
      <li>기본 규칙은 ClusterIP 서비스 동작 규칙과 거의 같으며 차이점은 KUBE-NODEPORTS, KUBE-MARK-MASK, KUBE-POSTROUTING 체인이  다릅니다. 핵심 내용은 NodePort에 매칭시 마킹 후 출발지 IP를 해당 노드에 있는 네트워크 IP로 변환(MASQUERADE : SNAT)하여 목적지 파드로 전달합니다.</li>
      <li>
        <p>실습을 통해 iptables 정책에 대해 확인해보겠습니다.  컨트롤플레인에서 실습을 진행하겠습니다.</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane bash
  <span class="nt">----------------------------------------</span>
      
  <span class="c"># 패킷 카운트 초기화</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">--zero</span>
      
  <span class="c"># PREROUTING 정보 확인</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep </span>PREROUTING
  <span class="c"># =&gt; -P PREROUTING ACCEPT</span>
  <span class="c">#    -A PREROUTING -m comment --comment "kubernetes service portals" -j KUBE-SERVICES</span>
  <span class="c">#    -A PREROUTING -d 172.23.0.1/32 -j DOCKER_OUTPUT</span>
      
  <span class="c"># 외부 클라이언트가 노드IP:NodePort 로 접속하기 때문에 --dst-type LOCAL 에 매칭되어서 -j KUBE-NODEPORTS 로 점프!</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep </span>KUBE-SERVICES
  <span class="c"># =&gt; ...</span>
  <span class="c">#    -A KUBE-SERVICES -m comment --comment "kubernetes service nodeports; NOTE: this must be the last rule in this chain" -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS</span>
      
  <span class="c"># KUBE-NODEPORTS 에서 KUBE-EXT-# 로 점프!</span>
  <span class="c">## -m nfacct --nfacct-name localhost_nps_accepted_pkts 추가됨 : 패킷 flow 카운팅 - 카운트 이름 지정 </span>
  <span class="nv">$ NPORT</span><span class="o">=</span><span class="si">$(</span>kubectl get service svc-nodeport <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.ports[0].nodePort}'</span><span class="si">)</span>
  <span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$NPORT</span>
  <span class="c"># =&gt; 31791</span>
      
  <span class="c"># $ iptables -t nat -S | grep KUBE-NODEPORTS | grep &lt;NodePort&gt;</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep </span>KUBE-NODEPORTS | <span class="nb">grep</span> <span class="nv">$NPORT</span>
  <span class="c"># =&gt; -A KUBE-NODEPORTS -p tcp -m comment --comment "default/svc-nodeport:svc-webport" -m tcp --dport 31791 -j KUBE-EXT-VTR7MTHHNMFZ3OFS</span>
      
  <span class="c"># (참고) nfacct 확인</span>
  <span class="nv">$ </span>nfacct list
  <span class="c">## nfacct flush # 초기화</span>
      
  <span class="c">## KUBE-EXT-# 에서 'KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000' 마킹 및 KUBE-SVC-# 로 점프!</span>
  <span class="c"># docker exec -it mypc zsh -c "while true; do curl -s --connect-timeout 1 $CNODE:$NPORT | grep hostname; date '+%Y-%m-%d %H:%M:%S' ; echo ;  sleep 1; done" 반복 접속 후 아래 확인</span>
  <span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'iptables -v --numeric --table nat --list KUBE-EXT-VTR7MTHHNMFZ3OFS'</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep</span> <span class="s2">"A KUBE-EXT-VTR7MTHHNMFZ3OFS"</span>
  <span class="c"># =&gt; -A KUBE-EXT-VTR7MTHHNMFZ3OFS -m comment --comment "masquerade traffic for default/svc-nodeport:svc-webport external destinations" -j KUBE-MARK-MASQ</span>
  <span class="c">#    -A KUBE-EXT-VTR7MTHHNMFZ3OFS -j KUBE-SVC-VTR7MTHHNMFZ3OFS</span>
      
  <span class="c"># iptables -t nat -S | grep "A KUBE-MARK-MASQ" | sed -e 's/^/#    /' -e '1s/^#    /# =&gt; /'</span>
  <span class="c"># =&gt; -A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000        # 0x4000/0x4000으로 마킹하는 룰</span>
      
  <span class="c"># KUBE-SVC-# 이후 과정은 Cluster-IP 와 동일! : 3개의 파드로 DNAT 되어서 전달</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep</span> <span class="s2">"A KUBE-SVC-VTR7MTHHNMFZ3OFS -"</span>
  <span class="c"># =&gt; -A KUBE-SVC-VTR7MTHHNMFZ3OFS -m comment --comment "default/svc-nodeport:svc-webport -&gt; 10.10.1.5:8080" -m statistic --mode random --probability 0.33333333349 -j KUBE-SEP-SESYGQFRQSLJQZ6Q</span>
  <span class="c">#    -A KUBE-SVC-VTR7MTHHNMFZ3OFS -m comment --comment "default/svc-nodeport:svc-webport -&gt; 10.10.2.7:8080" -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-FBJG45W6XHLV2NA6</span>
  <span class="c">#    -A KUBE-SVC-VTR7MTHHNMFZ3OFS -m comment --comment "default/svc-nodeport:svc-webport -&gt; 10.10.4.4:8080" -j KUBE-SEP-GEQNJ6BO5AOHB6LH</span>
      
  <span class="c"># POSTROUTING 정보 확인</span>
  <span class="c"># 마킹되어 있어서 출발지IP를 접속한 노드의 IP 로 SNAT(MASQUERADE) 처리함! , 최초 출발지Port는 랜덤Port 로 변경</span>
  <span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep</span> <span class="s2">"A KUBE-POSTROUTING"</span>
  <span class="c"># =&gt; -A KUBE-POSTROUTING -m mark ! --mark 0x4000/0x4000 -j RETURN   # 0x4000/0x4000 되어 있으니 여기에 매칭되지 않고 아래 Rule로 내려감</span>
  <span class="c">#    -A KUBE-POSTROUTING -j MARK --set-xmark 0x4000/0x0</span>
  <span class="c">#    -A KUBE-POSTROUTING -m comment --comment "kubernetes service traffic requiring SNAT" -j MASQUERADE --random-fully</span>
      
  <span class="c"># docker exec -it mypc zsh -c "while true; do curl -s --connect-timeout 1 $CNODE:$NPORT | grep hostname; date '+%Y-%m-%d %H:%M:%S' ; echo ;  sleep 1; done" 반복 접속 후 아래 확인</span>
  <span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'iptables -v --numeric --table nat --list KUBE-POSTROUTING;echo;iptables -v --numeric --table nat --list POSTROUTING'</span>
      
  <span class="nv">$ </span><span class="nb">exit</span>
  <span class="nt">----------------------------------------</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>서비스 (NodePort) 생성 시 kube-proxy에 의해서 iptables 규칙이 모든 노드에 추가되는지 확인해보겠습니다.</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c">#</span>
  <span class="nv">$ NPORT</span><span class="o">=</span><span class="si">$(</span>kubectl get service svc-nodeport <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.ports[0].nodePort}'</span><span class="si">)</span>
  <span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$NPORT</span> 
  <span class="c"># =&gt; 31791</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep </span>KUBE-NODEPORTS | <span class="nb">grep</span> <span class="nv">$NPORT</span>
  <span class="c"># =&gt; -A KUBE-NODEPORTS -p tcp -m comment --comment "default/svc-nodeport:svc-webport" -m tcp --dport 31791 -j KUBE-EXT-VTR7MTHHNMFZ3OFS</span>
      
  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep </span>KUBE-NODEPORTS | <span class="nb">grep</span> <span class="nv">$NPORT</span><span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; &gt;&gt; node myk8s-control-plane &lt;&lt;</span>
  <span class="c">#    -A KUBE-NODEPORTS -p tcp -m comment --comment "default/svc-nodeport:svc-webport" -m tcp --dport 31791 -j KUBE-EXT-VTR7MTHHNMFZ3OFS</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker &lt;&lt;</span>
  <span class="c">#    -A KUBE-NODEPORTS -p tcp -m comment --comment "default/svc-nodeport:svc-webport" -m tcp --dport 31791 -j KUBE-EXT-VTR7MTHHNMFZ3OFS</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker2 &lt;&lt;</span>
  <span class="c">#    -A KUBE-NODEPORTS -p tcp -m comment --comment "default/svc-nodeport:svc-webport" -m tcp --dport 31791 -j KUBE-EXT-VTR7MTHHNMFZ3OFS</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker3 &lt;&lt;</span>
  <span class="c">#    -A KUBE-NODEPORTS -p tcp -m comment --comment "default/svc-nodeport:svc-webport" -m tcp --dport 31791 -j KUBE-EXT-VTR7MTHHNMFZ3OFS</span>
</code></pre></div>        </div>
      </li>
      <li>iptables 룰이 모든 노드에 추가되어있음을 확인 할 수 있습니다.</li>
    </ul>
  </li>
  <li>2.5. externalTrafficPolicy  설정
    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">externalTrafficPolicy: Local</code> : 앞에서 실습한 바와같이 서비스가 바라보는 파드에 접속시 클라이언트 IP가 node의 IP로 접속됩니다. 이때 <code class="language-plaintext highlighter-rouge">externalTrafficPolicy: Local</code> 를 하면 <strong>해당 노드에 배치된 파드로만 접속되면서</strong>, SNAT가 되지않아 <strong>외부 클라이언트 IP가 보존</strong>됩니다.</p>

        <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_26.png" alt="img.png" loading="lazy" width="955" height="354"></p>

        <ul>
          <li>이전까지는 같은 iptables 룰이 모든 노드에 적용 되었지만, 노드 자신의 파드로만 가는 룰만 있어서 각각 조금씩 다른 룰이 적용되게 됩니다.</li>
        </ul>

        <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_27.png" alt="img.png" loading="lazy" width="952" height="356"></p>

        <ul>
          <li>만약 노드에 해당하는 파드가 없으면 위의 그림과 같이 연결이 실패하게되니 사용에 주의가 필요합니다.</li>
        </ul>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">externalTrafficPolicy: Local</code> 설정 시의 통신 흐름을 좀 더 자세히 알아보겠습니다.</p>

        <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_28.png" alt="img.png" loading="lazy" width="722" height="180"></p>

        <ul>
          <li>클라이언트에서 파드가 배포되어있는 워커노드1에 NodePort로 접속합니다.</li>
          <li>워커노드1의 IPTABLES의 nat 테이블 규칙과 매칭되어 목적지 IP와 목적지 Port는 변환 되지만, SNAT 되지 않고 바로 파드로 전달되므로 클라이언트의 IP가 파드에 그대로 전달 됩니다.</li>
        </ul>
      </li>
      <li>
        <p>설정 및 파드 접속 확인</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># 기본 정보 확인</span>
  <span class="nv">$ </span>kubectl get svc svc-nodeport <span class="nt">-o</span> json | <span class="nb">grep</span> <span class="s1">'TrafficPolicy"'</span>
  <span class="c"># =&gt;         "externalTrafficPolicy": "Cluster",</span>
  <span class="c">#            "internalTrafficPolicy": "Cluster",</span>
      
  <span class="c"># 기존 통신 연결 정보(conntrack) 제거 후 아래 실습 진행하자! : (모든 노드에서) conntrack -F</span>
  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> conntrack <span class="nt">-F</span><span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; &gt;&gt; node myk8s-control-plane &lt;&lt;</span>
  <span class="c">#    conntrack v1.4.7 (conntrack-tools): connection tracking table has been emptied.</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker &lt;&lt;</span>
  <span class="c">#    conntrack v1.4.7 (conntrack-tools): connection tracking table has been emptied.</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker2 &lt;&lt;</span>
  <span class="c">#    conntrack v1.4.7 (conntrack-tools): connection tracking table has been emptied.</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node myk8s-worker3 &lt;&lt;</span>
  <span class="c">#    conntrack v1.4.7 (conntrack-tools): connection tracking table has been emptied.</span>
  <span class="c">#    </span>
  <span class="nv">$ </span>kubectl delete <span class="nt">-f</span> svc-nodeport.yml
  <span class="c"># =&gt; service "svc-nodeport" deleted</span>
  <span class="nv">$ </span>kubectl apply <span class="nt">-f</span> svc-nodeport.yml
  <span class="c"># =&gt; service/svc-nodeport created</span>
      
  <span class="c"># externalTrafficPolicy: local 설정 변경</span>
  <span class="nv">$ </span>kubectl patch svc svc-nodeport <span class="nt">-p</span> <span class="s1">'{"spec":{"externalTrafficPolicy": "Local"}}'</span>
  <span class="c"># =&gt; service/svc-nodeport patched</span>
  <span class="nv">$ </span>kubectl get svc svc-nodeport <span class="nt">-o</span> json | <span class="nb">grep</span> <span class="s1">'TrafficPolicy"'</span>
  <span class="c"># =&gt;         "externalTrafficPolicy": "Local",</span>
  <span class="c">#            "internalTrafficPolicy": "Cluster",</span>
      
  <span class="c"># 파드 3개를 2개로 줄입니다.</span>
  <span class="nv">$ </span>kubectl scale deployment deploy-echo <span class="nt">--replicas</span><span class="o">=</span>2
  <span class="c"># =&gt; deployment.apps/deploy-echo scaled</span>
</code></pre></div>        </div>

        <p><img src="/assets/2024/kans-3th/w4/20240928_kans_w4_29.png" alt="img.png" loading="lazy" width="719" height="277"></p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># 파드 존재하는 노드 정보 확인</span>
  <span class="nv">$ </span>kubectl get pod <span class="nt">-owide</span>
  <span class="c"># =&gt; NAME                           READY   STATUS    RESTARTS   AGE   IP          NODE                  NOMINATED NODE   READINESS GATES</span>
  <span class="c">#    deploy-echo-5c689d5454-24cql   1/1     Running   0          30s   10.10.4.5   myk8s-worker          &lt;none&gt;           &lt;none&gt;</span>
  <span class="c">#    deploy-echo-5c689d5454-2kgfj   1/1     Running   0          30s   10.10.1.6   myk8s-worker2         &lt;none&gt;           &lt;none&gt;</span>
  <span class="c">#    net-pod                        1/1     Running   0          46h   10.10.0.7   myk8s-control-plane   &lt;none&gt;           &lt;none&gt;</span>
      
  <span class="c"># 파드 로그 실시간 확인 (웹 파드에 접속자의 IP가 출력)</span>
  <span class="nv">$ </span>kubectl logs <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>deploy-websrv <span class="nt">-f</span>
      
  <span class="c"># 외부 클라이언트(mypc)에서 접속 시도</span>
      
  <span class="c"># 노드의 IP와 NodePort를 변수에 지정</span>
  <span class="c">## CNODE=&lt;컨트롤플레인노드의 IP주소&gt;</span>
  <span class="c">## NODE1=&lt;노드1의 IP주소&gt;</span>
  <span class="c">## NODE2=&lt;노드2의 IP주소&gt;</span>
  <span class="c">## NODE3=&lt;노드3의 IP주소&gt;</span>
  <span class="nv">$ CNODE</span><span class="o">=</span>172.23.0.2
  <span class="nv">$ NODE1</span><span class="o">=</span>172.23.0.4
  <span class="nv">$ NODE2</span><span class="o">=</span>172.23.0.5
  <span class="nv">$ NODE3</span><span class="o">=</span>172.23.0.3
      
  <span class="c">## NodePort 를 변수에 지정</span>
  <span class="nv">$ NPORT</span><span class="o">=</span><span class="si">$(</span>kubectl get service svc-nodeport <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.ports[0].nodePort}'</span><span class="si">)</span>
  <span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$NPORT</span>
  <span class="c"># =&gt; 31177</span>
      
  <span class="c"># 서비스(NodePort) 부하분산 접속 확인 : 파드가 존재하지 않는 노드로는 접속 실패!, 파드가 존재하는 노드는 접속 성공 및 클라이언트 IP 확인!</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$CNODE</span>:<span class="nv">$NPORT</span> | jq
  <span class="c"># =&gt; (공백)</span>
  <span class="c"># 컨트롤 플레인에는 파드가 없으므로 결과가 없습니다.</span>
      
  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="nv">$CNODE</span> <span class="nv">$NODE1</span> <span class="nv">$NODE2</span> <span class="nv">$NODE3</span> <span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node </span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> mypc curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$i</span>:<span class="nv">$NPORT</span><span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; &gt;&gt; node 172.23.0.2 &lt;&lt;</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node 172.23.0.4 &lt;&lt;</span>
  <span class="c">#    {</span>
  <span class="c">#      "path": "/",</span>
  <span class="c">#      "headers": {</span>
  <span class="c">#        "host": "172.23.0.4:31177",</span>
  <span class="c">#        ...</span>
  <span class="c">#      },</span>
  <span class="c">#      ...</span>
  <span class="c">#      "hostname": "172.23.0.4",</span>
  <span class="c">#      "ip": "::ffff:172.23.0.6",</span>
  <span class="c">#      ...</span>
  <span class="c">#      "os": {</span>
  <span class="c">#        "hostname": "deploy-echo-5c689d5454-24cql"</span>
  <span class="c">#      }</span>
  <span class="c">#    }</span>
  <span class="c">#    &gt;&gt; node 172.23.0.5 &lt;&lt;</span>
  <span class="c">#    {</span>
  <span class="c">#      "headers": {</span>
  <span class="c">#        "host": "172.23.0.5:31177",</span>
  <span class="c">#        ...</span>
  <span class="c">#      },</span>
      
  <span class="c">#      "hostname": "172.23.0.5",</span>
  <span class="c">#      "ip": "::ffff:172.23.0.6",</span>
  <span class="c">#      ...</span>
  <span class="c">#      "os": {</span>
  <span class="c">#        "hostname": "deploy-echo-5c689d5454-2kgfj"</span>
  <span class="c">#      }</span>
  <span class="c">#    }</span>
  <span class="c">#    &gt;&gt; node 172.23.0.3 &lt;&lt;</span>
  <span class="c">#    </span>
      
  <span class="c"># 목적지 파드가 배치되지 않은 노드는 접속이 어떻게? 왜 그런가?</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100}; do curl -s </span><span class="nv">$CNODE</span><span class="s2">:</span><span class="nv">$NPORT</span><span class="s2"> | grep hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt; </span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100}; do curl -s </span><span class="nv">$NODE1</span><span class="s2">:</span><span class="nv">$NPORT</span><span class="s2"> | grep hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt;     100   "hostname": "172.23.0.4",</span>
  <span class="c">#        100     "hostname": "deploy-echo-5c689d5454-24cql"</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100}; do curl -s </span><span class="nv">$NODE2</span><span class="s2">:</span><span class="nv">$NPORT</span><span class="s2"> | grep hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt;     100   "hostname": "172.23.0.5",</span>
  <span class="c">#        100     "hostname": "deploy-echo-5c689d5454-2kgfj"</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc zsh <span class="nt">-c</span> <span class="s2">"for i in {1..100}; do curl -s </span><span class="nv">$NODE3</span><span class="s2">:</span><span class="nv">$NPORT</span><span class="s2"> | grep hostname; done | sort | uniq -c | sort -nr"</span>
  <span class="c"># =&gt; </span>
  <span class="c"># 목적지 파드가 배치되지 않은 노드는 응답이 없어 타임아웃이 됩니다. 그 이유는 externalTrafficPolicy: Local여서 노드포트로 온 패킷이, local pod로 전달하려고 하는데</span>
  <span class="c"># local pod가 없기 때문입니다.</span>
      
  <span class="c"># 아래 반복 접속 실행 해두자</span>
  <span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> mypc zsh <span class="nt">-c</span> <span class="s2">"while true; do curl -s --connect-timeout 1 </span><span class="nv">$NODE2</span><span class="s2">:</span><span class="nv">$NPORT</span><span class="s2"> | grep hostname; date '+%Y-%m-%d %H:%M:%S' ; echo ;  sleep 1; done"</span>
      
  <span class="c"># (옵션) 노드에서 Network Connection</span>
  <span class="nv">$ </span>conntrack <span class="nt">-E</span>
  <span class="nv">$ </span>conntrack <span class="nt">-L</span> <span class="nt">--any-nat</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>외부 클라이언트 → 각각 워커 노드 1,2 접속시 각각 노드의 파드로만 접속 됩니다.</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># 호스트에서 실행</span>
  <span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="nv">$CNODE</span> <span class="nv">$NODE1</span> <span class="nv">$NODE2</span> <span class="nv">$NODE3</span> <span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node </span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$i</span>:<span class="nv">$NPORT</span><span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
  <span class="c"># =&gt; &gt;&gt; node 172.23.0.2 &lt;&lt;</span>
  <span class="c">#    </span>
  <span class="c">#    &gt;&gt; node 172.23.0.4 &lt;&lt;</span>
  <span class="c">#    {</span>
  <span class="c">#      "headers": {</span>
  <span class="c">#        "host": "172.23.0.4:31177",</span>
  <span class="c">#      },</span>
  <span class="c">#      "hostname": "172.23.0.4",</span>
  <span class="c">#      "ip": "::ffff:172.23.0.1",</span>
  <span class="c">#      "os": {</span>
  <span class="c">#        "hostname": "deploy-echo-5c689d5454-24cql"</span>
  <span class="c">#      }</span>
  <span class="c">#    }</span>
  <span class="c">#    &gt;&gt; node 172.23.0.5 &lt;&lt;</span>
  <span class="c">#    {</span>
  <span class="c">#      "headers": {</span>
  <span class="c">#        "host": "172.23.0.5:31177",</span>
  <span class="c">#      },</span>
  <span class="c">#      "hostname": "172.23.0.5",</span>
  <span class="c">#      "ip": "::ffff:172.23.0.1",</span>
  <span class="c">#      "os": {</span>
  <span class="c">#        "hostname": "deploy-echo-5c689d5454-2kgfj"</span>
  <span class="c">#      }</span>
  <span class="c">#    }</span>
  <span class="c">#    &gt;&gt; node 172.23.0.3 &lt;&lt;    </span>
    
  <span class="c"># 다른 터미널에서 로그 표시</span>
  <span class="nv">$ </span>kubectl logs <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>deploy-websrv <span class="nt">-f</span> | <span class="nb">grep </span>HTTP
  ::ffff:172.23.0.1 - - <span class="o">[</span>26/Sep/2024:07:33:09 +0000] <span class="s2">"GET / HTTP/1.1"</span> 200 397 <span class="s2">"-"</span> <span class="s2">"curl/8.7.1"</span>
  ::ffff:172.23.0.1 - - <span class="o">[</span>26/Sep/2024:07:33:10 +0000] <span class="s2">"GET / HTTP/1.1"</span> 200 397 <span class="s2">"-"</span> <span class="s2">"curl/8.7.1"</span>
  ::ffff:172.23.0.1 - - <span class="o">[</span>26/Sep/2024:07:33:26 +0000] <span class="s2">"GET / HTTP/1.1"</span> 200 397 <span class="s2">"-"</span> <span class="s2">"curl/8.7.1"</span>
  ::ffff:172.23.0.1 - - <span class="o">[</span>26/Sep/2024:07:33:26 +0000] <span class="s2">"GET / HTTP/1.1"</span> 200 397 <span class="s2">"-"</span> <span class="s2">"curl/8.7.1"</span>
</code></pre></div>        </div>
        <ul>
          <li>
<code class="language-plaintext highlighter-rouge">kubectl logs -l app=deploy-websrv -f</code>로 확인시 외부 클라이언트인 172.23.0.1이 보존되는 것을 확인 할 수 있습니다.</li>
        </ul>
      </li>
      <li>이렇게 동작하는 이유를 iptables 룰을 통해 확인해보겠습니다.
        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 컨트롤플레인 노드 - iptables 분석 &lt;&lt; 정책 확인 : 아래 정책 내용은 핵심적인 룰(rule)만 표시했습니다!</span>
<span class="c"># (예시) 파드가 배포되어 있는 노드1에서 확인했습니다</span>
    
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-worker bash
<span class="nt">---------------------------------------</span>
    
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span>
<span class="c"># $ iptables -t nat -S | grep &lt;NodePort&gt;</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep </span>31177
<span class="c"># =&gt; -A KUBE-NODEPORTS -p tcp -m comment --comment "default/svc-nodeport:svc-webport" -m tcp --dport 31177 -j KUBE-EXT-VTR7MTHHNMFZ3OFS</span>
    
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep</span> <span class="s1">'A KUBE-EXT-VTR7MTHHNMFZ3OFS'</span>
<span class="c"># =&gt; -A KUBE-EXT-VTR7MTHHNMFZ3OFS -s 10.10.0.0/16 -m comment --comment "pod traffic for default/svc-nodeport:svc-webport external destinations" -j KUBE-SVC-VTR7MTHHNMFZ3OFS</span>
<span class="c">#    -A KUBE-EXT-VTR7MTHHNMFZ3OFS -m comment --comment "masquerade LOCAL traffic for default/svc-nodeport:svc-webport external destinations" -m addrtype --src-type LOCAL -j KUBE-MARK-MASQ</span>
<span class="c">#    -A KUBE-EXT-VTR7MTHHNMFZ3OFS -m comment --comment "route LOCAL traffic for default/svc-nodeport:svc-webport external destinations" -m addrtype --src-type LOCAL -j KUBE-SVC-VTR7MTHHNMFZ3OFS</span>
<span class="c">#    -A KUBE-EXT-VTR7MTHHNMFZ3OFS -j KUBE-SVL-VTR7MTHHNMFZ3OFS</span>
    
<span class="c"># 실습 환경에서는 아래처럼 2개의 파드 중 자신의 노드에 생성된 파드 1개만 DNAT 연결됨</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep</span> <span class="s1">'A KUBE-SVL-VTR7MTHHNMFZ3OFS'</span>
<span class="c"># =&gt; -A KUBE-SVL-VTR7MTHHNMFZ3OFS -m comment --comment "default/svc-nodeport:svc-webport -&gt; 10.10.4.5:8080" -j KUBE-SEP-COBCKEECYTEF2ZXK</span>
    
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep</span> <span class="s1">'A KUBE-SEP-COBCKEECYTEF2ZXK'</span>
<span class="c"># =&gt; -A KUBE-SEP-COBCKEECYTEF2ZXK -s 10.10.4.5/32 -m comment --comment "default/svc-nodeport:svc-webport" -j KUBE-MARK-MASQ</span>
<span class="c">#    -A KUBE-SEP-COBCKEECYTEF2ZXK -p tcp -m comment --comment "default/svc-nodeport:svc-webport" -m tcp -j DNAT --to-destination 10.10.4.5:8080</span>
    
<span class="nv">$ </span><span class="nb">exit</span>
<span class="c"># ---------------------------------------</span>
</code></pre></div>        </div>
        <ul>
          <li>정책을 확인해보면 <code class="language-plaintext highlighter-rouge">externalTrafficPolicy: Local</code> 설정 전에는 MASQUERADE로 SNAT 되었지만, 설정 후에는 DNAT으로 바로 전달되는 것을 확인할 수 있습니다.</li>
          <li>SNAT 되지 않았기 때문에 클라이언트의 IP가 그대로 전달되어 파드에서 확인할 수 있습니다.</li>
        </ul>
      </li>
      <li>서비스(NodePort, externalTrafficPolicy: Local) 생성 시 iptables 규칙(KUBE-SVL-#)이 모든 노드에 추가되는지 확인해보겠습니다.
        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 컨트롤 플레인에는 파드가 없으므로 결과가 없습니다.</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep</span> <span class="s1">'A KUBE-SVL-VTR7MTHHNMFZ3OFS'</span>
<span class="c"># =&gt; (공백)</span>
    
<span class="c"># 각 노드에 확인해보겠습니다.</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>control-plane worker worker2 worker3<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; node myk8s-</span><span class="nv">$i</span><span class="s2"> &lt;&lt;"</span><span class="p">;</span> docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-<span class="nv">$i</span> iptables <span class="nt">-t</span> nat <span class="nt">-S</span> | <span class="nb">grep</span> <span class="s1">'A KUBE-SVL-VTR7MTHHNMFZ3OFS'</span><span class="p">;</span> <span class="nb">echo</span><span class="p">;</span> <span class="k">done</span>
<span class="c"># =&gt; &gt;&gt; node myk8s-control-plane &lt;&lt;</span>
<span class="c">#    </span>
<span class="c">#    &gt;&gt; node myk8s-worker &lt;&lt;</span>
<span class="c">#    -A KUBE-SVL-VTR7MTHHNMFZ3OFS -m comment --comment "default/svc-nodeport:svc-webport -&gt; 10.10.4.5:8080" -j KUBE-SEP-COBCKEECYTEF2ZXK</span>
<span class="c">#    </span>
<span class="c">#    &gt;&gt; node myk8s-worker2 &lt;&lt;</span>
<span class="c">#    -A KUBE-SVL-VTR7MTHHNMFZ3OFS -m comment --comment "default/svc-nodeport:svc-webport -&gt; 10.10.1.6:8080" -j KUBE-SEP-ABUS75FNO53OAK6G</span>
<span class="c">#    </span>
<span class="c">#    &gt;&gt; node myk8s-worker3 &lt;&lt;</span>
</code></pre></div>        </div>
        <ul>
          <li>파드가 있는 worker, worker2 노드에만 iptables 규칙이 추가되어 있음을 확인할 수 있습니다.</li>
        </ul>
      </li>
      <li>NodePort의 부족한 점
        <ul>
          <li>외부에서 노드의 IP와 포트로 직접 접속이 필요합니다.</li>
          <li>따라서 내부망이 외부에 공개(라우팅 가능)되어 보안에 취약합니다.
            <ul>
              <li>=&gt; <strong>LoadBalancer 서비스</strong> 타입으로 외부 공개 최소화 가능</li>
            </ul>
          </li>
          <li>클라이언트 IP 보존을 위해서, <code class="language-plaintext highlighter-rouge">externalTrafficPolicy: local</code>를 사용하면 파드가 없는 노드 IP로 NodePort 접속 시 실패하게 됩니다.
            <ul>
              <li>=&gt; <strong>LoadBalancer 서비스</strong>에서 헬스체크(Probe) 로 대응 가능</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="파드간-속도-측정">파드간 속도 측정</h4>

<ul>
  <li>이번 실습에서는 iperf3를 사용해서 파드간 속도를 측정해보겠습니다.</li>
  <li>iperf3는 네트워크 대역폭을 측정하는 도구로, 서버와 클라이언트로 나뉘어 서버는 대역폭을 제공하고 클라이언트는 대역폭을 측정합니다. TCP와 UDP, SCTP를 지원합니다.</li>
  <li>iperf3의 기본 사용법을 살펴 보겠습니다.
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># iperf3 설치 </span>
<span class="c"># macOS 인 경우</span>
<span class="nv">$ </span>brew <span class="nb">install </span>iperf3
<span class="c"># ubuntu 등 debian 계열인 경우 </span>
<span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>iperf3 <span class="nt">-y</span>
  
<span class="c"># iperf3 테스트 1 : TCP 5201, 측정시간 10초</span>
<span class="nv">$ </span>iperf3 <span class="nt">-s</span> <span class="c"># 서버모드 실행</span>
<span class="c"># =&gt; -----------------------------------------------------------</span>
<span class="c">#    Server listening on 5201</span>
<span class="c">#    -----------------------------------------------------------</span>
<span class="c">#    Accepted connection from 127.0.0.1, port 40142</span>
<span class="c">#    [  5] local 127.0.0.1 port 5201 connected to 127.0.0.1 port 40154</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate</span>
<span class="c">#    [  5]   0.00-1.00   sec  7.11 GBytes  61.1 Gbits/sec</span>
<span class="c">#    [  5]   1.00-2.00   sec  8.03 GBytes  68.9 Gbits/sec</span>
<span class="c">#    [  5]   2.00-3.00   sec  7.53 GBytes  64.7 Gbits/sec</span>
<span class="c">#    [  5]   3.00-4.00   sec  7.73 GBytes  66.4 Gbits/sec</span>
<span class="c">#    [  5]   4.00-5.00   sec  7.64 GBytes  65.6 Gbits/sec</span>
<span class="c">#    [  5]   5.00-6.00   sec  7.89 GBytes  67.8 Gbits/sec</span>
<span class="c">#    [  5]   6.00-7.00   sec  7.95 GBytes  68.3 Gbits/sec</span>
<span class="c">#    [  5]   7.00-8.00   sec  7.78 GBytes  66.9 Gbits/sec</span>
<span class="c">#    [  5]   8.00-9.00   sec  7.91 GBytes  67.9 Gbits/sec</span>
<span class="c">#    [  5]   9.00-10.00  sec  7.64 GBytes  65.6 Gbits/sec</span>
<span class="c">#    [  5]  10.00-10.05  sec   384 MBytes  66.0 Gbits/sec</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate</span>
<span class="c">#    [  5]   0.00-10.05  sec  77.6 GBytes  66.3 Gbits/sec                  receiver</span>
<span class="nv">$ </span>iperf3 <span class="nt">-c</span> 127.0.0.1 <span class="c"># 다른 터미널에서 클라이언트모드 실행</span>
<span class="c"># =&gt; Connecting to host 127.0.0.1, port 5201</span>
<span class="c">#    [  5] local 127.0.0.1 port 40154 connected to 127.0.0.1 port 5201</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate         Retr  Cwnd</span>
<span class="c">#    [  5]   0.00-1.00   sec  7.48 GBytes  64.2 Gbits/sec    8   2.69 MBytes</span>
<span class="c">#    ...</span>
<span class="c">#    [  5]   9.00-10.00  sec  7.72 GBytes  66.3 Gbits/sec    1   3.06 MBytes</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate         Retr</span>
<span class="c">#    [  5]   0.00-10.00  sec  77.6 GBytes  66.6 Gbits/sec   53             sender</span>
<span class="c">#    [  5]   0.00-10.05  sec  77.6 GBytes  66.3 Gbits/sec                  receiver</span>
  
<span class="c"># iperf3 테스트 2 : TCP 80, 측정시간 5초</span>
<span class="nv">$ </span>iperf3 <span class="nt">-s</span> <span class="nt">-p</span> 80
<span class="nv">$ </span>iperf3 <span class="nt">-c</span> 127.0.0.1 <span class="nt">-p</span> 80 <span class="nt">-t</span> 5
  
<span class="c"># iperf3 테스트 3 : UDP 사용, 역방향 모드(-R)</span>
<span class="nv">$ </span>iperf3 <span class="nt">-s</span> 
<span class="nv">$ </span>iperf3 <span class="nt">-c</span> 127.0.0.1 <span class="nt">-u</span> <span class="nt">-b</span> 100G
  
<span class="c"># iperf3 테스트 4 : 역방향 모드(-R) =&gt; 서버에서 클라이언트로 전송할때 속도를 측정합니다.  </span>
<span class="nv">$ </span>iperf3 <span class="nt">-s</span> 
<span class="nv">$ </span>iperf3 <span class="nt">-c</span> 127.0.0.1 <span class="nt">-R</span>
  
<span class="c"># iperf3 테스트 5 : 쌍방향 모드(-R)</span>
<span class="nv">$ </span>iperf3 <span class="nt">-s</span> 
<span class="nv">$ </span>iperf3 <span class="nt">-c</span> 127.0.0.1 <span class="nt">--bidir</span>
  
<span class="c"># iperf3 테스트 6 : TCP 다중 스트림(30개), -P(number of parallel client streams to run)</span>
<span class="nv">$ </span>iperf3 <span class="nt">-s</span> 
<span class="nv">$ </span>iperf3 <span class="nt">-c</span> 127.0.0.1 <span class="nt">-P</span> 2 <span class="nt">-t</span> 30
</code></pre></div>    </div>
  </li>
  <li>쿠버네티스 환경에서 속도 측정 테스트해보겠습니다.
    <ul>
      <li>테스트 환경 배포
        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 배포</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/gasida/PKOS/main/aews/k8s-iperf3.yaml
    
<span class="c"># 확인 : 서버와 클라이언트가 다른 워커노드에 배포되었는지 확인</span>
<span class="nv">$ </span>kubectl get deploy,svc,pod <span class="nt">-owide</span>
<span class="c"># =&gt; NAME                            READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS      IMAGES                    SELECTOR</span>
<span class="c">#    deployment.apps/iperf3-client   0/1     1            0           5s    iperf3-client   networkstatic/iperf3      app=iperf3-client</span>
<span class="c">#    deployment.apps/iperf3-server   0/1     1            0           5s    iperf3-server   networkstatic/iperf3      app=iperf3-server</span>
<span class="c">#    </span>
<span class="c">#    NAME                    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)             AGE    SELECTOR</span>
<span class="c">#    service/iperf3-server   ClusterIP   10.200.1.166   &lt;none&gt;        5201/TCP,5201/UDP   5s     app=iperf3-server</span>
<span class="c">#    </span>
<span class="c">#    NAME                                 READY   STATUS              RESTARTS   AGE    IP          NODE                  NOMINATED NODE   READINESS GATES</span>
<span class="c">#    pod/iperf3-client-598b85fd6b-tq5xg   0/1     ContainerCreating   0          5s     &lt;none&gt;      myk8s-worker3         &lt;none&gt;           &lt;none&gt;</span>
<span class="c">#    pod/iperf3-server-688df6d56f-hlhrm   0/1     ContainerCreating   0          5s     &lt;none&gt;      myk8s-worker          &lt;none&gt;           &lt;none&gt;</span>
    
<span class="c"># 서버 파드 로그 확인 : 기본 5201 포트 Listen</span>
<span class="nv">$ </span>kubectl logs <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>iperf3-server <span class="nt">-f</span>
</code></pre></div>        </div>
      </li>
      <li>TCP 5201, 측정시간 5초
        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 클라이언트 파드에서 아래 명령 실행</span>
<span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> deploy/iperf3-client <span class="nt">--</span> iperf3 <span class="nt">-c</span> iperf3-server <span class="nt">-t</span> 5
<span class="c"># =&gt; Connecting to host iperf3-server, port 5201</span>
<span class="c">#    [  5] local 10.10.2.9 port 54972 connected to 10.200.1.166 port 5201</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate         Retr  Cwnd</span>
<span class="c">#    [  5]   0.00-1.00   sec  4.68 GBytes  40.2 Gbits/sec  3333   1.07 MBytes</span>
<span class="c">#    [  5]   1.00-2.00   sec  4.87 GBytes  41.8 Gbits/sec  1293   1.09 MBytes</span>
<span class="c">#    [  5]   2.00-3.00   sec  4.86 GBytes  41.8 Gbits/sec  1020   1.11 MBytes</span>
<span class="c">#    [  5]   3.00-4.00   sec  4.85 GBytes  41.7 Gbits/sec  590   1.21 MBytes</span>
<span class="c">#    [  5]   4.00-5.00   sec  4.93 GBytes  42.4 Gbits/sec  988   1.27 MBytes</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate         Retr</span>
<span class="c">#    [  5]   0.00-5.00   sec  24.2 GBytes  41.6 Gbits/sec  7224             sender</span>
<span class="c">#    [  5]   0.00-5.00   sec  24.2 GBytes  41.6 Gbits/sec                  receiver</span>
    
<span class="c"># 서버 파드 로그 확인 : 기본 5201 포트 Listen</span>
<span class="nv">$ </span>kubectl logs <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>iperf3-server <span class="nt">-f</span>
<span class="c"># =&gt; -----------------------------------------------------------</span>
<span class="c">#    Server listening on 5201 (test #1)</span>
<span class="c">#    -----------------------------------------------------------</span>
<span class="c">#    Accepted connection from 10.10.2.9, port 54962</span>
<span class="c">#    [  5] local 10.10.4.6 port 5201 connected to 10.10.2.9 port 54972</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate</span>
<span class="c">#    [  5]   0.00-1.00   sec  4.67 GBytes  40.1 Gbits/sec</span>
<span class="c">#    [  5]   1.00-2.00   sec  4.87 GBytes  41.8 Gbits/sec</span>
<span class="c">#    [  5]   2.00-3.00   sec  4.86 GBytes  41.8 Gbits/sec</span>
<span class="c">#    [  5]   3.00-4.00   sec  4.85 GBytes  41.7 Gbits/sec</span>
<span class="c">#    [  5]   4.00-5.00   sec  4.93 GBytes  42.4 Gbits/sec</span>
<span class="c">#    [  5]   5.00-5.00   sec   384 KBytes  41.4 Gbits/sec</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate</span>
<span class="c">#    [  5]   0.00-5.00   sec  24.2 GBytes  41.6 Gbits/sec                  receiver</span>
</code></pre></div>        </div>
      </li>
      <li>UDP 사용, 역방향 모드(-R)
        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 클라이언트 파드에서 아래 명령 실행</span>
<span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> deploy/iperf3-client <span class="nt">--</span> iperf3 <span class="nt">-c</span> iperf3-server <span class="nt">-u</span> <span class="nt">-b</span> 20G
<span class="c"># =&gt; Connecting to host iperf3-server, port 5201</span>
<span class="c">#    [  5] local 10.10.2.9 port 41928 connected to 10.200.1.166 port 5201</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate         Total Datagrams</span>
<span class="c">#    [  5]   0.00-1.00   sec   161 MBytes  1.35 Gbits/sec  116453</span>
<span class="c">#    [  5]   1.00-2.00   sec   187 MBytes  1.57 Gbits/sec  135745</span>
<span class="c">#    [  5]   2.00-3.00   sec   163 MBytes  1.36 Gbits/sec  117693</span>
<span class="c">#    [  5]   3.00-4.00   sec   220 MBytes  1.84 Gbits/sec  159109</span>
<span class="c">#    [  5]   4.00-5.00   sec   168 MBytes  1.41 Gbits/sec  121705</span>
<span class="c">#    [  5]   5.00-6.00   sec   183 MBytes  1.54 Gbits/sec  132730</span>
<span class="c">#    [  5]   6.00-7.00   sec   184 MBytes  1.54 Gbits/sec  133267</span>
<span class="c">#    [  5]   7.00-8.00   sec   158 MBytes  1.32 Gbits/sec  114073</span>
<span class="c">#    [  5]   8.00-9.00   sec   171 MBytes  1.44 Gbits/sec  124005</span>
<span class="c">#    [  5]   9.00-10.00  sec   160 MBytes  1.35 Gbits/sec  116175</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span>
<span class="c">#    [  5]   0.00-10.00  sec  1.71 GBytes  1.47 Gbits/sec  0.000 ms  0/1270955 (0%)  sender</span>
<span class="c">#    [  5]   0.00-10.00  sec  1.68 GBytes  1.44 Gbits/sec  0.008 ms  28438/1270955 (2.2%)  receiver</span>
    
<span class="c"># 서버 파드 로그 확인 : 기본 5201 포트 Listen</span>
<span class="nv">$ </span>kubectl logs <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>iperf3-server <span class="nt">-f</span>
<span class="c"># =&gt; -----------------------------------------------------------</span>
<span class="c">#    Server listening on 5201 (test #3)</span>
<span class="c">#    -----------------------------------------------------------</span>
<span class="c">#    Accepted connection from 10.10.2.9, port 48546</span>
<span class="c">#    [  5] local 10.10.4.6 port 5201 connected to 10.10.2.9 port 41928</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span>
<span class="c">#    [  5]   0.00-1.00   sec   158 MBytes  1.33 Gbits/sec  0.011 ms  2000/116449 (1.7%)</span>
<span class="c">#    [  5]   1.00-2.00   sec   180 MBytes  1.51 Gbits/sec  0.009 ms  5401/135743 (4%)</span>
<span class="c">#    [  5]   2.00-3.00   sec   161 MBytes  1.35 Gbits/sec  0.011 ms  1241/117696 (1.1%)</span>
<span class="c">#    [  5]   3.00-4.00   sec   215 MBytes  1.81 Gbits/sec  0.009 ms  3132/159105 (2%)</span>
<span class="c">#    [  5]   4.00-5.00   sec   165 MBytes  1.39 Gbits/sec  0.007 ms  2073/121704 (1.7%)</span>
<span class="c">#    [  5]   5.00-6.00   sec   179 MBytes  1.51 Gbits/sec  0.008 ms  2758/132731 (2.1%)</span>
<span class="c">#    [  5]   6.00-7.00   sec   181 MBytes  1.52 Gbits/sec  0.009 ms  2397/133243 (1.8%)</span>
<span class="c">#    [  5]   7.00-8.00   sec   153 MBytes  1.28 Gbits/sec  0.007 ms  3612/114097 (3.2%)</span>
<span class="c">#    [  5]   8.00-9.00   sec   166 MBytes  1.39 Gbits/sec  0.009 ms  3707/124005 (3%)</span>
<span class="c">#    [  5]   9.00-10.00  sec   158 MBytes  1.32 Gbits/sec  0.009 ms  2117/116179 (1.8%)</span>
<span class="c">#    [  5]  10.00-10.00  sec  4.24 KBytes   656 Mbits/sec  0.008 ms  0/3 (0%)</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span>
<span class="c">#    [  5]   0.00-10.00  sec  1.68 GBytes  1.44 Gbits/sec  0.008 ms  28438/1270955 (2.2%)  receiver</span>
</code></pre></div>        </div>
      </li>
      <li>TCP, 쌍방향 모드(-R)
        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 클라이언트 파드에서 아래 명령 실행</span>
<span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> deploy/iperf3-client <span class="nt">--</span> iperf3 <span class="nt">-c</span> iperf3-server <span class="nt">-t</span> 5 <span class="nt">--bidir</span>
<span class="c"># =&gt; Connecting to host iperf3-server, port 5201</span>
<span class="c">#    [  5] local 10.10.2.9 port 59852 connected to 10.200.1.166 port 5201</span>
<span class="c">#    [  7] local 10.10.2.9 port 59860 connected to 10.200.1.166 port 5201</span>
<span class="c">#    [ ID][Role] Interval           Transfer     Bitrate         Retr  Cwnd</span>
<span class="c">#    [  5][TX-C]   0.00-1.00   sec  3.85 GBytes  33.0 Gbits/sec  2249   1.55 MBytes</span>
<span class="c">#    [  7][RX-C]   0.00-1.00   sec   553 MBytes  4.64 Gbits/sec</span>
<span class="c">#    [  5][TX-C]   1.00-2.00   sec  1.77 GBytes  15.2 Gbits/sec  3105   1.07 MBytes</span>
<span class="c">#    [  7][RX-C]   1.00-2.00   sec  2.73 GBytes  23.4 Gbits/sec</span>
<span class="c">#    [  5][TX-C]   2.00-3.00   sec  1.64 GBytes  14.1 Gbits/sec  639    850 KBytes</span>
<span class="c">#    [  7][RX-C]   2.00-3.00   sec  2.93 GBytes  25.2 Gbits/sec</span>
<span class="c">#    [  5][TX-C]   3.00-4.00   sec  2.07 GBytes  17.8 Gbits/sec    0    853 KBytes</span>
<span class="c">#    [  7][RX-C]   3.00-4.00   sec  2.48 GBytes  21.3 Gbits/sec</span>
<span class="c">#    [  5][TX-C]   4.00-5.00   sec  1.22 GBytes  10.5 Gbits/sec    2    877 KBytes</span>
<span class="c">#    [  7][RX-C]   4.00-5.00   sec  3.25 GBytes  27.9 Gbits/sec</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    [ ID][Role] Interval           Transfer     Bitrate         Retr</span>
<span class="c">#    [  5][TX-C]   0.00-5.00   sec  10.5 GBytes  18.1 Gbits/sec  5995             sender</span>
<span class="c">#    [  5][TX-C]   0.00-5.00   sec  10.5 GBytes  18.1 Gbits/sec                  receiver</span>
<span class="c">#    [  7][RX-C]   0.00-5.00   sec  11.9 GBytes  20.5 Gbits/sec  9201             sender</span>
<span class="c">#    [  7][RX-C]   0.00-5.00   sec  11.9 GBytes  20.5 Gbits/sec                  receiver</span>
    
<span class="c"># 서버 파드 로그 확인 : 기본 5201 포트 Listen</span>
<span class="nv">$ </span>kubectl logs <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>iperf3-server <span class="nt">-f</span>
<span class="c"># =&gt; -----------------------------------------------------------</span>
<span class="c">#    Server listening on 5201 (test #2)</span>
<span class="c">#    -----------------------------------------------------------</span>
<span class="c">#    Accepted connection from 10.10.2.9, port 59836</span>
<span class="c">#    [  5] local 10.10.4.6 port 5201 connected to 10.10.2.9 port 59852</span>
<span class="c">#    [  8] local 10.10.4.6 port 5201 connected to 10.10.2.9 port 59860</span>
<span class="c">#    [ ID][Role] Interval           Transfer     Bitrate         Retr  Cwnd</span>
<span class="c">#    [  5][RX-S]   0.00-1.00   sec  3.85 GBytes  33.0 Gbits/sec</span>
<span class="c">#    [  8][TX-S]   0.00-1.00   sec   561 MBytes  4.70 Gbits/sec   59   1.02 MBytes</span>
<span class="c">#    [  5][RX-S]   1.00-2.00   sec  1.77 GBytes  15.2 Gbits/sec</span>
<span class="c">#    [  8][TX-S]   1.00-2.00   sec  2.73 GBytes  23.5 Gbits/sec  2468   1.09 MBytes</span>
<span class="c">#    [  5][RX-S]   2.00-3.00   sec  1.63 GBytes  14.0 Gbits/sec</span>
<span class="c">#    [  8][TX-S]   2.00-3.00   sec  2.92 GBytes  25.1 Gbits/sec  3327   1.10 MBytes</span>
<span class="c">#    [  5][RX-S]   3.00-4.00   sec  2.08 GBytes  17.9 Gbits/sec</span>
<span class="c">#    [  8][TX-S]   3.00-4.00   sec  2.49 GBytes  21.4 Gbits/sec  2315   1.13 MBytes</span>
<span class="c">#    [  5][RX-S]   4.00-5.00   sec  1.22 GBytes  10.5 Gbits/sec</span>
<span class="c">#    [  8][TX-S]   4.00-5.00   sec  3.25 GBytes  27.9 Gbits/sec  1032   1.16 MBytes</span>
<span class="c">#    [  5][RX-S]   5.00-5.00   sec   768 KBytes  27.6 Gbits/sec</span>
<span class="c">#    [  8][TX-S]   5.00-5.00   sec  1.25 MBytes  41.3 Gbits/sec    0   1.16 MBytes</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    [ ID][Role] Interval           Transfer     Bitrate         Retr</span>
<span class="c">#    [  5][RX-S]   0.00-5.00   sec  10.5 GBytes  18.1 Gbits/sec                  receiver</span>
<span class="c">#    [  8][TX-S]   0.00-5.00   sec  11.9 GBytes  20.5 Gbits/sec  9201             sender</span>
</code></pre></div>        </div>
      </li>
      <li>TCP 다중 스트림(30개), -P(number of parallel client streams to run)
        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 클라이언트 파드에서 아래 명령 실행</span>
<span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nt">-it</span> deploy/iperf3-client <span class="nt">--</span> iperf3 <span class="nt">-c</span> iperf3-server <span class="nt">-t</span> 10 <span class="nt">-P</span> 2
<span class="c"># =&gt; [  5] local 10.10.2.9 port 41976 connected to 10.200.1.166 port 5201</span>
<span class="c">#    [  7] local 10.10.2.9 port 41982 connected to 10.200.1.166 port 5201</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate         Retr  Cwnd</span>
<span class="c">#    [  5]   0.00-1.00   sec  2.87 GBytes  24.7 Gbits/sec  822    570 KBytes</span>
<span class="c">#    [  7]   0.00-1.00   sec  2.88 GBytes  24.7 Gbits/sec  159    576 KBytes</span>
<span class="c">#    [SUM]   0.00-1.00   sec  5.75 GBytes  49.4 Gbits/sec  981</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    ...</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate         Retr</span>
<span class="c">#    [  5]   0.00-10.00  sec  29.2 GBytes  25.1 Gbits/sec  3825             sender</span>
<span class="c">#    [  5]   0.00-10.00  sec  29.2 GBytes  25.1 Gbits/sec                  receiver</span>
<span class="c">#    [  7]   0.00-10.00  sec  29.2 GBytes  25.1 Gbits/sec  2063             sender</span>
<span class="c">#    [  7]   0.00-10.00  sec  29.2 GBytes  25.0 Gbits/sec                  receiver</span>
<span class="c">#    [SUM]   0.00-10.00  sec  58.3 GBytes  50.1 Gbits/sec  5888             sender</span>
<span class="c">#    [SUM]   0.00-10.00  sec  58.3 GBytes  50.1 Gbits/sec                  receiver</span>
    
<span class="c"># 서버 파드 로그 확인 : 기본 5201 포트 Listen</span>
<span class="nv">$ </span>kubectl logs <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>iperf3-server <span class="nt">-f</span>
<span class="c"># =&gt; -----------------------------------------------------------</span>
<span class="c">#    Server listening on 5201 (test #4)</span>
<span class="c">#    -----------------------------------------------------------</span>
<span class="c">#    Accepted connection from 10.10.2.9, port 41962</span>
<span class="c">#    [  5] local 10.10.4.6 port 5201 connected to 10.10.2.9 port 41976</span>
<span class="c">#    [  8] local 10.10.4.6 port 5201 connected to 10.10.2.9 port 41982</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate</span>
<span class="c">#    [  5]   0.00-1.00   sec  2.87 GBytes  24.6 Gbits/sec</span>
<span class="c">#    [  8]   0.00-1.00   sec  2.87 GBytes  24.7 Gbits/sec</span>
<span class="c">#    [SUM]   0.00-1.00   sec  5.74 GBytes  49.3 Gbits/sec</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    ...</span>
<span class="c">#    - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="c">#    [ ID] Interval           Transfer     Bitrate</span>
<span class="c">#    [  5]   0.00-10.00  sec  29.2 GBytes  25.1 Gbits/sec                  receiver</span>
<span class="c">#    [  8]   0.00-10.00  sec  29.2 GBytes  25.0 Gbits/sec                  receiver</span>
<span class="c">#    [SUM]   0.00-10.00  sec  58.3 GBytes  50.1 Gbits/sec                  receiver</span>
</code></pre></div>        </div>
      </li>
      <li>실습결과 <code class="language-plaintext highlighter-rouge">iperf3 -c 127.0.0.1 -t 5</code>로 측정하였을때는 호스트에서는 67.1 Gbits/sec 였던것에 반해, 쿠버네티스를 통하면 41.6 Gbits/sec로 측정됩니다.
        <ul>
          <li>쿠버네티스도 로컬호스트에서 docker로 실행되는데 kube-proxy, iptables 포워딩 등의 오버헤드로 인해 발생하는것 같습니다.</li>
        </ul>
      </li>
      <li>UDP의 경우에도 <code class="language-plaintext highlighter-rouge">iperf3 -c 127.0.0.1 -u -b 20G</code>로 측정했을때 호스트에서는 20.0 Gbits/sec가 나오는데, 쿠버네티스를 통하면 1.41 Gbits/sec로 측정됩니다.
        <ul>
          <li>UDP는 더 오버헤드가 심한데 원인을 찾아봐야 할것 같습니다.</li>
        </ul>
      </li>
      <li>이번 실습을 통해 다양한 네트워크 CNI, 설정등을 변경해가며 최적의 설정을 찾아보는 방법을 배워보았습니다.</li>
    </ul>
  </li>
</ul>

<hr>

<h2 id="마치며">마치며</h2>

<p>실습을 할수록 점점 더 iptables과 친숙해지는것 같습니다.
눈에 익은게 많아지고는 있지만, nftables라던지 ipvs라던지, eBPF라던지 아직 갈길이 멉니다. 😅</p>

<p>새삼스레 스터디를 진행하시는 가시다님을 비롯해서 조력자 분들도 정말 대단하다는 생각이 듭니다.
그리고 내용들 및 그림들이 가시다님이 집필하신 책에서 많이 가져왔습니다.
책이 출판되면 꼭 구매해서 읽어보겠습니다! 
이제 스터디도 중반을 향해 달려가고 있습니다. 남은 날들도 스터디에서 생존할 수 있기를 바랍니다. <img class="emoji" title=":pray:" alt=":pray:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png" height="20" width="20" loading="lazy"></p>

  </div>

  <div id="toc-minimap" class="toc-minimap collapsed">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0">들어가며</a></li>
<li class="toc-entry toc-h2">
<a href="#k8s-service">K8S Service</a>
<ul>
<li class="toc-entry toc-h3"><a href="#service%EC%9D%98-%ED%83%84%EC%83%9D-%EB%B0%B0%EA%B2%BD">Service의 탄생 배경</a></li>
<li class="toc-entry toc-h3">
<a href="#k8s-service-%EC%A2%85%EB%A5%98">K8S Service 종류</a>
<ul>
<li class="toc-entry toc-h4"><a href="#clusterip">ClusterIP</a></li>
<li class="toc-entry toc-h4"><a href="#nodeport">NodePort</a></li>
<li class="toc-entry toc-h4"><a href="#loadbalancer">LoadBalancer</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EA%B5%AC%EC%A1%B0">서비스의 구조</a></li>
<li class="toc-entry toc-h3">
<a href="#kube-proxy-%EB%AA%A8%EB%93%9C">kube-proxy 모드</a>
<ul>
<li class="toc-entry toc-h4"><a href="#userspace-proxy-%EB%AA%A8%EB%93%9C">userspace proxy 모드</a></li>
<li class="toc-entry toc-h4"><a href="#iptables-proxy-%EB%AA%A8%EB%93%9C">iptables proxy 모드</a></li>
<li class="toc-entry toc-h4"><a href="#ipvs-proxy-%EB%AA%A8%EB%93%9C">ipvs proxy 모드</a></li>
<li class="toc-entry toc-h4"><a href="#nftables-proxy-%EB%AA%A8%EB%93%9C">nftables proxy 모드</a></li>
<li class="toc-entry toc-h4"><a href="#ebpf-%EB%AA%A8%EB%93%9C--xdp">eBPF 모드 + XDP</a></li>
</ul>
</li>
<li class="toc-entry toc-h3">
<a href="#%EC%8B%A4%EC%8A%B5">실습</a>
<ul>
<li class="toc-entry toc-h4"><a href="#%EC%8B%A4%EC%8A%B5%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95">실습환경 구축</a></li>
<li class="toc-entry toc-h4"><a href="#clusterip-%EC%8B%A4%EC%8A%B5">ClusterIP 실습</a></li>
<li class="toc-entry toc-h4"><a href="#nodeport-%EC%8B%A4%EC%8A%B5">NodePort 실습</a></li>
<li class="toc-entry toc-h4"><a href="#%ED%8C%8C%EB%93%9C%EA%B0%84-%EC%86%8D%EB%8F%84-%EC%B8%A1%EC%A0%95">파드간 속도 측정</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
</ul>
  </div>
<a class="u-url" href="/posts/2024-09-27-KANS-Study-Week4/" hidden></a>
</article>



<div class="PageNavigation">
  
  <a class="prev" href="/posts/2024-09-22-KANS-Study-Week3/">« [KANS 3기] K8S Calico CNI</a>
  
  
</div>

<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = "https://sweetlittlebird.github.io/posts/2024-09-27-KANS-Study-Week4/";
this.page.identifier = "/posts/KANS Study - Week4";
};
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Sweet Little Bird</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Sweet Little Bird</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/sweetlittlebird"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">sweetlittlebird</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>공부 기록과 개발 이야기를 담은 블로그입니다.</p>
      </div>
    </div>

  </div>

</footer>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
      <!-- Background of PhotoSwipe. 
           It's a separate element as animating opacity is faster than rgba(). -->
      <div class="pswp__bg"></div>
      <!-- Slides wrapper with overflow:hidden. -->
      <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
          <div class="pswp__item"></div>
          <div class="pswp__item"></div>
          <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
          <div class="pswp__top-bar">
            <!--  Controls are self-explanatory. Order can be changed. -->
            <div class="pswp__counter"></div>
            <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
            <button class="pswp__button pswp__button--share" title="Share"></button>
            <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
            <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
            <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
            <!-- element will get class pswp__preloader--active when preloader is running -->
            <div class="pswp__preloader">
              <div class="pswp__preloader__icn">
                <div class="pswp__preloader__cut">
                  <div class="pswp__preloader__donut"></div>
                </div>
              </div>
            </div>
          </div>
          <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
            <div class="pswp__share-tooltip"></div>
          </div>
          <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
          </button>
          <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
          </button>
          <div class="pswp__caption">
            <div class="pswp__caption__center"></div>
          </div>
        </div>
      </div>
    </div>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-EWGY9N8QXY"></script>

    
    <script async src="/assets/dist/app.min.js"></script>
    
  
    <a href="#" id="back-to-top"><span>Back to Top</span></a>
  </body>

</html>
