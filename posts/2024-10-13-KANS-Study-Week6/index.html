<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[KANS 3기] Ingress &amp; Gateway API | Sweet Little Bird</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="[KANS 3기] Ingress &amp; Gateway API">
<meta property="og:locale" content="ko">
<meta name="description" content="이번주에는 ingress와 gateway api 에대해 알아 보겠습니다.">
<meta property="og:description" content="이번주에는 ingress와 gateway api 에대해 알아 보겠습니다.">
<link rel="canonical" href="https://sweetlittlebird.github.io/posts/2024-10-13-KANS-Study-Week6/">
<meta property="og:url" content="https://sweetlittlebird.github.io/posts/2024-10-13-KANS-Study-Week6/">
<meta property="og:site_name" content="Sweet Little Bird">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-10-13T01:00:18+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="[KANS 3기] Ingress &amp; Gateway API">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-10-13T01:00:18+09:00","datePublished":"2024-10-13T01:00:18+09:00","description":"이번주에는 ingress와 gateway api 에대해 알아 보겠습니다.","headline":"[KANS 3기] Ingress &amp; Gateway API","mainEntityOfPage":{"@type":"WebPage","@id":"https://sweetlittlebird.github.io/posts/2024-10-13-KANS-Study-Week6/"},"url":"https://sweetlittlebird.github.io/posts/2024-10-13-KANS-Study-Week6/"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/dist/photoswipe.min.css">
  <link rel="stylesheet" href="/assets/dist/main.min.css">
  <link rel="stylesheet" href="/assets/dist/main_dark.min.css" media="(prefers-color-scheme: dark)">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pretendard/1.3.9/static/pretendard.css" integrity="sha512-NzqTHTrO48HsIamogmIaVhTXoSgRF24Cn+ynrNYrFuKrY0AdDbmcNieiOHsQARS/r0Gax9VwV3/rVMHs3ipUlg==" crossorigin="anonymous" referrerpolicy="no-referrer">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!--  <link href="https://fonts.googleapis.com/css2?family=Elsie+Swash+Caps:wght@400;900&display=swap" rel="stylesheet">-->
  <link href="https://fonts.googleapis.com/css2?family=Elsie+Swash+Caps:wght@400;900&amp;family=Milonga&amp;display=swap" rel="stylesheet">

  <link rel="shortcut icon" href="/assets/favicon/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/favicon/favicon.ico" type="image/x-icon">
<link type="application/atom+xml" rel="alternate" href="https://sweetlittlebird.github.io/feed.xml" title="Sweet Little Bird">
</head>
<body class="body--contents">
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/">Sweet Little Bird</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
<a class="page-link" href="/about/">소개</a><a class="page-link" href="/posts/">글 목록</a>
</div>
      </nav>
</div>
  
  <span id="scroll-indicator"></span>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">[KANS 3기] Ingress &amp; Gateway API</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-10-13T01:00:18+09:00" itemprop="datePublished">2024년 10월 13일에 작성
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div class="table-of-content">
      <header>목차</header>
      <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0">들어가며</a></li>
<li class="toc-entry toc-h2">
<a href="#ingress">Ingress</a>
<ul>
<li class="toc-entry toc-h3"><a href="#ingress%EB%9E%80">Ingress란?</a></li>
<li class="toc-entry toc-h3"><a href="#ingress-controller%EC%9D%98-%EC%A2%85%EB%A5%98">Ingress Controller의 종류</a></li>
<li class="toc-entry toc-h3">
<a href="#%EC%8B%A4%EC%8A%B5-%ED%99%98%EA%B2%BD-%EC%A4%80%EB%B9%84">실습 환경 준비</a>
<ul>
<li class="toc-entry toc-h4"><a href="#k3s-%ED%8A%B9%EC%A7%95">k3s 특징</a></li>
<li class="toc-entry toc-h4"><a href="#k3s%EC%9D%98-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90">k3s의 아키텍쳐</a></li>
<li class="toc-entry toc-h4"><a href="#k3s-%EC%84%A4%EC%B9%98">k3s 설치</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#nginx-ingress-controller-%EC%84%A4%EC%B9%98">Nginx Ingress Controller 설치</a></li>
<li class="toc-entry toc-h3">
<a href="#%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4ingress-%EC%8B%A4%EC%8A%B5-%EB%B0%8F-%ED%86%B5%EC%8B%A0-%ED%9D%90%EB%A6%84-%ED%99%95%EC%9D%B8">인그레스(Ingress) 실습 및 통신 흐름 확인</a>
<ul>
<li class="toc-entry toc-h4"><a href="#deployment%EC%99%80-service-%EC%83%9D%EC%84%B1">deployment와 service 생성</a></li>
<li class="toc-entry toc-h4"><a href="#%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4%EC%A0%95%EC%B1%85-%EC%83%9D%EC%84%B1">인그레스(정책) 생성</a></li>
<li class="toc-entry toc-h4"><a href="#ingress%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%82%B4%EB%B6%80-%EC%A0%91%EC%86%8D">ingress를 통한 내부 접속</a></li>
<li class="toc-entry toc-h4"><a href="#%ED%8C%A8%ED%82%B7-%EB%B6%84%EC%84%9D">패킷 분석</a></li>
<li class="toc-entry toc-h4"><a href="#nginx-%EB%B6%84%EC%82%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B3%80%EA%B2%BD">Nginx 분산 알고리즘 변경</a></li>
<li class="toc-entry toc-h4"><a href="#host-%EA%B8%B0%EB%B0%98-%EB%9D%BC%EC%9A%B0%ED%8C%85">Host 기반 라우팅</a></li>
<li class="toc-entry toc-h4"><a href="#%EC%B9%B4%EB%82%98%EB%A6%AC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8">카나리 업데이트</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#gateway-api">Gateway API</a>
<ul>
<li class="toc-entry toc-h3"><a href="#gateway-api-%EC%86%8C%EA%B0%9C">Gateway API 소개</a></li>
<li class="toc-entry toc-h3">
<a href="#gloo-gateway">Gloo Gateway</a>
<ul>
<li class="toc-entry toc-h4"><a href="#gloo-gateway-architecture">Gloo Gateway Architecture</a></li>
<li class="toc-entry toc-h4"><a href="#%EC%8B%A4%EC%8A%B5">실습</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#%EA%B8%B0%ED%83%80-gateway-api-%EA%B5%AC%ED%98%84%EC%B2%B4">기타 Gateway API 구현체</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
</ul>
    </div>
    <h2 id="들어가며">들어가며</h2>

<p>이번주에는 ingress와 gateway api 에대해 알아 보겠습니다.
KANS 3기 6주차 스터디를 시작하겠습니다.</p>

<hr>

<h2 id="ingress">Ingress</h2>

<h3 id="ingress란">Ingress란?</h3>

<ul>
  <li>Ingress는 클러스터 외부에서 클러스터 내부로 HTTP 및 HTTPS 트래픽을 라우팅하는 Web Proxy 역할을 수행합니다.</li>
  <li>지난주에 스터디했던 LoadBalancer와 비슷한 역할을 수행하지만, LoadBalancer는 Layer 4에서 동작하는 반면 Ingress는 Layer 7에서 동작한다는 차이가 있습니다.</li>
  <li>Ingress는 HTTP와 HTTPS를 이해하기 때문에 호스트명, 경로 등에 따라 트래픽을 라우팅할 수도 있고, SSL Offloading 등의 기능도 제공합니다.</li>
  <li>이렇게 다양한 기능이 있지만 <strong>Ingress는 동결처리</strong> 되었으며, <strong>신규 기능들은 Gateway API라는 다른 API에 추가되고 있고</strong>, 향후에는 Ingress 대신 Gateway API를 사용하는 것이 권장될것으로 보입니다.</li>
</ul>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_1.png" alt="img.png" class="image-center" loading="lazy" width="1524" height="278"></p>

<ul>
  <li>특이한 점은 Ingress 를 통한 트래픽은 서비스를 통하지 않고, 서비스를 통해서 파드의 IP를 확인하고, 위의 그림과 같이 서비스를 거치지 않고 파드와 직접 통신합니다.</li>
</ul>

<h3 id="ingress-controller의-종류">Ingress Controller의 종류</h3>

<ul>
  <li>Ingress는 Kubernetes에 내장된 기능이 아니어서 별도의 Ingress Controller를 설치해야만 사용할 수 있습니다. 
많이 사용되는 Ingress Controller는 다음과 같습니다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>특징</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Pomerium</td>
      <td>보안에 특화 된 Ingress로 Identity-Aware 접근이 가능하며 Zero Trust 모델을 지원합니다.</td>
    </tr>
    <tr>
      <td>NGINX Ingress Controller</td>
      <td>신뢰할 수 있는 안정적으로, 라우팅이 유연하고, Lua 스크립트 등으로 기능확장이 가능합니다.</td>
    </tr>
    <tr>
      <td>Traefik</td>
      <td>Auto-discovery를 제공하고, 실시간으로 업데이트 되며, 관리 대시보드를 제공합니다. 동적으로 운영하기 좋습니다.</td>
    </tr>
    <tr>
      <td>HAProxy Ingress</td>
      <td>고성능이며, 다양한 고급 기능을 제공합니다.</td>
    </tr>
    <tr>
      <td>Envoy</td>
      <td>확장성이 있으며 재시도, 서킷 브레이커, 레이트 제한 등 다양한 기능을 제공합니다.</td>
    </tr>
    <tr>
      <td>Istio Ingress Gateway</td>
      <td>트래픽 관리에 강점이 있으며, Istio 서비스 메시와 연동하기 좋습니다.</td>
    </tr>
    <tr>
      <td>Contour</td>
      <td>HTTP/2와 gRPC를 지원하는 경량의 고성능을 제공합니다.</td>
    </tr>
    <tr>
      <td>Kong Ingress Controller</td>
      <td>Kong은 API Gateway로 널리 알려져있지만 Ingress Controller 기능도 제공합니다. NGINX Ingress Controller의 기능에 추가적인 기능을 제공하지만 학습 곡선이 높은 편입니다.</td>
    </tr>
  </tbody>
</table>

<p>이외에도 다양한 Ingress Controller가 존재하며 다음의 링크에서 확인 할 수 있습니다. <a href="https://docs.google.com/spreadsheets/d/191WWNpjJ2za6-nbG4ZoUMXMpUK8KlCIosvQB0f-oq3k/">Kubernetes Ingress Controllers 비교</a></p>

<h3 id="실습-환경-준비">실습 환경 준비</h3>

<ul>
  <li>이번 실습에는 k3s라는 경량 Kubernetes 클러스터를 사용하겠습니다. k3s는 Rancher에서 개발한 경량 Kubernetes 클러스터로, 쉽게 설치가 가능하고, 
전체가 100MB보다 적을 정도로 적은 자원으로도 Kubernetes를 사용할 수 있습니다.</li>
  <li>하지만 K8S와는 기능 차이가 있기 때문에, 이러한 부분을 감안하고 사용하시면 됩니다.</li>
</ul>

<h4 id="k3s-특징">k3s 특징</h4>

<ul>
  <li>k3s의 특징은 다음과 같습니다
    <ul>
      <li>단일 바이너리 또는 최소 컨테이너 이미지로 배포됩니다.</li>
      <li>기본 저장소 백엔드로 sqlite3를 기반으로 한 경량 데이터 저장소가 사용됩니다. etcd, MySQL 및 Postgres도 사용할 수 있습니다.</li>
      <li>TLS 및 옵션의 복잡성을 처리하는 런처에 포함되어 있습니다.</li>
      <li>경량 환경에 적합한 합리적인 기본값으로 보안에 신경을 썼습니다.</li>
      <li>모든 Kubernetes 컨트롤 플레인 구성 요소의 작동이 단일 바이너리 및 프로세스에 캡슐화되어 있고, k3s가 인증서 배포와 같은 복잡한 클러스터 작업을 자동화합니다.</li>
      <li>외부 종속성이 최소화되었습니다. 필요한 것은 최신 커널과 cgroup 마운트뿐입니다.</li>
      <li>손쉬운 클러스터 생성을 위해 필요한 패키지를 기본 제공합니다:
        <ul>
          <li>containerd / cri-dockerd 컨테이너 런타임 (CRI)</li>
          <li>Flannel 컨테이너 네트워크 인터페이스 (CNI)</li>
          <li>CoreDNS 클러스터 DNS</li>
          <li>Traefik Ingress 컨트롤러</li>
          <li>ServiceLB 로드 밸런서 컨트롤러</li>
          <li>Kube-router 네트워크 정책 컨트롤러</li>
          <li>Local-path-provisioner 영구 볼륨 컨트롤러</li>
          <li>Spegel 분산 컨테이너 이미지 레지스트리 미러</li>
          <li>호스트 유틸리티 (iptables, socat 등)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="k3s의-아키텍쳐">k3s의 아키텍쳐</h4>

<ul>
  <li>k3s는 서버 (Control Plane)와 에이전트 (Worker Node)로 구성되어 있습니다.
    <ul>
      <li>서버 노드는 Kubernetes의 <code class="language-plaintext highlighter-rouge">k3s server</code> 명령으로 실행되며 모든 컨트롤 플레인 구성 요소와 데이터 저장 컴포넌트를 실행하며 k3s가 관리합니다.</li>
      <li>에이전트 노드는 <code class="language-plaintext highlighter-rouge">k3s agent</code> 명령으로 실행되며 컨트롤 플레인 요소등 없이 워커 노드로 동작합니다.</li>
      <li>모든 서버와 에이전트는 kublet, 컨테이너 런타임, CNI 등을 포함한 모든 Kubernetes 구성 요소를 실행합니다.</li>
      <li>더 자세한 내용은 다음 링크를 참고하세요. <a href="https://docs.k3s.io/advanced#running-agentless-servers-experimental">링크</a>
<img src="/assets/2024/kans-3th/w6/20241012_kans_w6_2.svg" alt="20241012_kans_w6_2.svg" loading="lazy" width="1561" height="898">
</li>
    </ul>
  </li>
  <li>단일 서버 구성 : 1대 K3S 서버(경량 DB = SQLite), 필요한 만큼의 K3S Agents (Worker Node) 구성
<img src="/assets/2024/kans-3th/w6/20241012_kans_w6_3.png" alt="img.png" loading="lazy" width="2048" height="1185">
</li>
  <li>고가용성 구성 : Embedded DB (etcd 등), 외부 DB (MySQL, PostgreSQL 등) 사용 가능
<img src="/assets/2024/kans-3th/w6/20241012_kans_w6_4.png" alt="img_1.png" loading="lazy" width="9008" height="4244">
</li>
</ul>

<h4 id="k3s-설치">k3s 설치</h4>

<ul>
  <li>k3s는 기본적으로 <code class="language-plaintext highlighter-rouge">traefik</code>을 Ingress Controller로 사용하는데 이번 실습에서는 nginx ingress controller를 사용할 것이기 때문에 <code class="language-plaintext highlighter-rouge">traefik</code>을 설치하지 않겠습니다.</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">INSTALL_K3S_EXEC=" --disable=traefik"</code> 옵션을 사용하여 traefik을 설치하지 않을 수 있습니다.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># Install k3s-server</span>
<span class="nv">$ </span>curl <span class="nt">-sfL</span> https://get.k3s.io | <span class="nv">INSTALL_K3S_EXEC</span><span class="o">=</span><span class="s2">" --disable=traefik"</span>  sh <span class="nt">-s</span> - server <span class="nt">--token</span> <span class="o">[[</span>인증토큰]] <span class="nt">--cluster-cidr</span> <span class="s2">"172.16.0.0/16"</span> <span class="nt">--service-cidr</span> <span class="s2">"10.10.200.0/24"</span> <span class="nt">--write-kubeconfig-mode</span> 644 
  
<span class="c"># Install k3s-agent</span>
<span class="nv">$ </span>curl <span class="nt">-sfL</span> https://get.k3s.io | <span class="nv">K3S_URL</span><span class="o">=</span>https://192.168.10.10:6443 <span class="nv">K3S_TOKEN</span><span class="o">=[[</span>인증토큰]]  sh <span class="nt">-s</span> -
</code></pre></div>    </div>
  </li>
  <li>k3s 설치 후, k3의 설정을 확인해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 노드 확인</span>
<span class="nv">$ </span>kubectl get node <span class="nt">-owide</span>
<span class="c"># =&gt; NAME     STATUS   ROLES                  AGE     VERSION        INTERNAL-IP   EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION       CONTAINER-RUNTIME</span>
<span class="c">#    k3s-m    Ready    control-plane,master   30m     v1.30.5+k3s1   10.0.2.15     &amp;lt;none&amp;gt;        Ubuntu 22.04.5 LTS   5.15.0-119-generic   containerd://1.7.21-k3s2</span>
<span class="c">#    k3s-w1   Ready    &amp;lt;none&amp;gt;                 4m24s   v1.30.5+k3s1   10.0.2.15     &amp;lt;none&amp;gt;        Ubuntu 22.04.5 LTS   5.15.0-119-generic   containerd://1.7.21-k3s2</span>
<span class="c">#    k3s-w2   Ready    &amp;lt;none&amp;gt;                 26m     v1.30.5+k3s1   10.0.2.15     &amp;lt;none&amp;gt;        Ubuntu 22.04.5 LTS   5.15.0-119-generic   containerd://1.7.21-k3s2</span>
<span class="c">#    k3s-w3   Ready    &amp;lt;none&amp;gt;                 24m     v1.30.5+k3s1   10.0.2.15     &amp;lt;none&amp;gt;        Ubuntu 22.04.5 LTS   5.15.0-119-generic   containerd://1.7.21-k3s2</span>

<span class="nv">$ </span>kubectl describe node k3s-m | <span class="nb">grep </span>Taint  <span class="c"># Taints 없음</span>
<span class="c"># =&gt; Taints:             &amp;lt;none&amp;gt;</span>
<span class="nv">$ </span>kubectl describe node k3s-w1 | <span class="nb">grep </span>Taint  <span class="c"># Taints 없음</span>
<span class="c"># =&gt; Taints:             &amp;lt;none&amp;gt;</span>

<span class="c"># 파드 확인</span>
<span class="nv">$ </span>kubectl get pod <span class="nt">-n</span> kube-system
<span class="c"># =&gt; NAME                                      READY   STATUS    RESTARTS   AGE</span>
<span class="c">#    coredns-7b98449c4-8l64d                   1/1     Running   0          31m</span>
<span class="c">#    local-path-provisioner-6795b5f9d8-b5gt6   1/1     Running   0          31m</span>
<span class="c">#    metrics-server-cdcc87586-d87gv            1/1     Running   0          31m</span>

<span class="c">#</span>
<span class="nv">$ </span>kubectl top node
<span class="c"># =&gt; NAME     CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%</span>
<span class="c">#    k3s-m    147m         3%     1128Mi          28%</span>
<span class="c">#    k3s-w1   147m         3%     1128Mi          57%</span>
<span class="c">#    k3s-w2   147m         3%     1128Mi          57%</span>
<span class="c">#    k3s-w3   147m         3%     1128Mi          57%</span>
<span class="nv">$ </span>kubectl top pod <span class="nt">-A</span> <span class="nt">--sort-by</span><span class="o">=</span><span class="s1">'cpu'</span>
<span class="c"># =&gt; NAMESPACE     NAME                                      CPU(cores)   MEMORY(bytes)</span>
<span class="c">#    kube-system   metrics-server-cdcc87586-d87gv            15m          19Mi</span>
<span class="c">#    kube-system   coredns-7b98449c4-8l64d                   4m           13Mi</span>
<span class="c">#    kube-system   local-path-provisioner-6795b5f9d8-b5gt6   1m           6Mi</span>
<span class="nv">$ </span>kubectl top pod <span class="nt">-A</span> <span class="nt">--sort-by</span><span class="o">=</span><span class="s1">'memory'</span>
<span class="nv">$ </span>kubectl get storageclass
<span class="c"># =&gt; NAME                   PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE</span>
<span class="c">#    local-path (default)   rancher.io/local-path   Delete          WaitForFirstConsumer   false                  32m</span>

<span class="c"># config 정보(위치) 확인</span>
<span class="nv">$ </span>kubectl get pod <span class="nt">-v</span><span class="o">=</span>6
<span class="c"># =&gt; I1012 05:55:56.507623    6817 loader.go:395] Config loaded from file:  /etc/rancher/k3s/k3s.yaml</span>
<span class="c">#    I1012 05:55:56.518338    6817 round_trippers.go:553] GET https://127.0.0.1:6443/api/v1/namespaces/default/pods?limit=500 200 OK in 5 milliseconds</span>
<span class="c">#    No resources found in default namespace.</span>

<span class="nv">$ </span><span class="nb">cat</span> /etc/rancher/k3s/k3s.yaml
<span class="c"># =&gt; apiVersion: v1</span>
<span class="c">#    clusters:</span>
<span class="c">#    - cluster:</span>
<span class="c">#        certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUJlRENDQVIyZ0F3SUJBZ0lCQURBS0JnZ3Foa2pPUFFRREFqQWpNU0V3SHdZRFZRUUREQmhyTTNNdGMyVnkKZG1WeUxXTmhRREUzTWpnM01UQTJNREF3SGhjTk1qUXhNREV5TURVeU16SXdXaGNOTXpReE1ERXdNRFV5TXpJdwpXakFqTVNFd0h3WURWUVFEREJock0zTXRjMlZ5ZG1WeUxXTmhRREUzTWpnM01UQTJNREF3V1RBVEJnY3Foa2pPClBRSUJCZ2dxaGtqT1BRTUJCd05DQUFReEdLOFFEcHMvNmNHdE45RWRCYmZJRmg2UjBpQlFLYUhHYWhVQXVMdjUKWHhpd1JjTVdia1FZNmxBdWM1RC9zWWYrTmhZYUFjcmNzMk01LzAyTkQ5bERvMEl3UURBT0JnTlZIUThCQWY4RQpCQU1DQXFRd0R3WURWUjBUQVFIL0JBVXdBd0VCL3pBZEJnTlZIUTRFRmdRVXJzL1ZVODFCZEJnS3N2YmJDRmhjCkJ5aStxUTB3Q2dZSUtvWkl6ajBFQXdJRFNRQXdSZ0loQUxwWXpzZkVMdjZScG56OGdqcDZXYkZuUFk2S3FrQ2gKTWYwRWZvMnRzM2d5QWlFQXhkaDM4akJCMWJrTWlwWDNSMTFyTnBtZmc2S2huZzliNUJDTUs0M3UyTjA9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K</span>
<span class="c">#        server: https://127.0.0.1:6443</span>
<span class="c">#      name: default</span>
<span class="c">#    ...</span>
<span class="nv">$ </span><span class="nb">export</span> | <span class="nb">grep </span>KUBECONFIG
<span class="c"># =&gt; (공백)</span>

<span class="c"># 네트워크 정보 확인 : flannel CNI(vxlan mode), podCIDR</span>
<span class="nv">$ </span>ip <span class="nt">-c</span> addr
<span class="c"># =&gt; ...</span>
<span class="c">#    4: flannel.1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue state UNKNOWN group default</span>
<span class="c">#        link/ether 02:21:77:da:a3:91 brd ff:ff:ff:ff:ff:ff</span>
<span class="c">#        inet 172.16.0.0/32 scope global flannel.1</span>
<span class="c">#           valid_lft forever preferred_lft forever</span>
<span class="c">#    5: cni0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue state UP group default qlen 1000</span>
<span class="c">#        link/ether ca:30:a0:c8:5c:cd brd ff:ff:ff:ff:ff:ff</span>
<span class="c">#        inet 172.16.0.1/24 brd 172.16.0.255 scope global cni0</span>
<span class="c">#           valid_lft forever preferred_lft forever</span>
<span class="c">#    6: veth41d9e3b2@if2: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue master cni0 state UP group default</span>
<span class="c">#        link/ether fa:47:5c:4a:8d:af brd ff:ff:ff:ff:ff:ff link-netns cni-9c26655e-b22f-97a1-f97c-db88daccc77f</span>
<span class="c">#    7: veth5c3de18a@if2: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue master cni0 state UP group default</span>
<span class="c">#        link/ether 6a:5e:39:72:4f:4c brd ff:ff:ff:ff:ff:ff link-netns cni-cff25bf8-d23b-790a-91d0-ed5c4ee526d5</span>
<span class="c">#    8: vethfaeebb1c@if2: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue master cni0 state UP group default</span>
<span class="c">#        link/ether c6:f5:31:a1:56:21 brd ff:ff:ff:ff:ff:ff link-netns cni-06a3672f-70dc-7445-48c9-8cf8c26e7fb3</span>
<span class="nv">$ </span>ip <span class="nt">-c</span> route
<span class="c"># =&gt; default via 10.0.2.2 dev enp0s3 proto dhcp src 10.0.2.15 metric 100</span>
<span class="c">#    ...</span>
<span class="c">#    172.16.0.0/24 dev cni0 proto kernel scope link src 172.16.0.1</span>
<span class="c">#    172.16.1.0/24 via 172.16.1.0 dev flannel.1 onlink</span>
<span class="c">#    172.16.2.0/24 via 172.16.2.0 dev flannel.1 onlink</span>
<span class="c">#    172.16.3.0/24 via 172.16.3.0 dev flannel.1 onlink</span>
<span class="c">#    192.168.10.0/24 dev enp0s8 proto kernel scope link src 192.168.10.10</span>
<span class="nv">$ </span><span class="nb">cat</span> /run/flannel/subnet.env
<span class="c"># =&gt; FLANNEL_NETWORK=172.16.0.0/16</span>
<span class="c">#    FLANNEL_SUBNET=172.16.0.1/24</span>
<span class="c">#    FLANNEL_MTU=1450</span>
<span class="c">#    FLANNEL_IPMASQ=true</span>
<span class="nv">$ </span>kubectl get nodes <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.items[*].spec.podCIDR}'</span> <span class="p">;</span><span class="nb">echo</span>
<span class="c"># =&gt; 172.16.0.0/24 172.16.3.0/24 172.16.1.0/24 172.16.2.0/24</span>
<span class="nv">$ </span>kubectl describe node | <span class="nb">grep</span> <span class="nt">-A3</span> Annotations
<span class="c"># =&gt; Annotations:        alpha.kubernetes.io/provided-node-ip: 10.0.2.15</span>
<span class="c">#                        flannel.alpha.coreos.com/backend-data: {&amp;quot;VNI&amp;quot;:1,&amp;quot;VtepMAC&amp;quot;:&amp;quot;02:21:77:da:a3:91&amp;quot;}</span>
<span class="c">#                        flannel.alpha.coreos.com/backend-type: vxlan</span>
<span class="c">#                        flannel.alpha.coreos.com/kube-subnet-manager: true</span>
<span class="c">#    --</span>
<span class="c">#    Annotations:        alpha.kubernetes.io/provided-node-ip: 10.0.2.15</span>
<span class="c">#                        flannel.alpha.coreos.com/backend-data: {&amp;quot;VNI&amp;quot;:1,&amp;quot;VtepMAC&amp;quot;:&amp;quot;72:95:9e:3d:c6:35&amp;quot;}</span>
<span class="c">#                        flannel.alpha.coreos.com/backend-type: vxlan</span>
<span class="c">#                        flannel.alpha.coreos.com/kube-subnet-manager: true</span>
<span class="c">#    --</span>
<span class="c">#    Annotations:        alpha.kubernetes.io/provided-node-ip: 10.0.2.15</span>
<span class="c">#                        flannel.alpha.coreos.com/backend-data: {&amp;quot;VNI&amp;quot;:1,&amp;quot;VtepMAC&amp;quot;:&amp;quot;ae:28:43:65:df:f4&amp;quot;}</span>
<span class="c">#                        flannel.alpha.coreos.com/backend-type: vxlan</span>
<span class="c">#                        flannel.alpha.coreos.com/kube-subnet-manager: true</span>
<span class="c">#    --</span>
<span class="c">#    Annotations:        alpha.kubernetes.io/provided-node-ip: 10.0.2.15</span>
<span class="c">#                        flannel.alpha.coreos.com/backend-data: {&amp;quot;VNI&amp;quot;:1,&amp;quot;VtepMAC&amp;quot;:&amp;quot;8e:91:37:7d:c1:d7&amp;quot;}</span>
<span class="c">#                        flannel.alpha.coreos.com/backend-type: vxlan</span>
<span class="c">#                        flannel.alpha.coreos.com/kube-subnet-manager: true</span>
<span class="nv">$ </span>brctl show
<span class="c"># =&gt; bridge name     bridge id               STP enabled     interfaces</span>
<span class="c">#    cni0            8000.ca30a0c85ccd       no              veth41d9e3b2</span>
<span class="c">#                                                            veth5c3de18a</span>
<span class="c">#                                                            vethfaeebb1c</span>

<span class="c"># 서비스와 엔드포인트 확인</span>
<span class="nv">$ </span>kubectl get svc,ep <span class="nt">-A</span>
<span class="c"># =&gt; NAMESPACE     NAME                     TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                  AGE</span>
<span class="c">#    default       service/kubernetes       ClusterIP   10.10.200.1     &amp;lt;none&amp;gt;        443/TCP                  38m</span>
<span class="c">#    kube-system   service/kube-dns         ClusterIP   10.10.200.10    &amp;lt;none&amp;gt;        53/UDP,53/TCP,9153/TCP   38m</span>
<span class="c">#    kube-system   service/metrics-server   ClusterIP   10.10.200.103   &amp;lt;none&amp;gt;        443/TCP                  38m</span>
<span class="c">#    </span>
<span class="c">#    NAMESPACE     NAME                       ENDPOINTS                                     AGE</span>
<span class="c">#    default       endpoints/kubernetes       10.0.2.15:6443                                38m</span>
<span class="c">#    kube-system   endpoints/kube-dns         172.16.0.4:53,172.16.0.4:53,172.16.0.4:9153   38m</span>
<span class="c">#    kube-system   endpoints/metrics-server   172.16.0.3:10250                              38m</span>

<span class="c"># iptables 정보 확인</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> filter <span class="nt">-S</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> nat <span class="nt">-S</span>
<span class="nv">$ </span>iptables <span class="nt">-t</span> mangle <span class="nt">-S</span>

<span class="c"># tcp listen 포트 정보 확인</span>
<span class="nv">$ </span>ss <span class="nt">-tnlp</span>
</code></pre></div></div>

<ul>
  <li>flannel CNI를 사용하고 있고, 클러스터 IP는 172.16.0.0/16이며, 컨트롤 플레인의기능들이 많이 내장되어있어 실행중인 파드가 적음을 확인 할 수 있습니다.</li>
</ul>

<h3 id="nginx-ingress-controller-설치">Nginx Ingress Controller 설치</h3>

<ul>
  <li>Nginx Ingress Controller는 가장 많이 사용되는 Ingress Controller 중 하나로 Ingress 실습을 위해 설치해보겠습니다.</li>
  <li>먼저 NGINX Ingress 의 특징을 살펴보겠습니다.
    <ul>
      <li>NGINX Ingress는 고성능 웹서버인 NGINX를 기반으로 동작하며, Layer 7에서 동작합니다.</li>
      <li>k8s의 configmap 설정을 lua 스크립트로 가공하여 nginx config로 변환하여 사용합니다.</li>
      <li>설정을 변경하면 내부의 nginx가 reload 되면서 자동으로 적용되며, 설정을 쉽게 변경할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Ingress-Nginx 컨트롤러 생성</span>
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOT</span><span class="sh">&gt; ingress-nginx-values.yaml
controller:
  service:
    type: NodePort
    nodePorts:
      http: 30080
      https: 30443
  nodeSelector:
    kubernetes.io/hostname: "k3s-s"
  metrics:
    enabled: true
  serviceMonitor:
      enabled: true
</span><span class="no">EOT

</span><span class="nv">$ </span>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
<span class="c"># =&gt; "ingress-nginx" has been added to your repositories</span>
<span class="nv">$ </span>helm repo update
<span class="c"># =&gt; ...Successfully got an update from the "ingress-nginx" chart repository</span>

<span class="nv">$ </span>kubectl create ns ingress
<span class="c"># =&gt; namespace/ingress created</span>
<span class="nv">$ </span>helm <span class="nb">install </span>ingress-nginx ingress-nginx/ingress-nginx <span class="nt">-f</span> ingress-nginx-values.yaml <span class="nt">--namespace</span> ingress <span class="nt">--version</span> 4.11.2
<span class="c"># =&gt; Release &amp;quot;ingress-nginx&amp;quot; has been upgraded. Happy Helming!</span>
<span class="c">#    NAME: ingress-nginx</span>
<span class="c">#    NAMESPACE: ingress</span>
<span class="c">#    STATUS: deployed</span>
<span class="c">#    ...</span>
<span class="c">#    The ingress-nginx controller has been installed.</span>
<span class="c">#    Get the application URL by running these commands:</span>
<span class="c">#      export HTTP_NODE_PORT=30080</span>
<span class="c">#      export HTTPS_NODE_PORT=30443</span>
<span class="c">#      export NODE_IP=&amp;quot;$(kubectl get nodes --output jsonpath=&amp;quot;{.items[0].status.addresses[1].address}&amp;quot;)&amp;quot;</span>
<span class="c">#    </span>
<span class="c">#      echo &amp;quot;Visit http://${NODE_IP}:${HTTP_NODE_PORT} to access your application via HTTP.&amp;quot;</span>
<span class="c">#      echo &amp;quot;Visit https://${NODE_IP}:${HTTPS_NODE_PORT} to access your application via HTTPS.&amp;quot;</span>
<span class="c">#    ...</span>

<span class="c"># 확인</span>
<span class="nv">$ </span>kubectl get all <span class="nt">-n</span> ingress
<span class="c"># =&gt; NAME                                            READY   STATUS    RESTARTS   AGE</span>
<span class="c">#    pod/ingress-nginx-controller-7b67846f8f-jdt65   1/1     Running   0          47s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE</span>
<span class="c">#    service/ingress-nginx-controller             NodePort    10.10.200.113   &amp;lt;none&amp;gt;        80:30080/TCP,443:30443/TCP   47s</span>
<span class="c">#    service/ingress-nginx-controller-admission   ClusterIP   10.10.200.176   &amp;lt;none&amp;gt;        443/TCP                      47s</span>
<span class="c">#    service/ingress-nginx-controller-metrics     ClusterIP   10.10.200.218   &amp;lt;none&amp;gt;        10254/TCP                    47s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                       READY   UP-TO-DATE   AVAILABLE   AGE</span>
<span class="c">#    deployment.apps/ingress-nginx-controller   1/1     1            1           47s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                                  DESIRED   CURRENT   READY   AGE</span>
<span class="c">#    replicaset.apps/ingress-nginx-controller-7b67846f8f   1         1         1       47s</span>

<span class="nv">$ </span>kubectl describe svc <span class="nt">-n</span> ingress ingress-nginx-controller
<span class="c"># =&gt; Name:                     ingress-nginx-controller</span>
<span class="c">#    Namespace:                ingress</span>
<span class="c">#    Labels:                   app.kubernetes.io/component=controller</span>
<span class="c">#                              app.kubernetes.io/instance=ingress-nginx</span>
<span class="c">#    ...</span>
<span class="c">#    Selector:                 app.kubernetes.io/component=controller,app.kubernetes.io/instance=ingress-nginx,app.kubernetes.io/name=ingress-nginx</span>
<span class="c">#    Type:                     NodePort</span>
<span class="c">#    IP Family Policy:         SingleStack</span>
<span class="c">#    IP Families:              IPv4</span>
<span class="c">#    IP:                       10.10.200.113</span>
<span class="c">#    ...</span>
<span class="c">#    Port:                     http  80/TCP</span>
<span class="c">#    TargetPort:               http/TCP</span>
<span class="c">#    NodePort:                 http  30080/TCP</span>
<span class="c">#    Endpoints:                172.16.0.16:80</span>
<span class="c">#    Port:                     https  443/TCP</span>
<span class="c">#    TargetPort:               https/TCP</span>
<span class="c">#    NodePort:                 https  30443/TCP</span>
<span class="c">#    Endpoints:                172.16.0.16:443</span>
<span class="c">#    ...</span>

<span class="c"># externalTrafficPolicy 설정</span>
<span class="nv">$ </span>kubectl patch svc <span class="nt">-n</span> ingress ingress-nginx-controller <span class="nt">-p</span> <span class="s1">'{"spec":{"externalTrafficPolicy": "Local"}}'</span>
<span class="c"># =&gt; service/ingress-nginx-controller patched</span>

<span class="c"># 기본 nginx conf 파일 확인</span>
<span class="nv">$ </span>kubectl describe cm <span class="nt">-n</span> ingress ingress-nginx-controller
<span class="c"># =&gt; ...</span>
<span class="c">#    Data</span>
<span class="c">#    ====</span>
<span class="c">#    allow-snippet-annotations:</span>
<span class="c">#    ----</span>
<span class="c">#    false</span>
<span class="c">#    ...</span>
<span class="nv">$ </span>kubectl <span class="nb">exec </span>deploy/ingress-nginx-controller <span class="nt">-n</span> ingress <span class="nt">-it</span> <span class="nt">--</span> <span class="nb">cat</span> /etc/nginx/nginx.conf
<span class="c"># =&gt; # Configuration checksum: 13054992059071414660</span>
<span class="c">#    # setup custom paths that do not require root access</span>
<span class="c">#    pid /tmp/nginx/nginx.pid;</span>
<span class="c">#    </span>
<span class="c">#    daemon off;</span>
<span class="c">#    worker_processes 4;</span>
<span class="c">#    worker_rlimit_nofile 1047552;</span>
<span class="c">#    worker_shutdown_timeout 240s ;</span>
<span class="c">#    </span>
<span class="c">#    events {</span>
<span class="c">#            multi_accept        on;</span>
<span class="c">#            worker_connections  16384;</span>
<span class="c">#            use                 epoll;</span>
<span class="c">#    }</span>
<span class="c">#    </span>
<span class="c">#    http {</span>
<span class="c">#            lua_package_path &amp;quot;/etc/nginx/lua/?.lua;;&amp;quot;;</span>
<span class="c">#            lua_shared_dict balancer_ewma 10M;</span>
<span class="c">#    ...</span>

<span class="c"># 관련된 정보 확인 : 포드(Nginx 서버), 서비스, 디플로이먼트, 리플리카셋, 컨피그맵, 롤, 클러스터롤, 서비스 어카운트 등</span>
<span class="nv">$ </span>kubectl get all,sa,cm,secret,roles <span class="nt">-n</span> ingress
<span class="c"># =&gt; NAME                                            READY   STATUS    RESTARTS   AGE</span>
<span class="c">#    pod/ingress-nginx-controller-7b67846f8f-jdt65   1/1     Running   0          4m21s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE</span>
<span class="c">#    service/ingress-nginx-controller             NodePort    10.10.200.113   &amp;lt;none&amp;gt;        80:30080/TCP,443:30443/TCP   4m21s</span>
<span class="c">#    service/ingress-nginx-controller-admission   ClusterIP   10.10.200.176   &amp;lt;none&amp;gt;        443/TCP                      4m21s</span>
<span class="c">#    service/ingress-nginx-controller-metrics     ClusterIP   10.10.200.218   &amp;lt;none&amp;gt;        10254/TCP                    4m21s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                       READY   UP-TO-DATE   AVAILABLE   AGE</span>
<span class="c">#    deployment.apps/ingress-nginx-controller   1/1     1            1           4m21s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                                  DESIRED   CURRENT   READY   AGE</span>
<span class="c">#    replicaset.apps/ingress-nginx-controller-7b67846f8f   1         1         1       4m21s</span>
<span class="c">#    </span>
<span class="c">#    NAME                           SECRETS   AGE</span>
<span class="c">#    serviceaccount/default         0         4m29s</span>
<span class="c">#    serviceaccount/ingress-nginx   0         4m21s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                 DATA   AGE</span>
<span class="c">#    configmap/ingress-nginx-controller   1      4m21s</span>
<span class="c">#    configmap/kube-root-ca.crt           1      4m30s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                         TYPE                 DATA   AGE</span>
<span class="c">#    secret/ingress-nginx-admission               Opaque               3      4m24s</span>
<span class="c">#    secret/sh.helm.release.v1.ingress-nginx.v1   helm.sh/release.v1   1      4m26s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                           CREATED AT</span>
<span class="c">#    role.rbac.authorization.k8s.io/ingress-nginx   2024-01-01T08:53:04Z</span>
<span class="nv">$ </span>kubectl describe clusterroles ingress-nginx
<span class="nv">$ </span>kubectl get pod,svc,ep <span class="nt">-n</span> ingress <span class="nt">-o</span> wide <span class="nt">-l</span> app.kubernetes.io/component<span class="o">=</span>controller

<span class="c"># 버전 정보 확인</span>
<span class="nv">$ POD_NAMESPACE</span><span class="o">=</span>ingress
<span class="nv">$ POD_NAME</span><span class="o">=</span><span class="si">$(</span>kubectl get pods <span class="nt">-n</span> <span class="nv">$POD_NAMESPACE</span> <span class="nt">-l</span> app.kubernetes.io/name<span class="o">=</span>ingress-nginx <span class="nt">--field-selector</span><span class="o">=</span>status.phase<span class="o">=</span>Running <span class="nt">-o</span> name<span class="si">)</span>
<span class="nv">$ </span>kubectl <span class="nb">exec</span> <span class="nv">$POD_NAME</span> <span class="nt">-n</span> <span class="nv">$POD_NAMESPACE</span> <span class="nt">--</span> /nginx-ingress-controller <span class="nt">--version</span>
<span class="c"># =&gt; -------------------------------------------------------------------------------</span>
<span class="c">#    NGINX Ingress controller</span>
<span class="c">#      Release:       v1.11.2</span>
<span class="c">#      Build:         46e76e5916813cfca2a9b0bfdc34b69a0000f6b9</span>
<span class="c">#      Repository:    https://github.com/kubernetes/ingress-nginx</span>
<span class="c">#      nginx version: nginx/1.25.5</span>
<span class="c">#    -------------------------------------------------------------------------------</span>
</code></pre></div></div>

<ul>
  <li>Ingress Controller가 설치되었으며, NodePort로 서비스가 생성된것을 확인할 수 있습니다.</li>
  <li>
    <p>또한 Nginx Ingress Controller의 경우 내부적으로는 일반적인 <strong>nginx 서버가 동일하게 동작</strong>하고, <strong>lua 스크립트를 사용하여 configmap의 설정이 적용/관리</strong>되고 있음을 확인할 수 있습니다.</p>
  </li>
  <li>(옵션) kubectl krew 설치 - <a href="https://krew.sigs.k8s.io/docs/user-guide/setup/install/">링크</a> &amp; ingress-nginx plugin 설치 - <a href="https://kubernetes.github.io/ingress-nginx/kubectl-plugin/">링크</a>
</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># (참고) 운영체제 확인 : linux</span>
<span class="nv">$ OS</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">uname</span> | <span class="nb">tr</span> <span class="s1">'[:upper:]'</span> <span class="s1">'[:lower:]'</span><span class="si">)</span><span class="s2">"</span>
<span class="c"># (참고)  CPU 아키텍처 확인 : amd64</span>
<span class="nv">$ ARCH</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-m</span> | <span class="nb">sed</span> <span class="nt">-e</span> <span class="s1">'s/x86_64/amd64/'</span> <span class="nt">-e</span> <span class="s1">'s/\(arm\)\(64\)\?.*/\1\2/'</span> <span class="nt">-e</span> <span class="s1">'s/aarch64$/arm64/'</span><span class="si">)</span><span class="s2">"</span>
<span class="c"># (참고)  KREW 지정 : krew-linux_amd64</span>
<span class="nv">$ KREW</span><span class="o">=</span><span class="s2">"krew-</span><span class="k">${</span><span class="nv">OS</span><span class="k">}</span><span class="s2">_</span><span class="k">${</span><span class="nv">ARCH</span><span class="k">}</span><span class="s2">"</span>

<span class="c"># kubectl krew 설치</span>
<span class="c"># curl -fsSLO "https://github.com/kubernetes-sigs/krew/releases/latest/download/${KREW}.tar.gz"</span>
<span class="nv">$ </span>curl <span class="nt">-fsSLO</span> <span class="s2">"https://github.com/kubernetes-sigs/krew/releases/latest/download/krew-linux_amd64.tar.gz"</span> <span class="o">&amp;&amp;</span> <span class="nb">tar </span>zxvf krew-linux_amd64.tar.gz <span class="o">&amp;&amp;</span> ./krew-linux_amd64 <span class="nb">install </span>krew
<span class="nv">$ </span><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">KREW_ROOT</span><span class="k">:-</span><span class="nv">$HOME</span><span class="p">/.krew</span><span class="k">}</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">"</span>

<span class="c"># 플러그인 정보 업데이트 후 확인 - 링크</span>
<span class="nv">$ </span>kubectl krew update
<span class="nv">$ </span>kubectl krew search

<span class="c"># ingress-nginx 플러그인 설치</span>
<span class="nv">$ </span>kubectl krew <span class="nb">install </span>ingress-nginx
<span class="c"># =&gt; (아쉽게도 옛날 버전이라서 설치가 안 됩니다.) </span>

<span class="c"># ingress-nginx 플러그인 명령어 실행(도움말 출력)</span>
<span class="nv">$ </span>kubectl ingress-nginx

<span class="c"># nginx ctrl 의 backends 설정 정보 출력</span>
<span class="nv">$ </span>kubectl ingress-nginx backends <span class="nt">-n</span> ingress-nginx <span class="nt">--list</span>
<span class="nv">$ </span>kubectl ingress-nginx backends <span class="nt">-n</span> ingress-nginx

<span class="c"># conf 출력</span>
<span class="nv">$ </span>kubectl ingress-nginx conf <span class="nt">-n</span> ingress-nginx
<span class="c">## 특정 호스트(도메인) 설정 확인</span>
<span class="nv">$ </span>kubectl ingress-nginx conf <span class="nt">-n</span> ingress-nginx <span class="nt">--host</span> gasida.cndk.link
<span class="nv">$ </span>kubectl ingress-nginx conf <span class="nt">-n</span> ingress-nginx <span class="nt">--host</span> nasida.cndk.link

<span class="c"># 정보 보기 편함!</span>
<span class="nv">$ </span>kubectl ingress-nginx ingresses
<span class="nv">$ </span>kubectl ingress-nginx ingresses <span class="nt">--all-namespaces</span>
</code></pre></div></div>

<h3 id="인그레스ingress-실습-및-통신-흐름-확인">인그레스(Ingress) 실습 및 통신 흐름 확인</h3>

<ul>
  <li>실습 구성도
    <ul>
      <li>컨트롤플레인 노드에 인그레스 컨트롤러(Nginx) 파드를 생성하고, NodePort 로 외부에 노출합니다.</li>
      <li>인그레스 정책 설정 : Host/Path routing, 실습의 편리를 위해서 도메인 없이 IP로 접속 설정 가능하도록 합니다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_5.png" alt="img.png" loading="lazy" width="1017" height="741"></p>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_6.png" alt="img_1.png" loading="lazy" width="1249" height="686"></p>

<h4 id="deployment와-service-생성">deployment와 service 생성</h4>

<ul>
  <li>svc1-pod.yml 생성
    <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1"># svc1-pod.yml</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">deploy1-websrv</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">websrv</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">websrv</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">pod-web</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">svc1-web</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web-port</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">9001</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="m">80</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">websrv</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">ClusterIP</span>
</code></pre></div>    </div>
  </li>
  <li>svc2-pod.yml 생성
    <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1"># svc2-pod.yml </span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">deploy2-guestsrv</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">2</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">guestsrv</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">guestsrv</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">pod-guest</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">gcr.io/google-samples/kubernetes-bootcamp:v1</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">svc2-guest</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">guest-port</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">9002</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="m">8080</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">guestsrv</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">NodePort</span>
</code></pre></div>    </div>
  </li>
  <li>svc3-pod.yml 생성
    <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1"># svc3-pod.yml</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">deploy3-adminsrv</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">adminsrv</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">adminsrv</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">pod-admin</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">k8s.gcr.io/echoserver:1.5</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">svc3-admin</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">admin-port</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">9003</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="m">8080</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">adminsrv</span>
</code></pre></div>    </div>
  </li>
  <li>생성 및 확인
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 모니터링</span>
<span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'kubectl get ingress,svc,ep,pod -owide'</span>
  
<span class="c"># 생성</span>
<span class="nv">$ </span>kubectl taint nodes k3s-m <span class="nv">role</span><span class="o">=</span>controlplane:NoSchedule
<span class="c"># &lt;span style="color: green;"&gt;&lt;/span&gt;</span>
  
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> svc1-pod.yml,svc2-pod.yml,svc3-pod.yml
<span class="c"># =&gt; deployment.apps/deploy1-websrv created</span>
<span class="c">#    service/svc1-web created</span>
<span class="c">#    deployment.apps/deploy2-guestsrv created</span>
<span class="c">#    service/svc2-guest created</span>
<span class="c">#    deployment.apps/deploy3-adminsrv created</span>
<span class="c">#    service/svc3-admin created</span>
  
<span class="c"># 확인 : svc1, svc3 은 ClusterIP 로 클러스터 외부에서는 접속할 수 없다 &gt;&gt; Ingress 는 연결 가능!</span>
<span class="nv">$ </span>kubectl get pod,svc,ep
<span class="c"># =&gt; NAME                                    READY   STATUS    RESTARTS   AGE</span>
<span class="c">#    pod/deploy1-websrv-5c6b88bd77-ht5hl     1/1     Running   0          34s</span>
<span class="c">#    pod/deploy2-guestsrv-649875f78b-8wh8r   1/1     Running   0          34s</span>
<span class="c">#    pod/deploy2-guestsrv-649875f78b-jcvrf   1/1     Running   0          34s</span>
<span class="c">#    pod/deploy3-adminsrv-7c8f8b8c87-4mzv7   1/1     Running   0          34s</span>
<span class="c">#    pod/deploy3-adminsrv-7c8f8b8c87-4sqmh   1/1     Running   0          34s</span>
<span class="c">#    pod/deploy3-adminsrv-7c8f8b8c87-ztltl   1/1     Running   0          34s</span>
<span class="c">#    </span>
<span class="c">#    NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span>
<span class="c">#    service/kubernetes   ClusterIP   10.10.200.1     &amp;lt;none&amp;gt;        443/TCP          5h52m</span>
<span class="c">#    service/svc1-web     ClusterIP   10.10.200.141   &amp;lt;none&amp;gt;        9001/TCP         34s</span>
<span class="c">#    service/svc2-guest   NodePort    10.10.200.60    &amp;lt;none&amp;gt;        9002:30901/TCP   34s</span>
<span class="c">#    service/svc3-admin   ClusterIP   10.10.200.171   &amp;lt;none&amp;gt;        9003/TCP         34s</span>
<span class="c">#    &lt;span style="color: green;"&gt;# ingress는 pod 정보로 바로 접근 가능하므로 서비스가 ClusterIP이든 NodePort 타입이든 관계 없습니다.&lt;/span&gt;</span>
<span class="c">#    </span>
<span class="c">#    NAME                   ENDPOINTS                                         AGE</span>
<span class="c">#    endpoints/kubernetes   192.168.10.10:6443                                5h52m</span>
<span class="c">#    endpoints/svc1-web     172.16.1.8:80                                     34s</span>
<span class="c">#    endpoints/svc2-guest   172.16.2.8:8080,172.16.3.7:8080                   34s</span>
<span class="c">#    endpoints/svc3-admin   172.16.1.7:8080,172.16.2.9:8080,172.16.3.8:8080   34s</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="인그레스정책-생성">인그레스(정책) 생성</h4>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_7.png" alt="img.png" class="image-center" loading="lazy" width="1257" height="697">
<em class="image-caption">ingress 정책 적용 구조 (<a href="https://kschoi728.tistory.com/266">출처</a>)</em></p>

<ul>
  <li>ingress1.yml 파일 생성</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOT</span><span class="sh">&gt; ingress1.yml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-1
  annotations:
    #nginx.ingress.kubernetes.io/upstream-hash-by: "true"
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: svc1-web
            port:
              number: 80
      - path: /guest
        pathType: Prefix
        backend:
          service:
            name: svc2-guest
            port:
              number: 8080
      - path: /admin
        pathType: Prefix
        backend:
          service:
            name: svc3-admin
            port:
              number: 8080
</span><span class="no">EOT
</span></code></pre></div></div>

<ul>
  <li>ingress 정책 생성</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 모니터링</span>
<span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'kubectl get ingress,svc,ep,pod -owide'</span>

<span class="c"># 생성</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> ingress1.yml
<span class="c"># =&gt; ingress.networking.k8s.io/ingress-1 created</span>

<span class="c"># 확인</span>
<span class="nv">$ </span>kubectl get ingress
<span class="c"># =&gt; NAME        CLASS   HOSTS   ADDRESS   PORTS   AGE</span>
<span class="c">#    ingress-1   nginx   *                 80      11s</span>
<span class="nv">$ </span>kubectl describe ingress ingress-1
<span class="c"># =&gt; ...</span>
<span class="c">#    Rules:</span>
<span class="c">#      Host        Path  Backends</span>
<span class="c">#      ----        ----  --------</span>
<span class="c">#      *</span>
<span class="c">#                  /        svc1-web:80 ()</span>
<span class="c">#                  /guest   svc2-guest:8080 ()</span>
<span class="c">#                  /admin   svc3-admin:8080 ()</span>
<span class="c">#    ...</span>

<span class="c"># 설정이 반영된 nginx conf 파일 확인</span>
<span class="nv">$ </span>kubectl <span class="nb">exec </span>deploy/ingress-nginx-controller <span class="nt">-n</span> ingress <span class="nt">-it</span> <span class="nt">--</span> <span class="nb">cat</span> /etc/nginx/nginx.conf
<span class="nv">$ </span>kubectl <span class="nb">exec </span>deploy/ingress-nginx-controller <span class="nt">-n</span> ingress <span class="nt">-it</span> <span class="nt">--</span> <span class="nb">cat</span> /etc/nginx/nginx.conf | <span class="nb">grep</span> <span class="s1">'location /'</span> <span class="nt">-A5</span>
<span class="c"># =&gt;      location /guest/ {</span>
<span class="c">#    </span>
<span class="c">#         set $namespace      &amp;quot;default&amp;quot;;</span>
<span class="c">#         set $ingress_name   &amp;quot;ingress-1&amp;quot;;</span>
<span class="c">#         set $service_name   &amp;quot;svc2-guest&amp;quot;;</span>
<span class="c">#         set $service_port   &amp;quot;8080&amp;quot;;</span>
<span class="c">#    --</span>
<span class="c">#         location /admin/ {</span>
<span class="c">#    </span>
<span class="c">#         set $namespace      &amp;quot;default&amp;quot;;</span>
<span class="c">#         set $ingress_name   &amp;quot;ingress-1&amp;quot;;</span>
<span class="c">#         set $service_name   &amp;quot;svc3-admin&amp;quot;;</span>
<span class="c">#         set $service_port   &amp;quot;8080&amp;quot;;</span>
<span class="c">#    --</span>
<span class="c">#         location / {</span>
<span class="c">#    </span>
<span class="c">#         set $namespace      &amp;quot;default&amp;quot;;</span>
<span class="c">#         set $ingress_name   &amp;quot;ingress-1&amp;quot;;</span>
<span class="c">#         set $service_name   &amp;quot;svc1-web&amp;quot;;</span>
<span class="c">#         set $service_port   &amp;quot;80&amp;quot;;</span>
<span class="c">#    ...</span>
</code></pre></div></div>

<h4 id="ingress를-통한-내부-접속">ingress를 통한 내부 접속</h4>

<ul>
  <li>
    <p>Nginx ingress controller를 통해 접속시 서비스는 파드의 엔드포인트의 정보만 참조되고, 서비스를 거치지 않고 바로 파드로 전달됩니다.
<img src="/assets/2024/kans-3th/w6/20241012_kans_w6_8.png" alt="img.png" class="w-80 image-center" loading="lazy" width="1023" height="916">
<em class="image-caption">인그레스 접속 경로(서비스 Bypass) : Ingress → 애플리케이션(Deploy, Pod 등)</em></p>
  </li>
  <li>참고 : URI(Uniform Resource Identifier)는 RFC 3986에 정의된 통합 자원 식별자로, 흔히 사용되는 URL(Uniform Resource Locator)과 URN(Uniform Resource Name)을 포함합니다.
    <ul>
      <li>Request URI는 서버 주소나 파일이름, 파라미터 등 다양한 리소스를 식별하기 위해 사용되는 문자열입니다.</li>
      <li>절대 URI(absolute URI)는 스키마와 호스트를 포함한 완전한 URI를 의미하며, 상대 URI(relative URI)는 스키마와 호스트를 포함하지 않고 현재 위치에서 상대적인 위치를 기록한 URI를 의미합니다.
        <ul>
          <li>URI의 구조는 아래와 같습니다.
<img src="/assets/2024/kans-3th/w6/20241012_kans_w6_9.png" alt="img.png" class="image-center" loading="lazy" width="749" height="203">
<em class="image-caption">책 ‘그림으로 공부하는 TCP/IP 구조’ 중 발췌</em>
</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>참고 : X-Forwarded-For 헤더, X-Forwarded-Proto 헤더
    <ul>
      <li>X-Forwarded-For 헤더는 송신지 IP 주소가 변환되는 환경(장비, 서버, 솔루션 등)에서, 변환 전 송신지(클라이언트) IP 주소를 저장하는 헤더입니다.
        <ul>
          <li>여러 장비나 솔루션을 거칠 경우 <code class="language-plaintext highlighter-rouge">,</code>로 구분하여 여러 건이 넘어올 수도 있습니다. 그럴 경우 가장 왼쪽 것이 클라이언트 IP이고, 오른쪽으로 갈 수록 나중에 처리된 장비/솔루션의 IP가 됩니다.</li>
        </ul>
      </li>
      <li>X-Forwarded-Proto 헤더는 변환 전 프로토콜을 저장합니다. (예. SSL Offload 환경에서 서버 측에서 클라이언트가 요청 시 사용한 원래 프로토콜을 확인)</li>
      <li>이러한 헤더는 클라이언트의 IP 주소를 확인하거나, 프로토콜을 확인하는 등의 용도로 사용되며, 어플리케이션에서 NodePort나 LoadBalancer를 통해서 접속되었을때도 원래의 클라이언트의 IP를 확인할 수 있게 해줍니다. (<code class="language-plaintext highlighter-rouge">externalTrafficPolicy: Local</code>를 사용할 필요가 줄어듭니다!)</li>
      <li>원래의 IP를 가져오는 방법은 다음의 방법들이 있습니다.
        <ul>
          <li>Http request header 중 다음 값들에서 원래의 IP 찾기
            <ol>
              <li>X-Forwarded-For : HTTP RFC 표준에는 없지만 사실상 표준!!!</li>
              <li>Proxy-Client-IP : 특정 웹 어플리케이션에서 사용 (예. WebLogic Connector - mod_wl)</li>
              <li>WL-Proxy-Client-IP : 특정 웹 어플리케이션에서 사용 (예. WebLogic Connector - mod_wl)</li>
              <li>CLIENT_IP</li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>인그레스(Nginx 인그레스 컨트롤러)를 통한 접속(HTTP 인입)을 확인해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># (krew 플러그인 설치 시) 인그레스 정책 확인</span>
<span class="c"># $ kubectl ingress-nginx ingresses</span>
<span class="c"># INGRESS NAME   HOST+PATH   ADDRESSES       TLS   SERVICE      SERVICE PORT   ENDPOINTS</span>
<span class="c"># ingress-1      /           192.168.10.10   NO    svc1-web     80             1</span>
<span class="c"># ingress-1      /guest      192.168.10.10   NO    svc2-guest   8080           2</span>
<span class="c"># ingress-1      /admin      192.168.10.10   NO    svc3-admin   8080           3</span>

<span class="c">#</span>
<span class="nv">$ </span>kubectl get ingress
<span class="c"># =&gt; NAME        CLASS   HOSTS   ADDRESS         PORTS   AGE</span>
<span class="c">#    ingress-1   nginx   *       10.10.200.113   80      18m</span>
 
<span class="nv">$ </span>kubectl describe ingress ingress-1 | <span class="nb">sed</span> <span class="nt">-n</span> <span class="s2">"5, </span><span class="se">\$</span><span class="s2">p"</span>
<span class="c"># =&gt; ...</span>
<span class="c">#    Rules:</span>
<span class="c">#      Host        Path  Backends</span>
<span class="c">#      ----        ----  --------</span>
<span class="c">#      *</span>
<span class="c">#                  /        svc1-web:80 ()</span>
<span class="c">#                  /guest   svc2-guest:8080 ()</span>
<span class="c">#                  /admin   svc3-admin:8080 ()</span>
<span class="c">#    ...</span>

<span class="c"># 접속 로그 확인 : kubetail 설치되어 있음 - 출력되는 nginx 의 로그의 IP 확인</span>
<span class="nv">$ </span>kubetail <span class="nt">-n</span> ingress <span class="nt">-l</span> app.kubernetes.io/component<span class="o">=</span>controller

<span class="nt">-------------------------------</span>
<span class="c"># 자신의 집 PC에서 인그레스를 통한 접속 : 각각 </span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"Ingress1 sv1-web URL = http://</span><span class="si">$(</span>curl <span class="nt">-s</span> ipinfo.io/ip<span class="si">)</span><span class="s2">:30080"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"Ingress1 sv2-guest URL = http://</span><span class="si">$(</span>curl <span class="nt">-s</span> ipinfo.io/ip<span class="si">)</span><span class="s2">:30080/guest"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"Ingress1 sv3-admin URL = http://</span><span class="si">$(</span>curl <span class="nt">-s</span> ipinfo.io/ip<span class="si">)</span><span class="s2">:30080/admin"</span>

<span class="c"># svc1-web 접속</span>
<span class="c"># $ MYIP=&lt;EC2 공인 IP 또는 컨트롤플레인 node ip&gt;</span>
<span class="nv">$ MYIP</span><span class="o">=</span>192.168.10.10
<span class="nv">$ </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080
<span class="c"># =&gt; ...</span>
<span class="c">#    &amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt;</span>
<span class="c">#    &amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and</span>
<span class="c">#    working. Further configuration is required.&amp;lt;/p&amp;gt;</span>
<span class="c">#    </span>
<span class="c">#    &amp;lt;p&amp;gt;For online documentation and support please refer to</span>
<span class="c">#    &amp;lt;a href=&amp;quot;http://nginx.org/&amp;quot;&amp;gt;nginx.org&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt;</span>
<span class="c">#    Commercial support is available at</span>
<span class="c">#    &amp;lt;a href=&amp;quot;http://nginx.com/&amp;quot;&amp;gt;nginx.com&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;</span>
<span class="c">#    </span>
<span class="c">#    &amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Thank you for using nginx.&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;</span>
<span class="c">#    ...</span>

<span class="c"># svc2-guest 접속</span>
<span class="nv">$ </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080/guest
<span class="c"># =&gt; Hello Kubernetes bootcamp! | Running on: deploy2-guestsrv-649875f78b-jcvrf | v=1</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080/guest <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;      51 Hello Kubernetes bootcamp! | Running on: deploy2-guestsrv-649875f78b-8wh8r | v=1</span>
<span class="c">#         49 Hello Kubernetes bootcamp! | Running on: deploy2-guestsrv-649875f78b-jcvrf | v=1</span>

<span class="c"># svc3-admin 접속 &gt; 기본적으로 Nginx 는 라운드로빈 부하분산 알고리즘을 사용 &gt;&gt; Client_address 와 XFF 주소는 어떤 주소인가요?</span>
<span class="nv">$ </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080/admin
<span class="nv">$ </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080/admin | egrep <span class="s1">'(client_address|x-forwarded-for)'</span>
<span class="c"># =&gt;  client_address=172.16.0.16</span>
<span class="c">#     x-forwarded-for=172.16.0.1</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080/admin | <span class="nb">grep </span>Hostname <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;      34 Hostname: deploy3-adminsrv-7c8f8b8c87-4sqmh</span>
<span class="c">#         33 Hostname: deploy3-adminsrv-7c8f8b8c87-ztltl</span>
<span class="c">#         33 Hostname: deploy3-adminsrv-7c8f8b8c87-4mzv7</span>

<span class="c"># (옵션) 디플로이먼트의 파드 갯수를 증가/감소 설정 후 접속 테스트 해보자</span>
<span class="nv">$ </span>kubectl scale deployment deploy3-adminsrv <span class="nt">--replicas</span> 2   <span class="c"># svc3-admin의 파드 갯수를 2개로 감소</span>
<span class="c"># =&gt; deployment.apps/deploy3-adminsrv scaled</span>
<span class="nv">$ </span>kubectl get deploy deploy3-adminsrv
<span class="c"># =&gt; NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span>
<span class="c">#    deploy3-adminsrv   2/2     2            2           80m</span>
<span class="c"># &lt;span style="color: green;"&gt;파드수가 3개 =&gt; 2개로 줄었습니다.&lt;/span&gt;</span>
 
<span class="c"># 접속 테스트</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080/admin | <span class="nb">grep </span>Hostname <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;      50 Hostname: deploy3-adminsrv-7c8f8b8c87-4sqmh</span>
<span class="c">#         50 Hostname: deploy3-adminsrv-7c8f8b8c87-4mzv7</span>
<span class="c"># &lt;span style="color: green;"&gt;2개로 줄어든 파드수만큼 2개의 파드에 부하가 분산 되는것을 확인하였습니다.&lt;/span&gt;</span>
</code></pre></div></div>

<ul>
  <li>노드에서 패킷 캡쳐 확인 : flannel vxlan의 파드간 통신시 IP정보 확인</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ngrep을 이용해 패킷 캡쳐</span>
<span class="nv">$ </span>ngrep <span class="nt">-tW</span> byline <span class="nt">-d</span> enp0s8 <span class="s1">''</span> udp port 8472 or tcp port 80
<span class="c"># =&gt; interface: enp0s8 (192.168.10.0/255.255.255.0)</span>
<span class="c">#    filter: ( udp port 8472 or tcp port 80 ) and ((ip || ip6) || (vlan &amp;amp;&amp;amp; (ip || ip6)))</span>
<span class="c">#    #</span>
<span class="c">#    U 2024/10/12 12:42:39.071289 192.168.10.10:39828 -&amp;gt; 192.168.10.102:8472 #1</span>
<span class="c">#    .........(Ce...!w.....E..&amp;lt;..@.?............|.P...........\...........</span>
<span class="c">#    d9?.........</span>
<span class="c">#    #</span>
<span class="c">#    U 2024/10/12 12:42:39.072521 192.168.10.102:37126 -&amp;gt; 192.168.10.10:8472 #2</span>
<span class="c">#    .........!w....(Ce....E..&amp;lt;..@.?............P.|(3c@.......4.y.........</span>
<span class="c">#    ....d9?.....</span>
<span class="c">#    #</span>
<span class="c">#    U 2024/10/12 12:42:39.072734 192.168.10.10:39828 -&amp;gt; 192.168.10.102:8472 #3</span>
<span class="c">#    .........(Ce...!w.....E..4..@.?............|.P....(3cA.....K.....</span>
<span class="c">#    d9?.....</span>
<span class="c">#    #</span>
<span class="c">#    U 2024/10/12 12:42:39.072855 192.168.10.10:39828 -&amp;gt; 192.168.10.102:8472 #4</span>
<span class="c">#    .........(Ce...!w.....E..c..@.?..Y.........|.P....(3cA...........</span>
<span class="c">#    d9?.....GET / HTTP/1.1.</span>
<span class="c">#    Host: localhost:30080.</span>
<span class="c">#    X-Request-ID: e8aa4e70150ae6ae8de5a34637e294e6.</span>
<span class="c">#    X-Real-IP: 172.16.0.1.</span>
<span class="c">#    X-Forwarded-For: 172.16.0.1.</span>
<span class="c">#    X-Forwarded-Host: localhost:30080.</span>
<span class="c">#    X-Forwarded-Port: 80.</span>
<span class="c">#    X-Forwarded-Proto: http.</span>
<span class="c">#    X-Forwarded-Scheme: http.</span>
<span class="c">#    X-Scheme: http.</span>
<span class="c">#    User-Agent: curl/7.81.0.</span>
<span class="c">#    Accept: */*.</span>
<span class="c">#    ...</span>

<span class="c"># tcp dump를 이용해 vxlan(udp 8472) 통신 확인</span>
<span class="nv">$ </span>tcpdump <span class="nt">-i</span> enp0s8 udp port 8472 <span class="nt">-nn</span>
<span class="c"># =&gt; tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span>
<span class="c">#    listening on enp0s8, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span>
<span class="c">#    12:42:13.504948 IP 192.168.10.10.55617 &amp;gt; 192.168.10.102.8472: OTV, flags [I] (0x08), overlay 0, instance 1</span>
<span class="c">#    IP 172.16.0.16.57692 &amp;gt; 172.16.1.8.80: Flags [S], seq 911277209, win 64860, options [mss 1410,sackOK,TS val 1681447926 ecr 0,nop,wscale 7], length 0</span>
<span class="c">#    ...</span>

<span class="c"># vethY는 각자 k3s-s 의 가장 마지막 veth 를 지정</span>
<span class="nv">$ </span>tcpdump <span class="nt">-i</span> vethY tcp port 8080 <span class="nt">-nn</span>
<span class="c"># =&gt; tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span>
<span class="c">#    listening on veth5ae3dd58, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span>
<span class="c">#    12:44:11.609334 IP 172.16.0.16.41240 &amp;gt; 172.16.2.9.8080: Flags [S], seq 1593288127, win 64860, options [mss 1410,sackOK,TS val 3487210526 ecr 0,nop,wscale 7], length 0</span>
<span class="c">#    12:44:11.610875 IP 172.16.2.9.8080 &amp;gt; 172.16.0.16.41240: Flags [S.], seq 1820942288, ack 1593288128, win 64308, options [mss 1410,sackOK,TS val 257720908 ecr 3487210526,nop,wscale 7], length 0</span>
<span class="nv">$ </span>tcpdump <span class="nt">-i</span> vethY tcp port 8080 <span class="nt">-w</span> /tmp/ingress-nginx.pcap

<span class="nt">---</span> 

<span class="c"># 다른 터미널에서 svc3-admin 접속</span>
<span class="nv">$ </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080/admin 

<span class="nt">---</span>

<span class="c"># 자신의 PC에서 k3s-s EC2 공인 IP로 pcap 다운로드</span>
<span class="c"># $ scp ubuntu@&lt;k3s-s EC2 공인 IP&gt;:/tmp/ingress-nginx.pcap ~/Downloads</span>
<span class="nv">$ </span>scp ubuntu@43.202.1.177:/tmp/ingress-nginx.pcap ~/Downloads
</code></pre></div></div>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_10.png" alt="20241012_kans_w6_10.png" class="image-center" loading="lazy" width="1304" height="701">
<em class="image-caption">인그레스를 통한 접속 흐름</em></p>

<ul>
  <li>패킷 캡쳐 결과 ingress controller에서 파드의 ip로 바로 접속 됨을 확인할 수 있었습니다.</li>
  <li>
    <p>또한, flannel CNI를 사용하기 때문에 vxlan을 통해 통신이 이루어지고 있음을 확인할 수 있습니다.</p>
  </li>
  <li>Nginx 파드가 endpoint 정보 등을 모니터링 가능한 이유는 클러스터롤과 롤(엔드포인트 list, watch)를 바인딩된 서비스 어카운트를 파드가 사용하기 때문입니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl describe deployments.apps <span class="nt">-n</span> ingress ingress-nginx-controller | <span class="nb">grep</span> <span class="s1">'Service Account'</span>
<span class="c"># =&gt;   Service Account:  ingress-nginx</span>

<span class="nv">$ </span>kubectl get <span class="nt">-n</span> ingress clusterrolebindings ingress-nginx
<span class="c"># =&gt; NAME            ROLE                        AGE</span>
<span class="c">#    ingress-nginx   ClusterRole/ingress-nginx   4h9m</span>

<span class="nv">$ </span>kubectl get <span class="nt">-n</span> ingress rolebindings ingress-nginx
<span class="c"># =&gt; NAME            ROLE                 AGE</span>
<span class="c">#    ingress-nginx   Role/ingress-nginx   4h9m</span>

<span class="nv">$ </span>kubectl describe clusterrole ingress <span class="nt">-n</span> ingress | egrep <span class="s1">'(Verbs|endpoints)'</span>
<span class="c"># =&gt;   Resources                           Non-Resource URLs  Resource Names  Verbs</span>
<span class="c">#      endpointslices.discovery.k8s.io     []                 []              [list watch get]</span>
<span class="c">#      endpoints                           []                 []              [list watch]</span>

<span class="nv">$ </span>kubectl describe roles ingress-nginx <span class="nt">-n</span> ingress | egrep <span class="s1">'(Verbs|endpoints)'</span>
<span class="c"># =&gt;   Resources                           Non-Resource URLs  Resource Names          Verbs</span>
<span class="c">#      endpoints                           []                 []                      [get list watch]</span>
<span class="c">#      endpointslices.discovery.k8s.io     []                 []                      [list watch get]</span>
</code></pre></div></div>

<h4 id="패킷-분석">패킷 분석</h4>

<ul>
  <li>클러스터 외부에서 접속 후 내부로 접속하는 패킷을 분석해보겠습니다.</li>
  <li>위의 실습과 동일하지만 veth에서 8080을 캡쳐하고 노드의 nic에서 8472 (vxnet)를 캡쳐하여 병합(merge)하여 확인하였습니다.</li>
  <li>또한, 클라이언트의 IP 주소를 확인하기 위해 X-Forwarded-For 헤더를 확인하였습니다.</li>
</ul>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_11.png" alt="20241012_kans_w6_11.png" loading="lazy" width="1379" height="1019"></p>

<ul>
  <li>위의 그림과 같이 프로토콜의 정보를 그림으로 보려면 아래와 같이 환경설정에서 Appearance &gt; Layout에서 Pane 3에 
“Packet Diagram”을 선택하시면 됩니다.
<img src="/assets/2024/kans-3th/w6/20241012_kans_w6_12.png" alt="20241012_kans_w6_12.png" class="w-80 image-center" loading="lazy" width="792" height="642">
</li>
</ul>

<h4 id="nginx-분산-알고리즘-변경">Nginx 분산 알고리즘 변경</h4>

<ul>
  <li>nginx는 기본 RR(Round Robin) 방식으로 부하분산을 수행하지만, IP-Hash나 Session Cookie 설정으로 변경할 수 있습니다.</li>
  <li>특히 IP-Hash 나 Session Cookie를 사용하면 각 클라이언트에서 대상 파드를 고정할 수 있습니다.</li>
  <li>이를 변경하기 위해서는 <code class="language-plaintext highlighter-rouge">nginx.ingress.kubernetes.io/upstream-hash-by</code> annotation을 사용하여 변경하여야 하는데 실습을 통해 확인해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># mypc</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080/admin | <span class="nb">grep </span>Hostname <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;   51 Hostname: deploy3-adminsrv-7c8f8b8c87-4sqmh</span>
<span class="c">#      49 Hostname: deploy3-adminsrv-7c8f8b8c87-4mzv7</span>
<span class="nv">$ </span><span class="k">while </span><span class="nb">true</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$MYIP</span>:30080/admin | <span class="nb">grep </span>Hostname <span class="p">;</span> <span class="nb">date</span> <span class="s2">"+%Y-%m-%d %H:%M:%S"</span> <span class="p">;</span> <span class="nb">echo</span> <span class="s2">"--------------"</span> <span class="p">;</span> <span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>

<span class="c"># 아래 ingress 설정 중 IP-Hash 설정 &gt; # 주석 제거</span>
<span class="nv">$ </span><span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/#nginx.ingress/nginx.ingress/g'</span> ingress1.yml
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> ingress1.yml
<span class="c"># =&gt; ingress.networking.k8s.io/ingress-1 configured</span>

<span class="c"># 접속 확인</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080/admin | <span class="nb">grep </span>Hostname <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;  100 Hostname: deploy3-adminsrv-7c8f8b8c87-4sqmh</span>
<span class="nv">$ </span><span class="k">while </span><span class="nb">true</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$MYIP</span>:30080/admin | <span class="nb">grep </span>Hostname <span class="p">;</span> <span class="nb">date</span> <span class="s2">"+%Y-%m-%d %H:%M:%S"</span> <span class="p">;</span> <span class="nb">echo</span> <span class="s2">"--------------"</span> <span class="p">;</span> <span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>

<span class="c"># 다시 원복(라운드 로빈) &gt; # 주석 추가</span>
<span class="nv">$ </span><span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/nginx.ingress/#nginx.ingress/g'</span> ingress1.yml
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> ingress1.yml
<span class="c"># =&gt; ingress.networking.k8s.io/ingress-1 configured</span>

<span class="c"># 접속 확인</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYIP</span>:30080/admin | <span class="nb">grep </span>Hostname <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;   50 Hostname: deploy3-adminsrv-7c8f8b8c87-4sqmh</span>
<span class="c">#      50 Hostname: deploy3-adminsrv-7c8f8b8c87-4mzv7</span>
<span class="nv">$ </span><span class="k">while </span><span class="nb">true</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$MYIP</span>:30080/admin | <span class="nb">grep </span>Hostname <span class="p">;</span> <span class="nb">date</span> <span class="s2">"+%Y-%m-%d %H:%M:%S"</span> <span class="p">;</span> <span class="nb">echo</span> <span class="s2">"--------------"</span> <span class="p">;</span> <span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<ul>
  <li>ip-hash 설정을 통해 클라이언트의 IP 주소를 해싱하여 특정 파드로 접속되는 것을 확인할 수 있습니다.</li>
  <li>오브젝트 삭제</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl delete deployments,svc,ingress <span class="nt">--all</span>
</code></pre></div></div>

<h4 id="host-기반-라우팅">Host 기반 라우팅</h4>

<ul>
  <li>ingress2.yml 파일 생성</li>
</ul>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">ingress-2</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ingressClassName</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">kans.com</span>
    <span class="na">http</span><span class="pi">:</span>
      <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/</span>
        <span class="na">pathType</span><span class="pi">:</span> <span class="s">Prefix</span>
        <span class="na">backend</span><span class="pi">:</span>
          <span class="na">service</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">svc3-admin</span>
            <span class="na">port</span><span class="pi">:</span>
              <span class="na">number</span><span class="pi">:</span> <span class="m">8080</span>
  <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s2">"</span><span class="s">*.kans.com"</span>
    <span class="na">http</span><span class="pi">:</span>
      <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/echo</span>
        <span class="na">pathType</span><span class="pi">:</span> <span class="s">Prefix</span>
        <span class="na">backend</span><span class="pi">:</span>
          <span class="na">service</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">svc3-admin</span>
            <span class="na">port</span><span class="pi">:</span>
              <span class="na">number</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div></div>

<ul>
  <li>ingress 정책 생성</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 터미널1</span>
<span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'kubectl get ingresses,svc,ep,pod -owide'</span>

<span class="c"># 도메인 변경</span>
<span class="c"># $ MYDOMAIN1=&lt;각자 자신의 닉네임의 도메인&gt; 예시) gasida.com</span>
<span class="nv">$ MYDOMAIN1</span><span class="o">=</span>sweetlittlebird.com
<span class="nv">$ </span><span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/kans.com/</span><span class="nv">$MYDOMAIN1</span><span class="s2">/g"</span> ingress2.yaml

<span class="c"># 생성</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> ingress2.yaml,svc3-pod.yaml
<span class="c"># =&gt; ingress.networking.k8s.io/ingress-2 created</span>
<span class="c">#    deployment.apps/deploy3-adminsrv created</span>
<span class="c">#    service/svc3-admin created</span>

<span class="c"># 확인</span>
<span class="nv">$ </span>kubectl get ingress
<span class="c"># =&gt; NAME        CLASS   HOSTS                                       ADDRESS         PORTS   AGE</span>
<span class="c">#    ingress-2   nginx   sweetlittlebird.com,*.sweetlittlebird.com   10.10.200.113   80      14s</span>
<span class="nv">$ </span>kubectl describe ingress ingress-2
<span class="nv">$ </span>kubectl describe ingress ingress-2 | <span class="nb">sed</span> <span class="nt">-n</span> <span class="s2">"5, </span><span class="se">\$</span><span class="s2">p"</span>
<span class="c"># =&gt; ...</span>
<span class="c">#    Default backend:  &amp;lt;default&amp;gt;</span>
<span class="c">#    Rules:</span>
<span class="c">#      Host                   Path    Backends</span>
<span class="c">#      ----                   ----    --------</span>
<span class="c">#      sweetlittlebird.com    /       svc3-admin:8080 ()</span>
<span class="c">#      *.sweetlittlebird.com  /echo   svc3-admin:8080 ()</span>
<span class="c">#    ...</span>
</code></pre></div></div>

<ul>
  <li>Host 기반 라우팅을 통해 서비스에 접속해보겠습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 로그 모니터링</span>
<span class="nv">$ </span>kubetail <span class="nt">-n</span> ingress <span class="nt">-l</span> app.kubernetes.io/component<span class="o">=</span>controller
<span class="c"># =&gt; Will tail 1 logs...</span>
<span class="c">#    ingress-nginx-controller-7b67846f8f-jdt65</span>
<span class="c"># =&gt; [ingress-nginx-controller-7b67846f8f-jdt65] 192.168.10.1 - - [01/Jan/2024:13:52:42 +0000] &amp;quot;GET / HTTP/1.1&amp;quot; 200 677 &amp;quot;-&amp;quot; &amp;quot;curl/8.5.0&amp;quot; 88 0.002 [default-svc3-admin-8080] [] 172.16.3.10:8080 852 0.002 200 f22ddba305f55138796fc866f7416890</span>
<span class="c">#    [ingress-nginx-controller-7b67846f8f-jdt65] 192.168.10.1 - - [01/Jan/2024:13:53:47 +0000] &amp;quot;GET /admin HTTP/1.1&amp;quot; 200 687 &amp;quot;-&amp;quot; &amp;quot;curl/8.5.0&amp;quot; 93 0.002 [default-svc3-admin-8080] [] 172.16.2.10:8080 863 0.002 200 966f7a55060f1497eed20818d4bef890</span>
<span class="c">#    ...</span>

<span class="nt">------------</span>
<span class="c"># 자신의 PC 에서 접속 테스트</span>
<span class="c"># svc3-admin 접속 &gt; 결과 확인 : 왜 접속이 되지 않는가? HTTP 헤더에 Host 필드를 잘 확인해보자!</span>
<span class="nv">$ </span>curl <span class="nv">$MYIP</span>:30080 <span class="nt">-v</span>
<span class="nv">$ </span>curl <span class="nv">$MYIP</span>:30080/echo <span class="nt">-v</span>

<span class="c"># mypc에서 접속을 위한 설정</span>
<span class="c">## /etc/hosts 수정 : 도메인 이름으로 접속하기 위해서 변수 지정</span>
<span class="c">## 윈도우 C:\Windows\System32\drivers\etc\hosts</span>
<span class="c">## 맥 sudo vim /etc/hosts</span>
<span class="c"># $ MYDOMAIN1=&lt;각자 자신의 닉네임의 도메인&gt;</span>
<span class="c"># $ MYDOMAIN2=&lt;test.각자 자신의 닉네임의 도메인&gt;</span>
<span class="nv">$ MYDOMAIN1</span><span class="o">=</span>sweetlittlebird.com
<span class="nv">$ MYDOMAIN2</span><span class="o">=</span>test.sweetlittlebird.com
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$MYIP</span> <span class="nv">$MYDOMAIN1</span> <span class="nv">$MYDOMAIN2</span>
<span class="c"># =&gt; 192.168.10.10 sweetlittlebird.com test.sweetlittlebird.com</span>

<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$MYIP</span><span class="s2"> </span><span class="nv">$MYDOMAIN1</span><span class="s2">"</span> | <span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/hosts
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$MYIP</span><span class="s2"> </span><span class="nv">$MYDOMAIN2</span><span class="s2">"</span> | <span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/hosts
<span class="nv">$ </span><span class="nb">cat</span> /etc/hosts | <span class="nb">grep</span> <span class="nv">$MYDOMAIN1</span>
<span class="c"># =&gt; 192.168.10.10 sweetlittlebird.com</span>
<span class="c">#    192.168.10.10 test.sweetlittlebird.com</span>

<span class="c"># svc3-admin 접속 &gt; 결과 확인</span>
<span class="nv">$ </span>curl <span class="nv">$MYDOMAIN1</span>:30080 <span class="nt">-v</span>
<span class="c"># =&gt; * Host sweetlittlebird.com:30080 was resolved.</span>
<span class="c">#    * IPv4: 192.168.10.10</span>
<span class="c">#    *   Trying 192.168.10.10:30080...</span>
<span class="c">#    * Connected to sweetlittlebird.com (192.168.10.10) port 30080</span>
<span class="c">#    &amp;gt; GET / HTTP/1.1</span>
<span class="c">#    &amp;gt; Host: sweetlittlebird.com:30080</span>
<span class="c">#    &amp;gt; User-Agent: curl/8.5.0</span>
<span class="c">#    &amp;gt; Accept: */*</span>
<span class="c">#    &amp;gt;</span>
<span class="c">#    &amp;lt; HTTP/1.1 200 OK</span>
<span class="c">#    &amp;lt; Date: Sat, 01 Jan 2024 13:52:42 GMT</span>
<span class="c">#    &amp;lt; Content-Type: text/plain</span>
<span class="c">#    &amp;lt; Transfer-Encoding: chunked</span>
<span class="c">#    &amp;lt; Connection: keep-alive</span>
<span class="c">#    &amp;lt;</span>
<span class="c">#    </span>
<span class="c">#    Hostname: deploy3-adminsrv-7c8f8b8c87-48xwp</span>
<span class="c">#    </span>
<span class="c">#    Pod Information:</span>
<span class="c">#            -no pod information available-</span>
<span class="c">#    </span>
<span class="c">#    Server values:</span>
<span class="c">#            server_version=nginx: 1.13.0 - lua: 10008</span>
<span class="c">#    </span>
<span class="c">#    Request Information:</span>
<span class="c">#            client_address=172.16.0.16</span>
<span class="c">#            method=GET</span>
<span class="c">#            real path=/</span>
<span class="c">#            query=</span>
<span class="c">#            request_version=1.1</span>
<span class="c">#            request_uri=http://sweetlittlebird.com:8080/</span>
<span class="c">#    </span>
<span class="c">#    Request Headers:</span>
<span class="c">#            accept=*/*</span>
<span class="c">#            host=sweetlittlebird.com:30080</span>
<span class="c">#            user-agent=curl/8.5.0</span>
<span class="c">#            x-forwarded-for=192.168.10.1</span>
<span class="c">#            x-forwarded-host=sweetlittlebird.com:30080</span>
<span class="c">#            x-forwarded-port=80</span>
<span class="c">#            x-forwarded-proto=http</span>
<span class="c">#            ...</span>
<span class="nv">$ </span>curl <span class="nv">$MYDOMAIN1</span>:30080/admin
<span class="c"># =&gt; </span>
<span class="c">#    </span>
<span class="c">#    Hostname: deploy3-adminsrv-7c8f8b8c87-bm7dq</span>
<span class="c">#            ...</span>
<span class="c">#            client_address=172.16.0.16</span>
<span class="c">#            method=GET</span>
<span class="c">#            real path=/admin</span>
<span class="c">#            ...</span>
<span class="c">#            request_uri=http://sweetlittlebird.com:8080/admin</span>
<span class="c">#    </span>
<span class="c">#    Request Headers:</span>
<span class="c">#            accept=*/*</span>
<span class="c">#            host=sweetlittlebird.com:30080</span>
<span class="c">#            user-agent=curl/8.5.0</span>
<span class="c">#            x-forwarded-for=192.168.10.1</span>
<span class="c">#            x-forwarded-host=sweetlittlebird.com:30080</span>
<span class="c">#            x-forwarded-port=80</span>
<span class="c">#            x-forwarded-proto=http</span>
<span class="c">#            x-forwarded-scheme=http</span>
<span class="c">#            ...</span>
<span class="nv">$ </span>curl <span class="nv">$MYDOMAIN1</span>:30080/echo
<span class="c"># =&gt; Hostname: deploy3-adminsrv-7c8f8b8c87-ndwkj</span>
<span class="c">#            ...</span>
<span class="c">#            client_address=172.16.0.16</span>
<span class="c">#            method=GET</span>
<span class="c">#            real path=/echo</span>
<span class="c">#            ...</span>
<span class="c">#            request_uri=http://sweetlittlebird.com:8080/echo</span>
<span class="c">#    </span>
<span class="c">#    Request Headers:</span>
<span class="c">#            accept=*/*</span>
<span class="c">#            host=sweetlittlebird.com:30080</span>
<span class="c">#            user-agent=curl/8.5.0</span>
<span class="c">#            x-forwarded-for=192.168.10.1</span>
<span class="c">#            x-forwarded-host=sweetlittlebird.com:30080</span>
<span class="c">#            x-forwarded-port=80</span>
<span class="c">#            x-forwarded-proto=http</span>
<span class="c">#            x-forwarded-scheme=http</span>
<span class="c">#            ...    </span>
<span class="nv">$ </span>curl <span class="nv">$MYDOMAIN1</span>:30080/echo/1
<span class="c"># =&gt; Hostname: deploy3-adminsrv-7c8f8b8c87-48xwp</span>
<span class="c">#    </span>
<span class="c">#    Pod Information:</span>
<span class="c">#            -no pod information available-</span>
<span class="c">#    </span>
<span class="c">#    Server values:</span>
<span class="c">#            server_version=nginx: 1.13.0 - lua: 10008</span>
<span class="c">#    </span>
<span class="c">#    Request Information:</span>
<span class="c">#            client_address=172.16.0.16</span>
<span class="c">#            method=GET</span>
<span class="c">#            real path=/echo/1</span>
<span class="c">#            query=</span>
<span class="c">#            request_version=1.1</span>
<span class="c">#            request_uri=http://sweetlittlebird.com:8080/echo/1</span>
<span class="c">#            ...</span>

<span class="nv">$ </span>curl <span class="nv">$MYDOMAIN2</span>:30080 <span class="nt">-v</span>
<span class="c"># =&gt; * Host test.sweetlittlebird.com:30080 was resolved.</span>
<span class="c">#    * IPv4: 192.168.10.10</span>
<span class="c">#    *   Trying 192.168.10.10:30080...</span>
<span class="c">#    * Connected to test.sweetlittlebird.com (192.168.10.10) port 30080</span>
<span class="c">#    &amp;gt; GET / HTTP/1.1</span>
<span class="c">#    &amp;gt; Host: test.sweetlittlebird.com:30080</span>
<span class="c">#    ...</span>
<span class="c">#    &amp;lt; HTTP/1.1 404 Not Found</span>
<span class="c">#    ...</span>
<span class="nv">$ </span>curl <span class="nv">$MYDOMAIN2</span>:30080/admin
<span class="c"># =&gt; &amp;lt;html&amp;gt;</span>
<span class="c">#    &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;404 Not Found&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;</span>
<span class="c">#    &amp;lt;body&amp;gt;</span>
<span class="c">#    &amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;404 Not Found&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;</span>
<span class="c">#    &amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx&amp;lt;/center&amp;gt;</span>
<span class="c">#    &amp;lt;/body&amp;gt;</span>
<span class="c">#    &amp;lt;/html&amp;gt;</span>
<span class="nv">$ </span>curl <span class="nv">$MYDOMAIN2</span>:30080/echo
<span class="c"># =&gt; Hostname: deploy3-adminsrv-7c8f8b8c87-ndwkj</span>
<span class="c">#    </span>
<span class="c">#    Pod Information:</span>
<span class="c">#            -no pod information available-</span>
<span class="c">#    </span>
<span class="c">#    Server values:</span>
<span class="c">#            server_version=nginx: 1.13.0 - lua: 10008</span>
<span class="c">#    </span>
<span class="c">#    Request Information:</span>
<span class="c">#            client_address=172.16.0.16</span>
<span class="c">#            method=GET</span>
<span class="c">#            real path=/echo</span>
<span class="c">#            ...</span>
<span class="c">#            request_uri=http://test.sweetlittlebird.com:8080/echo</span>
<span class="c">#    </span>
<span class="c">#    Request Headers:</span>
<span class="c">#            accept=*/*</span>
<span class="c">#            host=test.sweetlittlebird.com:30080</span>
<span class="c">#            user-agent=curl/8.5.0</span>
<span class="c">#            x-forwarded-for=192.168.10.1</span>
<span class="c">#            x-forwarded-host=test.sweetlittlebird.com:30080</span>
<span class="c">#            x-forwarded-port=80</span>
<span class="c">#            x-forwarded-proto=http</span>
<span class="c">#            x-forwarded-scheme=http</span>
<span class="c">#            ...</span>
<span class="nv">$ </span>curl <span class="nv">$MYDOMAIN2</span>:30080/echo/1
<span class="nv">$ </span>curl <span class="nv">$MYDOMAIN2</span>:30080/echo/1/2

<span class="c">## (옵션) /etc/hosts 파일 변경 없이 접속 방안</span>
<span class="nv">$ </span>curl <span class="nt">-H</span> <span class="s2">"host: </span><span class="nv">$MYDOMAIN1</span><span class="s2">"</span> <span class="nv">$MYIP</span>:30080
<span class="c"># =&gt; (정상)</span>
<span class="nv">$ </span>curl <span class="nt">-H</span> <span class="s2">"host: </span><span class="nv">$MYDOMAIN2</span><span class="s2">"</span> <span class="nv">$MYIP</span>:30080
<span class="c"># =&gt; (404 에러)</span>
<span class="nv">$ </span>curl <span class="nt">-H</span> <span class="s2">"host: </span><span class="nv">$MYDOMAIN2</span><span class="s2">"</span> <span class="nv">$MYIP</span>:30080/echo
<span class="c"># =&gt; (정상 응답 옴)</span>
</code></pre></div></div>

<ul>
  <li>실습결과 sweetlittlebird.com으로는 모든 응답이 200 OK 응답이 오고,
test.sweetlittlebird.com으로 접속시에는 /echo 경로로 접속해야만 200 OK 응답이 오고, 그 외의 경로로 접속시에는 404 에러가 발생하는 것을 확인할 수 있습니다.</li>
  <li>아래의 룰대로 잘 접속이 되는 것을 확인할 수 있습니다.
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># sweetlittlebird.com이라는 호스트로 접속시 모든 경로에 대해서 200 OK 응답</span>
sweetlittlebird.com    /       svc3-admin:8080   
  
<span class="c"># test.sweetlittlebird.com 처럼 서브 도메인이 있는 호스트명으로 접속시 /echo 경로로만 200 OK 응답</span>
<span class="k">*</span>.sweetlittlebird.com  /echo   svc3-admin:8080   
</code></pre></div>    </div>
  </li>
  <li>오브젝트 삭제
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl delete deployments,svc,ingress <span class="nt">--all</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="카나리-업데이트">카나리 업데이트</h4>

<ul>
  <li>카나리 업데이트는 새로운 버전의 파드를  배포하고, 일부 트래픽만 새로운 버전으로 전환하고, 새로운 버전의 정상동작 확인 후 전체를 새로운 버전으로 전환하는 업데이트 방식입니다.</li>
  <li>배포 자동화시 최소 중단/무중단으로 하는 방법을 몇가지 살펴보겠습니다.
    <ol>
      <li>롤링 업데이트
  <img src="/assets/2024/kans-3th/w6/20241012_kans_w6_13.png" alt="img.png" class="w-80 image-center" loading="lazy" width="771" height="216">
        <ul>
          <li>파드를 하나씩 새로운 버전으로 교체하는 방식으로, 기존 버전의 파드가 정상동작하는지 확인 후 다음 파드로 교체하는 방식입니다.</li>
        </ul>
      </li>
      <li>카나리 업데이트
  <img src="/assets/2024/kans-3th/w6/20241012_kans_w6_14.png" alt="img_1.png" class="w-80 image-center" loading="lazy" width="771" height="216">
        <ul>
          <li>일부 트래픽을 새로운 버전으로 전환하고, 정상동작 확인 후 전체로 전환하는 방식입니다.</li>
        </ul>
      </li>
      <li>블루/그린 업데이트
  <img src="/assets/2024/kans-3th/w6/20241012_kans_w6_15.png" alt="img_2.png" class="w-80 image-center" loading="lazy" width="860" height="184">
        <ul>
          <li>새로운 버전의 파드를 새로운 서비스로 배포하고, 모든 파드 배포 후, 하나씩 전환하는 롤링 업데이트와는 다르게 전체 트래픽을 한꺼번에 새로운 서비스로 전환하는 방식입니다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>실습을 통해 nginx ingress controller를 이용한 카나리 업데이트를 진행해보겠습니다.
    <ul>
      <li>
        <p>canary-svc1-pod.yml 파일 생성</p>

        <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">dp-v1</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">svc-v1</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">svc-v1</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">pod-v1</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">k8s.gcr.io/echoserver:1.5</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
      <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">0</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">svc-v1</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web-port</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">9001</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="m">8080</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">svc-v1</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>canary-svc2-pod.yml 파일 생성</p>

        <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">dp-v2</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">svc-v2</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">svc-v2</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">pod-v2</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">k8s.gcr.io/echoserver:1.6</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
      <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">0</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">svc-v2</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web-port</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">9001</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="m">8080</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">svc-v2</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>생성 및 확인</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 터미널1</span>
<span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'kubectl get ingress,svc,ep,pod -owide'</span>
    
<span class="c"># 생성</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> canary-svc1-pod.yml,canary-svc2-pod.yml
<span class="c"># =&gt; deployment.apps/dp-v1 created</span>
<span class="c">#    service/svc-v1 created</span>
<span class="c">#    deployment.apps/dp-v2 created</span>
<span class="c">#    service/svc-v2 created</span>
    
<span class="c"># 확인</span>
<span class="nv">$ </span>kubectl get svc,ep,pod
<span class="c"># =&gt; NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span>
<span class="c">#    service/kubernetes   ClusterIP   10.10.200.1     &amp;lt;none&amp;gt;        443/TCP    12m</span>
<span class="c">#    service/svc-v1       ClusterIP   10.10.200.231   &amp;lt;none&amp;gt;        9001/TCP   18s</span>
<span class="c">#    service/svc-v2       ClusterIP   10.10.200.216   &amp;lt;none&amp;gt;        9001/TCP   18s</span>
<span class="c">#    </span>
<span class="c">#    NAME                   ENDPOINTS                                            AGE</span>
<span class="c">#    endpoints/kubernetes   192.168.10.10:6443                                   12m</span>
<span class="c">#    endpoints/svc-v1       172.16.1.10:8080,172.16.2.12:8080,172.16.3.11:8080   18s</span>
<span class="c">#    endpoints/svc-v2       172.16.1.11:8080,172.16.2.11:8080,172.16.3.12:8080   18s</span>
<span class="c">#    </span>
<span class="c">#    NAME                         READY   STATUS    RESTARTS   AGE</span>
<span class="c">#    pod/dp-v1-8684d45558-22nbv   1/1     Running   0          18s</span>
<span class="c">#    pod/dp-v1-8684d45558-59pnl   1/1     Running   0          18s</span>
<span class="c">#    pod/dp-v1-8684d45558-87xrs   1/1     Running   0          18s</span>
<span class="c">#    pod/dp-v2-7757c4bdc-5xmcm    1/1     Running   0          18s</span>
<span class="c">#    pod/dp-v2-7757c4bdc-bm2gq    1/1     Running   0          18s</span>
<span class="c">#    pod/dp-v2-7757c4bdc-h7fzl    1/1     Running   0          18s</span>
    
<span class="c"># 파드 버전 확인: 1.13.0 vs 1.13.1</span>
<span class="nv">$ </span><span class="k">for </span>pod <span class="k">in</span> <span class="si">$(</span>kubectl get pod <span class="nt">-o</span> wide <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>svc-v1 |awk <span class="s1">'NR&gt;1 {print $6}'</span><span class="si">)</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$pod</span>:8080 | egrep <span class="s1">'(Hostname|nginx)'</span><span class="p">;</span> <span class="k">done</span>
<span class="c"># =&gt; Hostname: dp-v1-8684d45558-22nbv</span>
<span class="c">#     server_version=nginx: 1.13.0 - lua: 10008</span>
<span class="c">#    ...</span>
<span class="nv">$ </span><span class="k">for </span>pod <span class="k">in</span> <span class="si">$(</span>kubectl get pod <span class="nt">-o</span> wide <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>svc-v2 |awk <span class="s1">'NR&gt;1 {print $6}'</span><span class="si">)</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$pod</span>:8080 | egrep <span class="s1">'(Hostname|nginx)'</span><span class="p">;</span> <span class="k">done</span>
<span class="c"># =&gt; Hostname: dp-v2-7757c4bdc-5xmcm</span>
<span class="c">#     server_version=nginx: 1.13.1 - lua: 10008</span>
<span class="c">#    ...		</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>canary-ingress1.yml</p>

        <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">ingress-canary-v1</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ingressClassName</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">kans.com</span>
    <span class="na">http</span><span class="pi">:</span>
      <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/</span>
        <span class="na">pathType</span><span class="pi">:</span> <span class="s">Prefix</span>
        <span class="na">backend</span><span class="pi">:</span>
          <span class="na">service</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">svc-v1</span>
            <span class="na">port</span><span class="pi">:</span>
              <span class="na">number</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>canary-ingress2.yml</p>

        <div class="language-yaml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">ingress-canary-v2</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">nginx.ingress.kubernetes.io/canary</span><span class="pi">:</span> <span class="s2">"</span><span class="s">true"</span>
    <span class="na">nginx.ingress.kubernetes.io/canary-weight</span><span class="pi">:</span> <span class="s2">"</span><span class="s">10"</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ingressClassName</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">kans.com</span>
    <span class="na">http</span><span class="pi">:</span>
      <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/</span>
        <span class="na">pathType</span><span class="pi">:</span> <span class="s">Prefix</span>
        <span class="na">backend</span><span class="pi">:</span>
          <span class="na">service</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">svc-v2</span>
            <span class="na">port</span><span class="pi">:</span>
              <span class="na">number</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>카나리 업그레이드 확인</p>
        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c"># 터미널1</span>
<span class="nv">$ </span>watch <span class="nt">-d</span> <span class="s1">'kubectl get ingress,svc,ep'</span>
    
<span class="c"># 도메인 변경</span>
<span class="c"># $ MYDOMAIN1=&lt;각자 자신의 닉네임의 도메인&gt; 예시) gasida.com</span>
<span class="nv">$ MYDOMAIN1</span><span class="o">=</span>sweetlittlebird.com
<span class="nv">$ </span><span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/kans.com/</span><span class="nv">$MYDOMAIN1</span><span class="s2">/g"</span> canary-ingress1.yml
<span class="nv">$ </span><span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/kans.com/</span><span class="nv">$MYDOMAIN1</span><span class="s2">/g"</span> canary-ingress2.yml
    
<span class="c"># 생성</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> canary-ingress1.yml,canary-ingress2.yml
<span class="c"># =&gt; ingress.networking.k8s.io/ingress-canary-v1 created</span>
<span class="c">#    ingress.networking.k8s.io/ingress-canary-v2 created</span>
    
<span class="c"># 로그 모니터링</span>
<span class="nv">$ </span>kubetail <span class="nt">-n</span> ingress <span class="nt">-l</span> app.kubernetes.io/component<span class="o">=</span>controller
    
<span class="c"># 접속 테스트</span>
<span class="nv">$ </span>curl <span class="nt">-s</span> <span class="nv">$MYDOMAIN1</span>:30080
<span class="nv">$ </span>curl <span class="nt">-s</span> <span class="nv">$MYDOMAIN1</span>:30080 | <span class="nb">grep </span>nginx
<span class="c"># =&gt; &amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx&amp;lt;/center&amp;gt;</span>
    
<span class="c"># 접속 시 v1 v2 버전별 비율이 어떻게 되나요? 왜 이렇게 되나요?</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span>  <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYDOMAIN1</span>:30080 | <span class="nb">grep </span>nginx <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;      84         server_version=nginx: 1.13.0 - lua: 10008</span>
<span class="c">#         16         server_version=nginx: 1.13.1 - lua: 10008</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..1000<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYDOMAIN1</span>:30080 | <span class="nb">grep </span>nginx <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;     919         server_version=nginx: 1.13.0 - lua: 10008</span>
<span class="c">#         81         server_version=nginx: 1.13.1 - lua: 10008</span>
<span class="nv">$ </span><span class="k">while </span><span class="nb">true</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nt">--connect-timeout</span> 1 <span class="nv">$MYDOMAIN1</span>:30080 | <span class="nb">grep </span>Hostname <span class="p">;</span> <span class="nb">echo</span> <span class="s2">"--------------"</span> <span class="p">;</span> <span class="nb">date</span> <span class="s2">"+%Y-%m-%d %H:%M:%S"</span> <span class="p">;</span> <span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>
<span class="c"># &lt;span style="color: green;"&gt;👉 v2의 canary 비율을 10%로 두어서 그렇습니다.&lt;/span&gt;</span>
    
<span class="c"># 비율 조정하여 절반을 v2로 전환하겠습니다. &gt;&gt; 개발 배포 버전 전략에 유용하다!</span>
<span class="nv">$ </span>kubectl annotate <span class="nt">--overwrite</span> ingress ingress-canary-v2 nginx.ingress.kubernetes.io/canary-weight<span class="o">=</span>50
    
<span class="c"># 접속 테스트</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span>  <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYDOMAIN1</span>:30080 | <span class="nb">grep </span>nginx <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;      53         server_version=nginx: 1.13.1 - lua: 10008</span>
<span class="c">#         47         server_version=nginx: 1.13.0 - lua: 10008</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..1000<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYDOMAIN1</span>:30080 | <span class="nb">grep </span>nginx <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;     526         server_version=nginx: 1.13.1 - lua: 10008</span>
<span class="c">#        474         server_version=nginx: 1.13.0 - lua: 10008</span>
        
<span class="c"># (옵션) 비율 조정 &lt;&lt; 어떻게 비율이 조정될까요?</span>
<span class="nv">$ </span>kubectl annotate <span class="nt">--overwrite</span> ingress ingress-canary-v2 nginx.ingress.kubernetes.io/canary-weight<span class="o">=</span>100
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span>  <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYDOMAIN1</span>:30080 | <span class="nb">grep </span>nginx <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;    100         server_version=nginx: 1.13.1 - lua: 10008</span>
<span class="c"># &lt;span style="color: green;"&gt;👉 카나리 비율을 100%로 하니 v2버전으로 100% 전환 되었습니다.&lt;/span&gt;</span>
    
<span class="c"># (옵션) 비율 조정 &lt;&lt; 어떻게 비율이 조정될까요?</span>
<span class="nv">$ </span>kubectl annotate <span class="nt">--overwrite</span> ingress ingress-canary-v2 nginx.ingress.kubernetes.io/canary-weight<span class="o">=</span>0
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span>  <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$MYDOMAIN1</span>:30080 | <span class="nb">grep </span>nginx <span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;     100         server_version=nginx: 1.13.0 - lua: 10008</span>
<span class="c"># &lt;span style="color: green;"&gt;👉 카나리 비율을 0%로 하니 v2버전으로 0% 로 전환 되고 모든 트래픽이 v1으로 전달되었습니다.&lt;/span&gt;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>오브젝트 삭제
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl delete deployments,svc,ingress <span class="nt">--all</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr>

<h2 id="gateway-api">Gateway API</h2>

<h3 id="gateway-api-소개">Gateway API 소개</h3>

<p>앞서 Ingress를 살펴볼때 말씀드린것 처럼 Ingress는 Frozen 되어서 더이상 업데이트 되지 않고, Gateway API에 기능을 추가할 계획이라고 합니다.
이어서 Gateway API에 대해 알아보겠습니다.</p>

<p>Gateway API는 Kubernetes에서 API Gateway를 정의하고 구성하기 위한 API를 제공하는 프로젝트입니다. <a href="https://medium.com/@disha.20.10/introduction-to-the-gateway-api-revolutionizing-kubernetes-networking-7b0c9a696038">Gateway API 소개</a>
Gateway API는 서비스 메시(예) istio 등)에서 제공하는 풍부한 기능 중 일부 기능들과 운영 관리에 필요한 기능들을 추가하였습니다.
추가된 기능의 예로는 헤더 기반 라우팅, 헤더 변조, 트래픽 미러링(쉽게 트래픽 복제), 역할 기반 접근 제어 등이 있습니다.</p>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_16.png" alt="img.png" class="w-80 image-center" loading="lazy" width="1408" height="843"></p>

<p>Gateway API는 이를 통해 동적 인프라 구성을 지원하고, 고급 트래픽 라우팅을 지원합니다.</p>

<ul>
  <li>Gateway API의 주요 기능은 다음과 같습니다.
    <ol>
      <li>
        <dl>
          <dt><strong>개선된 리소스 모델</strong></dt>
          <dd>API는 GatewayClass, Gateway 및 Route(HTTPRoute, TCPRoute 등)와 같은 새로운 사용자 정의 리소스를 도입하여 라우팅 규칙을 정의하는 보다 세부적이고 표현력 있는 방법을 제공합니다.</dd>
        </dl>
      </li>
      <li>
        <dl>
          <dt><strong>프로토콜 독립적</strong></dt>
          <dd>주로 HTTP용으로 설계된 Ingress와 달리 Gateway API는 TCP, UDP, TLS를 포함한 여러 프로토콜을 지원합니다.</dd>
        </dl>
      </li>
      <li>
        <dl>
          <dt><strong>강화된 보안</strong></dt>
          <dd>TLS 구성 및 보다 세부적인 액세스 제어에 대한 기본 제공 지원.</dd>
        </dl>
      </li>
      <li>
        <dl>
          <dt><strong>교차 네임스페이스 지원</strong></dt>
          <dd>서로 다른 네임스페이스의 서비스로 트래픽을 라우팅하여 보다 유연한 아키텍처를 구축할 수 있는 기능을 제공합니다.</dd>
        </dl>
      </li>
      <li>
        <dl>
          <dt><strong>확장성</strong></dt>
          <dd>API는 사용자 정의 리소스 및 정책으로 쉽게 확장할 수 있도록 설계되었습니다.</dd>
        </dl>
      </li>
      <li>
        <dl>
          <dt><strong>역할 지향</strong></dt>
          <dd>클러스터 운영자, 애플리케이션 개발자, 보안 팀 간의 우려를 명확하게 분리합니다.</dd>
        </dl>
      </li>
    </ol>
  </li>
  <li>다음의 구성요소 (Resource)를 가집니다.
    <ul>
      <li>GatewayClass, Gateway, HTTPRoute, TCPRoute, Service
<img src="/assets/2024/kans-3th/w6/20241012_kans_w6_17.png" alt="img.png" loading="lazy" width="466" height="130">
        <ul>
          <li>
<strong>GatewayClass:</strong> 공통 구성을 가진 게이트웨이 세트를 정의하고 클래스를 구현하는 컨트롤러에 의해 관리됩니다.</li>
          <li>
<strong>Gateway:</strong> 클라우드 로드 밸런서와 같은 트래픽 처리 인프라의 인스턴스를 정의합니다.</li>
          <li>
<strong>HTTPRoute:</strong> Gateway 리스너에서 백엔드 네트워크 엔드포인트의 표현으로 트래픽을 매핑하기 위한 HTTP 전용 규칙을 정의합니다. 이러한 엔드포인트는 종종 <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a>로 표현됩니다<br>
<img src="/assets/2024/kans-3th/w6/20241012_kans_w6_18.png" alt="img.png" class="image-center" loading="lazy" width="2048" height="1203">
<em class="image-caption">출처 : <a href="https://gateway-api.sigs.k8s.io/">https://gateway-api.sigs.k8s.io/</a></em>
</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>리퀘스트 흐름
<img src="/assets/2024/kans-3th/w6/20241012_kans_w6_19.svg" alt="20241012_kans_w6_19.svg" loading="lazy" width="821" height="113">
</li>
  <li>role-oriented  API 가 중요한 이유
    <ul>
      <li>담당 업무의 역할에 따라서 동작/권한을 유연하게 제공할 수 있습니다.</li>
      <li>아래 그림 처럼 ‘스토어 개발자’는 Store 네임스페이스내에서 해당 store PATH 라우팅 관련 정책을 스스로 관리 할 수 있습니다.
<img src="/assets/2024/kans-3th/w6/20241012_kans_w6_20.png" alt="img.png" loading="lazy" width="2048" height="1137">
</li>
      <li>역할의 예시입니다.
        <ul>
          <li>
<strong>인프라 제공자:</strong> 여러 격리된 클러스터가 여러 테넌트를 서비스할 수 있도록 인프라를 관리합니다. 예: 클라우드 제공자.</li>
          <li>
<strong>클러스터 운영자:</strong> 클러스터를 관리하며 주로 정책, 네트워크 접근, 애플리케이션 권한 등을 관리합니다.</li>
          <li>
<strong>애플리케이션 개발자:</strong> 클러스터에서 실행되는 애플리케이션을 관리하며 주로 애플리케이션 수준의 구성 및 <a href="https://kubernetes.io/docs/concepts/services-networking/service/">서비스</a> 구성에 관심이 있습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>추천글
    <ul>
      <li><a href="https://www.anyflow.net/sw-engineer/kubernetes-gateway-api-1">Ingress + API Gateway = Kubernetes Gateway API</a></li>
      <li><a href="https://www.anyflow.net/sw-engineer/kubernetes-gateway-api-2">API Gateway + Service Mesh = Kubernetes Gateway API</a></li>
    </ul>
  </li>
</ul>

<h3 id="gloo-gateway">Gloo Gateway</h3>

<p>Gloo Gateway는 Solo.io에서 개발한 API Gateway로, Gateway API를 구현한 대표적인 제품 중 하나입니다. 
Gloo Gateway는 다양한 환경에서 사용할 수 있도록 설계되어 있으며, 다음과 같은 특징을 가지고 있습니다.</p>

<ul>
  <li>
<strong>Envoy Proxy 기반</strong> : Gloo Gateway는 고성능의 Envoy Proxy를 기반으로 하여 뛰어난 확장성과 성능을 제공합니다.</li>
  <li>
<strong>API 관리 및 라우팅</strong> : 다양한 API 라우팅 옵션을 제공하며, REST, gRPC, GraphQL 등의 다양한 프로토콜을 지원합니다. 이를 통해 복잡한 트래픽 관리와 라우팅이 가능합니다.</li>
  <li>
<strong>보안 기능</strong> : 인증, 인가, TLS 암호화, OAuth, OpenID Connect 등 다양한 보안 기능을 제공합니다. 이를 통해 API를 안전하게 보호할 수 있습니다.</li>
  <li>
<strong>확장성</strong> : 플러그인 아키텍처를 통해 쉽게 확장할 수 있으며, 다양한 서드파티 통합을 지원합니다. 필요에 따라 기능을 확장하거나 사용자 정의 기능을 추가할 수 있습니다.</li>
  <li>
<strong>서비스 디스커버리</strong> : Kubernetes, Consul, EC2 등 다양한 서비스 디스커버리 메커니즘을 지원하여 동적 환경에서도 효율적으로 작동합니다.</li>
  <li>
<strong>Observability</strong> : 트래픽 모니터링, 로깅, 트레이싱 등의 기능을 제공하여 운영 중인 시스템의 상태를 쉽게 파악하고 문제를 해결할 수 있습니다.</li>
  <li>
<strong>유연한</strong> 배포 : 클라우드, 온프레미스, 하이브리드 환경 등 다양한 배포 옵션을 지원합니다. 이를 통해 다양한 인프라 환경에 맞춰 유연하게 배포할 수 있습니다.</li>
</ul>

<h4 id="gloo-gateway-architecture">Gloo Gateway Architecture</h4>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_21.png" alt="img.png" loading="lazy" width="2048" height="973"></p>

<ul>
  <li>Envoy를 통해서 Http의 L7 라우팅을 지원하며, Gloo의 역할은 라우팅 규칙을 관리하고 Envoy에 전달하는 역할을 합니다.</li>
</ul>

<p>Gloo Gateway는 내용이 방대하기 때문에 아래의 링크들로 설명을 대체하겠습니다.</p>

<ul>
  <li><a href="https://www.solo.io/blog/">Gloo Blog</a></li>
  <li><a href="https://docs.solo.io/gateway/latest/quickstart/">Docs</a></li>
  <li><a href="https://www.solo.io/blog/gateway-api-tutorial-blog/">https://www.solo.io/blog/gateway-api-tutorial-blog/</a></li>
  <li><a href="https://www.solo.io/blog/gateway-api-workshop/">https://www.solo.io/blog/gateway-api-workshop/</a></li>
  <li><a href="https://www.solo.io/blog/fast-and-furious-gateway-api-at-scale-with-envoy-proxy-and-gloo-gateway/">https://www.solo.io/blog/fast-and-furious-gateway-api-at-scale-with-envoy-proxy-and-gloo-gateway/</a></li>
  <li><a href="https://www.solo.io/blog/getting-the-most-out-of-gateway-api-lessons-learned-from-gloo-migrations/">https://www.solo.io/blog/getting-the-most-out-of-gateway-api-lessons-learned-from-gloo-migrations/</a></li>
  <li><a href="https://www.solo.io/blog/solving-an-information-leakage-problem-with-the-envoy-extproc-filter-and-kube-gateway-api/">https://www.solo.io/blog/solving-an-information-leakage-problem-with-the-envoy-extproc-filter-and-kube-gateway-api/</a></li>
  <li><a href="https://www.solo.io/blog/gateway-api-gitops-argo-tutorial-blog/">https://www.solo.io/blog/gateway-api-gitops-argo-tutorial-blog/</a></li>
</ul>

<h4 id="실습">실습</h4>

<p>실습을 통해 Gloo Gateway를 설치하고, Gateway API를 사용해보겠습니다.
실습은 <a href="https://www.solo.io/blog/gateway-api-tutorial-blog/">[Tutorial] Hands-On with the Kubernetes Gateway API and Envoy Proxy</a>를 참고하였습니다.
kind를 통해서 실습할 수 있도록 잘 구성되었고 30분 정도면 따라할 수 있다고 합니다.</p>

<h5 id="install">Install</h5>

<p><strong>Install KinD Cluster</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOT</span><span class="sh">&gt; kind-1node.yaml
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  extraPortMappings:
  - containerPort: 30000
    hostPort: 30000
  - containerPort: 30001
    hostPort: 30001
  - containerPort: 30002
    hostPort: 30002
</span><span class="no">EOT

</span><span class="c"># Install KinD Cluster</span>
<span class="nv">$ </span>kind create cluster <span class="nt">--image</span> kindest/node:v1.30.0 <span class="nt">--config</span> kind-1node.yaml <span class="nt">--name</span> myk8s

<span class="c"># 노드에 기본 툴 설치</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane sh <span class="nt">-c</span> <span class="s1">'apt update &amp;&amp; apt install tree psmisc lsof wget bsdmainutils bridge-utils net-tools dnsutils tcpdump ngrep iputils-ping git vim -y'</span>

<span class="c"># 노드/파드 확인</span>
<span class="nv">$ </span>kubectl get nodes <span class="nt">-o</span> wide
<span class="c"># =&gt; NAME                  STATUS   ROLES           AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                         KERNEL-VERSION     CONTAINER-RUNTIME</span>
<span class="c">#    myk8s-control-plane   Ready    control-plane   32s   v1.30.0   172.20.0.2    &amp;lt;none&amp;gt;        Debian GNU/Linux 12 (bookworm)   5.10.76-linuxkit   containerd://1.7.15</span>
<span class="nv">$ </span>kubectl get pod <span class="nt">-A</span>
<span class="c"># =&gt; NAMESPACE            NAME                                          READY   STATUS    RESTARTS   AGE</span>
<span class="c">#    kube-system          coredns-7db6d8ff4d-45mzg                      1/1     Running   0          38s</span>
<span class="c">#    kube-system          coredns-7db6d8ff4d-gc4zp                      1/1     Running   0          38s</span>
<span class="c">#    kube-system          etcd-myk8s-control-plane                      1/1     Running   0          52s</span>
<span class="c">#    kube-system          kindnet-h4dwk                                 1/1     Running   0          38s</span>
<span class="c">#    kube-system          kube-apiserver-myk8s-control-plane            1/1     Running   0          54s</span>
<span class="c">#    kube-system          kube-controller-manager-myk8s-control-plane   1/1     Running   0          52s</span>
<span class="c">#    kube-system          kube-proxy-sptf6                              1/1     Running   0          38s</span>
<span class="c">#    kube-system          kube-scheduler-myk8s-control-plane            1/1     Running   0          52s</span>
<span class="c">#    local-path-storage   local-path-provisioner-988d74bc-gl679         1/1     Running   0          38s</span>
</code></pre></div></div>

<p><strong>Install Gateway API CRDs</strong> : The Kubernetes Gateway API abstractions are expressed using Kubernetes CRDs.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># CRDs 설치 및 확인</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml
<span class="nv">$ </span>kubectl get crd
<span class="c"># =&gt; NAME                                        CREATED AT</span>
<span class="c">#    gatewayclasses.gateway.networking.k8s.io    2024-10-01T15:50:32Z</span>
<span class="c">#    gateways.gateway.networking.k8s.io          2024-10-01T15:50:32Z</span>
<span class="c">#    httproutes.gateway.networking.k8s.io        2024-10-01T15:50:32Z</span>
<span class="c">#    referencegrants.gateway.networking.k8s.io   2024-10-01T15:50:32Z</span>
</code></pre></div></div>

<p><strong>Install Glooctl Utility</strong> : GLOOCTL is a command-line utility that allows users to view, manage, and debug Gloo Gateway deployments - <a href="https://docs.solo.io/gloo-edge/latest/installation/glooctl_setup/">Link</a></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># [신규 터미널] 아래 bash 진입 후 glooctl 툴 사용</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane bash
<span class="nt">----------------------------------------</span>
<span class="c"># Install Glooctl Utility</span>
<span class="c">## glooctl install gateway     # install gloo's function gateway functionality into the 'gloo-system' namespace</span>
<span class="c">## glooctl install ingress     # install very basic Kubernetes Ingress support with Gloo into namespace gloo-system</span>
<span class="c">## glooctl install knative     # install Knative serving with Gloo configured as the default cluster ingress</span>
<span class="c">## curl -sL https://run.solo.io/gloo/install | sh</span>
<span class="nv">$ </span>curl <span class="nt">-sL</span> https://run.solo.io/gloo/install | <span class="nv">GLOO_VERSION</span><span class="o">=</span>v1.17.7 sh
<span class="nv">$ </span><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$HOME</span>/.gloo/bin:<span class="nv">$PATH</span>

<span class="c"># 버전 확인</span>
<span class="nv">$ </span>glooctl version
<span class="c"># =&gt; Server: version undefined, could not find any version of gloo running</span>
<span class="c">#    </span>
<span class="c">#    {</span>
<span class="c">#      &amp;quot;client&amp;quot;: {</span>
<span class="c">#        &amp;quot;version&amp;quot;: &amp;quot;1.17.7&amp;quot;</span>
<span class="c">#      },</span>
<span class="c">#      &amp;quot;kubernetesCluster&amp;quot;: {</span>
<span class="c">#        &amp;quot;major&amp;quot;: &amp;quot;1&amp;quot;,</span>
<span class="c">#        &amp;quot;minor&amp;quot;: &amp;quot;30&amp;quot;,</span>
<span class="c">#        &amp;quot;gitVersion&amp;quot;: &amp;quot;v1.30.0&amp;quot;,</span>
<span class="c">#        &amp;quot;buildDate&amp;quot;: &amp;quot;2024-05-13T22:02:25Z&amp;quot;,</span>
<span class="c">#        &amp;quot;platform&amp;quot;: &amp;quot;linux/arm64&amp;quot;</span>
<span class="c">#      }</span>
<span class="c">#    }</span>

<span class="c"># &lt;span style="color: green;"&gt;👉 서버가 설치되지 않았기 때문에 클라이언트 정보만 나옵니다.&lt;/span&gt;</span>
<span class="nt">----------------------------------------</span>
</code></pre></div></div>

<p><strong>Install Gloo Gateway : 오픈소스 버전</strong></p>

<p><strong>rosetta 비활성화 방법</strong></p>

<ul>
  <li>
    <p>[macOS m시리즈] <strong>Docker Desktop</strong> : 아래 옵션 Uncheck 해둘 것 → Apply &amp; restart</p>

    <p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_22.png" alt="img.png" loading="lazy" width="2028" height="724"></p>
  </li>
  <li>
    <p>[macOS m시리즈] <strong>Orbstack</strong> : 터미널에서 아래 입력</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c"># rosetta 비활성화 </span>
  <span class="nv">$ </span>orb config <span class="nb">set </span>rosetta <span class="nb">false</span>
    
  <span class="c">#  orb 설정 확인 </span>
  <span class="nv">$ </span>orb config show
    
  <span class="c"># orbstack 재시작 </span>
  <span class="nv">$ </span>orb stop 
  <span class="nv">$ </span>orb start 
</code></pre></div>    </div>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># [신규 터미널] 모니터링</span>
<span class="nv">$ </span>watch <span class="nt">-d</span> kubectl get pod,svc,endpointslices,ep <span class="nt">-n</span> gloo-system

<span class="c"># Install Gloo Gateway</span>
<span class="c">## --set kubeGateway.enabled=true: Kubernetes Gateway 기능을 활성화합니다.</span>
<span class="c">## --set gloo.disableLeaderElection=true: Gloo의 리더 선출 기능을 비활성화합니다. (단일 인스턴스에서 Gloo를 실행 시 유용)</span>
<span class="c">## --set discovery.enabled=false: 서비스 디스커버리 기능을 비활성화합니다.</span>
<span class="nv">$ </span>helm repo add gloo https://storage.googleapis.com/solo-public-helm
<span class="c"># =&gt; &amp;quot;gloo&amp;quot; has been added to your repositories</span>
<span class="nv">$ </span>helm repo update
<span class="nv">$ </span>helm <span class="nb">install</span> <span class="nt">-n</span> gloo-system gloo-gateway gloo/gloo <span class="se">\</span>
<span class="nt">--create-namespace</span> <span class="se">\</span>
<span class="nt">--version</span> 1.17.7 <span class="se">\</span>
<span class="nt">--set</span> kubeGateway.enabled<span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
<span class="nt">--set</span> gloo.disableLeaderElection<span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
<span class="nt">--set</span> discovery.enabled<span class="o">=</span><span class="nb">false</span>
<span class="c"># =&gt; NAME: gloo-gateway</span>
<span class="c">#    LAST DEPLOYED: Sun Oct 13 00:57:27 2024</span>
<span class="c">#    NAMESPACE: gloo-system</span>
<span class="c">#    STATUS: deployed</span>
<span class="c">#    REVISION: 1</span>
<span class="c">#    TEST SUITE: None</span>

<span class="c"># Confirm that the Gloo control plane has successfully been deployed using this command</span>
<span class="nv">$ </span>kubectl rollout status deployment/gloo <span class="nt">-n</span> gloo-system
<span class="c"># =&gt; deployment &amp;quot;gloo&amp;quot; successfully rolled out</span>

<span class="c"># 설치 확인</span>
<span class="nv">$ </span>kubectl get crd | <span class="nb">grep</span> <span class="s1">'networking.k8s.io'</span>
<span class="c"># =&gt; gatewayclasses.gateway.networking.k8s.io    2024-10-01T15:50:32Z</span>
<span class="c">#    gateways.gateway.networking.k8s.io          2024-10-01T15:50:32Z</span>
<span class="c">#    httproutes.gateway.networking.k8s.io        2024-10-01T15:50:32Z</span>
<span class="c">#    referencegrants.gateway.networking.k8s.io   2024-10-01T15:50:32Z</span>
<span class="nv">$ </span>kubectl get crd | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s1">'networking.k8s.io'</span>
<span class="nv">$ </span>kubectl get pod,svc,endpointslices <span class="nt">-n</span> gloo-system
<span class="c"># =&gt; NAME                                    READY   STATUS      RESTARTS   AGE</span>
<span class="c">#    pod/gateway-proxy-57c49d4f48-xm8vv      1/1     Running     0          87s</span>
<span class="c">#    pod/gloo-748d877c4-24ngk                1/1     Running     0          87s</span>
<span class="c">#    pod/gloo-resource-rollout-5bt7d         0/1     Completed   0          87s</span>
<span class="c">#    pod/gloo-resource-rollout-check-xwxd4   0/1     Completed   0          86s</span>
<span class="c">#    </span>
<span class="c">#    NAME                    TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                                                AGE</span>
<span class="c">#    service/gateway-proxy   LoadBalancer   10.96.69.126    &amp;lt;pending&amp;gt;     80:30172/TCP,443:32484/TCP                             87s</span>
<span class="c">#    service/gloo            ClusterIP      10.96.100.145   &amp;lt;none&amp;gt;        9977/TCP,9976/TCP,9988/TCP,9966/TCP,9979/TCP,443/TCP   87s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                                 ADDRESSTYPE   PORTS                        ENDPOINTS    AGE</span>
<span class="c">#    endpointslice.discovery.k8s.io/gateway-proxy-n7f7v   IPv4          8080,8443                    10.244.0.7   87s</span>
<span class="c">#    endpointslice.discovery.k8s.io/gloo-9bf7g            IPv4          9979,9988,9966 + 3 more...   10.244.0.8   87s</span>

<span class="c">#</span>
<span class="nv">$ </span>kubectl explain gatewayclasses
<span class="nv">$ </span>kubectl get gatewayclasses
<span class="c"># =&gt; NAME           CONTROLLER             ACCEPTED   AGE</span>
<span class="c">#    gloo-gateway   solo.io/gloo-gateway   True       2m18s</span>

<span class="nv">$ </span>kubectl get gatewayclasses <span class="nt">-o</span> yaml
<span class="c"># =&gt; apiVersion: v1</span>
<span class="c">#    items:</span>
<span class="c">#    - apiVersion: gateway.networking.k8s.io/v1</span>
<span class="c">#      kind: GatewayClass</span>
<span class="c">#      metadata:</span>
<span class="c">#        labels:</span>
<span class="c">#          app: gloo</span>
<span class="c">#        name: gloo-gateway</span>
<span class="c">#      spec:</span>
<span class="c">#        controllerName: solo.io/gloo-gateway</span>
<span class="c">#    ...</span>
</code></pre></div></div>

<p><strong>Install Httpbin Application</strong> : A simple HTTP Request &amp; Response Service - <a href="https://httpbin.org/">Link</a></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span>watch <span class="nt">-d</span> kubectl get pod,svc,endpointslices,ep <span class="nt">-n</span> httpbin

<span class="c"># Install Httpbin Application</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/solo-io/solo-blog/main/gateway-api-tutorial/01-httpbin-svc.yaml
<span class="c"># =&gt; namespace/httpbin created</span>
<span class="c">#    serviceaccount/httpbin created</span>
<span class="c">#    service/httpbin created</span>
<span class="c">#    deployment.apps/httpbin created</span>

<span class="c"># 설치 확인</span>
<span class="nv">$ </span>kubectl get deploy,pod,svc,endpointslices,sa <span class="nt">-n</span> httpbin
<span class="c"># =&gt; NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span>
<span class="c">#    deployment.apps/httpbin   0/1     1            0           10s</span>
<span class="c">#    </span>
<span class="c">#    NAME                           READY   STATUS              RESTARTS   AGE</span>
<span class="c">#    pod/httpbin-5855dc8bdd-xh2vf   0/1     ContainerCreating   0          10s</span>
<span class="c">#    </span>
<span class="c">#    NAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span>
<span class="c">#    service/httpbin   ClusterIP   10.96.169.139   &amp;lt;none&amp;gt;        8000/TCP   10s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                           ADDRESSTYPE   PORTS     ENDPOINTS   AGE</span>
<span class="c">#    endpointslice.discovery.k8s.io/httpbin-6zhsk   IPv4          &amp;lt;unset&amp;gt;   &amp;lt;unset&amp;gt;     10s</span>
<span class="c">#    </span>
<span class="c">#    NAME                     SECRETS   AGE</span>
<span class="c">#    serviceaccount/default   0         10s</span>
<span class="c">#    serviceaccount/httpbin   0         10s</span>
<span class="nv">$ </span>kubectl rollout status deploy/httpbin <span class="nt">-n</span> httpbin
<span class="c"># =&gt; deployment &amp;quot;httpbin&amp;quot; successfully rolled out</span>

<span class="c"># (옵션) NodePort 설정</span>
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  labels:
    app: httpbin
    service: httpbin
  name: httpbin
  namespace: httpbin
spec:
  type: NodePort
  ports:
  - name: http
    port: 8000
    targetPort: 80
    nodePort: 30000
  selector:
    app: httpbin
</span><span class="no">EOF
</span><span class="c"># =&gt; service/httpbin configured</span>

<span class="c"># (옵션) 로컬 접속 확인</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"httpbin web - http://localhost:30000"</span>     <span class="c"># macOS 사용자</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"httpbin web - http://192.168.50.10:30000"</span> <span class="c"># Windows 사용자</span>
</code></pre></div></div>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_23.png" alt="img.png" class="w-80 image-center" loading="lazy" width="877" height="1401">
<em class="image-caption">httpbin 설치결과</em></p>

<p><strong>Gateway API 종류</strong> - <a href="https://kubernetes.io/docs/concepts/services-networking/gateway/#resource-model">Docs</a></p>

<ul>
  <li>
<strong>GatewayClass:</strong> Defines a set of gateways with <strong>common configuration</strong> and managed by a controller that implements the <strong>class</strong>. - 예) 인프라 엔지니어가 관리</li>
  <li>
<strong>Gateway:</strong> Defines an instance of traffic handling <strong>infrastructure</strong>, such as cloud load balancer. - 예) 데브옵스 엔지니어가 관리</li>
  <li>
<strong>HTTPRoute:</strong> Defines <strong>HTTP-specific rules</strong> for mapping traffic from a Gateway listener to a representation of backend network endpoints. These endpoints are often represented as a <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a>. - 예) 개발자가 관리</li>
</ul>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_24.png" alt="img.png" class="image-center" loading="lazy" width="466" height="130"></p>

<h5 id="control--envoy-data-plane-and-the-gloo-control-plane">Control : <strong>Envoy</strong> data plane and the <strong>Gloo</strong> control plane.</h5>

<ul>
  <li>Now we’ll configure a <strong>Gateway listener</strong>, establish external access to <strong>Gloo Gateway,</strong> and test the <strong>routing</strong> <strong>rules</strong> that are the core of the proxy configuration.</li>
</ul>

<p><strong>Configure a Gateway Listener</strong></p>

<ul>
  <li>Let’s begin by establishing a Gateway resource that sets up an HTTP listener on port 8080 to expose routes from all our namespaces. Gateway custom resources like this are part of the Gateway API standard.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 02-gateway.yaml</span>
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> &gt; 02-gateway.yaml
kind: Gateway
apiVersion: gateway.networking.k8s.io/v1
metadata:
  name: http
  namespace: gloo-system
spec:
  gatewayClassName: gloo-gateway
  listeners:
  - protocol: HTTP
    port: 8080
    name: http
    allowedRoutes:
      namespaces:
        from: All
</span><span class="no">EOF

</span><span class="c"># gateway 리소스 생성</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> 02-gateway.yaml
<span class="c"># =&gt; gateway.gateway.networking.k8s.io/http created</span>

<span class="c"># 확인 : Now we can confirm that the Gateway has been activated</span>
<span class="nv">$ </span>kubectl get gateway <span class="nt">-n</span> gloo-system
<span class="c"># =&gt; NAME   CLASS          ADDRESS   PROGRAMMED   AGE</span>
<span class="c">#    http   gloo-gateway             True         8s</span>
<span class="nv">$ </span>kubectl get gateway <span class="nt">-n</span> gloo-system <span class="nt">-o</span> yaml
<span class="c"># =&gt; apiVersion: v1</span>
<span class="c">#    items:</span>
<span class="c">#    - apiVersion: gateway.networking.k8s.io/v1</span>
<span class="c">#      kind: Gateway</span>
<span class="c">#      metadata:</span>
<span class="c">#        name: http</span>
<span class="c">#        namespace: gloo-system</span>
<span class="c">#      spec:</span>
<span class="c">#        gatewayClassName: gloo-gateway</span>
<span class="c">#        listeners:</span>
<span class="c">#        - allowedRoutes:</span>
<span class="c">#            namespaces:</span>
<span class="c">#              from: All</span>
<span class="c">#          name: http</span>
<span class="c">#          port: 8080</span>
<span class="c">#          protocol: HTTP</span>
<span class="c">#    ...</span>

<span class="c"># You can also confirm that Gloo Gateway has spun up an Envoy proxy instance in response to the creation of this Gateway object by deploying gloo-proxy-http:</span>
<span class="nv">$ </span>kubectl get deployment gloo-proxy-http <span class="nt">-n</span> gloo-system
<span class="c"># =&gt; NAME              READY   UP-TO-DATE   AVAILABLE   AGE</span>
<span class="c">#    gloo-proxy-http   1/1     1            1           66s</span>

<span class="c"># envoy 사용 확인</span>
<span class="nv">$ </span>kubectl get pod <span class="nt">-n</span> gloo-system
<span class="c"># =&gt; NAME                               READY   STATUS    RESTARTS   AGE</span>
<span class="c">#    gateway-proxy-57c49d4f48-xm8vv     1/1     Running   0          13m</span>
<span class="c">#    gloo-748d877c4-24ngk               1/1     Running   0          13m</span>
<span class="c">#    gloo-proxy-http-587765f6b6-mpnt5   1/1     Running   0          78s</span>
<span class="nv">$ </span>kubectl describe pod <span class="nt">-n</span> gloo-system  |grep Image:
<span class="c"># =&gt;     Image:         quay.io/solo-io/gloo-envoy-wrapper:1.17.7 # &lt;span style="color: green;"&gt;👉 이름에서 알 수 있듯이 envoy가 들어있고 감싸고 있는것으로 보입니다.&lt;/span&gt;</span>
<span class="c">#        Image:          quay.io/solo-io/gloo:1.17.7</span>
<span class="c">#        Image:         quay.io/solo-io/gloo-envoy-wrapper:1.17.7</span>

<span class="c"># gloo-proxy-http 서비스는 External-IP는 Pending 상태</span>
<span class="nv">$ </span>kubectl get svc <span class="nt">-n</span> gloo-system gloo-proxy-http
<span class="c"># =&gt; NAME              TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span>
<span class="c">#    gloo-proxy-http   LoadBalancer   10.96.104.226   &amp;lt;pending&amp;gt;     8080:31461/TCP   101s</span>

<span class="c"># gloo-proxy-http NodePort 30001 설정</span>
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/instance: http
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gloo-proxy-http
    app.kubernetes.io/version: 1.17.7
    gateway.networking.k8s.io/gateway-name: http
    gloo: kube-gateway
    helm.sh/chart: gloo-gateway-1.17.7
  name: gloo-proxy-http
  namespace: gloo-system
spec:
  ports:
  - name: http
    nodePort: 30001
    port: 8080
  selector:
    app.kubernetes.io/instance: http
    app.kubernetes.io/name: gloo-proxy-http
    gateway.networking.k8s.io/gateway-name: http
  type: LoadBalancer
</span><span class="no">EOF
</span><span class="c"># =&gt; service/gloo-proxy-http configured</span>

<span class="nv">$ </span>kubectl get svc <span class="nt">-n</span> gloo-system gloo-proxy-http
<span class="c"># =&gt; NAME              TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span>
<span class="c">#    gloo-proxy-http   LoadBalancer   10.96.104.226   &amp;lt;pending&amp;gt;     8080:30001/TCP   2m17s </span>
<span class="c"># &lt;span style="color: green;"&gt;👉 노드포트가 30001로 변경되었습니다.&lt;/span&gt;</span>
</code></pre></div></div>

<p><strong>Establish External Access to Proxy</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 간편한 테스트를 위해 port-forward를 사용하여 외부로 노출하겠습니다.</span>
<span class="nv">$ </span>kubectl port-forward deployment/gloo-proxy-http <span class="nt">-n</span> gloo-system 8080:8080 &amp;
</code></pre></div></div>

<p><strong>Configure Simple Routing with an HTTPRoute</strong></p>

<p>Let’s begin our routing configuration with the simplest possible <strong>route</strong> to expose the <strong>/get</strong> operation on <strong>httpbin</strong></p>

<p><code class="language-plaintext highlighter-rouge">HTTPRoute</code> is one of the new Kubernetes CRDs introduced by the Gateway API, as documented <a href="https://gateway-api.sigs.k8s.io/api-types/httproute/">here</a>. We’ll start by introducing a simple <code class="language-plaintext highlighter-rouge">HTTPRoute</code> for our service.</p>

<p><strong>HTTPRoute Spec</strong></p>

<ul>
  <li>
<a href="https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.ParentRef">ParentRefs</a>-Define which <strong>Gateways</strong> this <strong>Route</strong> wants to be <strong>attached</strong> to.</li>
  <li>
<a href="https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.Hostname">Hostnames</a> (optional)- Define a list of <strong>hostnames</strong> to use for matching the <strong>Host header</strong> of HTTP requests.</li>
  <li>
<a href="https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteRule">Rules</a>-Define a list of <strong>rules</strong> to perform <strong>actions</strong> against matching HTTP requests.
    <ul>
      <li>Each rule consists of <a href="https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteMatch">matches</a>, <a href="https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteFilter">filters</a> (optional), <a href="https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPBackendRef">backendRefs</a> (optional) and <a href="https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteTimeouts">timeouts</a> (optional) fields.</li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: gateway.networking.k8s.io/v1beta1
kind: HTTPRoute
metadata:
  name: httpbin
  namespace: httpbin
  labels:
    example: httpbin-route
spec:
  parentRefs:
    - name: http
      namespace: gloo-system
  hostnames:
    - <span class="s2">"api.example.com"</span>
  rules:
  - matches:
    - path:
        <span class="nb">type</span>: Exact
        value: /get
    backendRefs:
      - name: httpbin
        port: 8000
</code></pre></div></div>

<p>This example <strong>attaches</strong> to the default <code class="language-plaintext highlighter-rouge">Gateway</code> object created for us when we installed Gloo Gateway earlier.</p>

<p>See the <code class="language-plaintext highlighter-rouge">gloo-system/http</code> reference in the <code class="language-plaintext highlighter-rouge">parentRefs</code> stanza.</p>

<p>The <a href="https://gateway-api.sigs.k8s.io/api-types/gateway/">Gateway</a> object simply represents a host:port listener that the proxy will expose to accept ingress traffic.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Our route watches for HTTP requests directed at the host api.example.com with the request path /get and then forwards the request to the httpbin service on port 8000.</span>
<span class="c"># Let’s establish this route now:</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/solo-io/gloo-gateway-use-cases/main/gateway-api-tutorial/03-httpbin-route.yaml
<span class="c"># =&gt; httproute.gateway.networking.k8s.io/httpbin created</span>

<span class="c">#</span>
<span class="nv">$ </span>kubectl get httproute <span class="nt">-n</span> httpbin
<span class="c"># =&gt; NAME      HOSTNAMES             AGE</span>
<span class="c">#    httpbin   [&amp;quot;api.example.com&amp;quot;]   12s</span>

<span class="nv">$ </span>kubectl describe httproute <span class="nt">-n</span> httpbin
<span class="c"># =&gt; ...</span>
<span class="c">#    Spec:</span>
<span class="c">#      Hostnames:</span>
<span class="c">#        api.example.com</span>
<span class="c">#      Parent Refs:</span>
<span class="c">#        Group:      gateway.networking.k8s.io</span>
<span class="c">#        Kind:       Gateway</span>
<span class="c">#        Name:       http</span>
<span class="c">#        Namespace:  gloo-system</span>
<span class="c">#      Rules:</span>
<span class="c">#        Backend Refs:</span>
<span class="c">#          Group:   </span>
<span class="c">#          Kind:    Service</span>
<span class="c">#          Name:    httpbin</span>
<span class="c">#          Port:    8000</span>
<span class="c">#          Weight:  1</span>
<span class="c">#        Matches:</span>
<span class="c">#          Path:</span>
<span class="c">#            Type:   Exact</span>
<span class="c">#            Value:  /get</span>
<span class="c">#    ...</span>
</code></pre></div></div>

<p><strong>Test the Simple Route with Curl</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># let’s use curl to display the response with the -i option to additionally show the HTTP response code and headers.</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"127.0.0.1 api.example.com"</span> | <span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/hosts
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"httproute - http://api.example.com:30001/get"</span> <span class="c"># 웹브라우저</span>
<span class="c"># 혹은</span>
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/get <span class="c"># kubectl port-forward 사용 시</span>
<span class="c"># =&gt; HTTP/1.1 200 OK</span>
<span class="c">#    &lt;span style="color: red;"&gt;server: envoy&lt;/span&gt; # &lt;span style="color: green;"&gt;👉 서버가 envoy임을 확인할 수 있습니다.&lt;/span&gt;</span>
<span class="c">#    date: Sat, 1 Oct 2024 16:19:18 GMT</span>
<span class="c">#    content-type: application/json</span>
<span class="c">#    content-length: 239</span>
<span class="c">#    access-control-allow-origin: *</span>
<span class="c">#    access-control-allow-credentials: true</span>
<span class="c">#    x-envoy-upstream-service-time: 13</span>
<span class="c">#    </span>
<span class="c">#    {</span>
<span class="c">#      &amp;quot;args&amp;quot;: {},</span>
<span class="c">#      &amp;quot;headers&amp;quot;: {</span>
<span class="c">#        &amp;quot;Accept&amp;quot;: &amp;quot;*/*&amp;quot;,</span>
<span class="c">#        &amp;quot;Host&amp;quot;: &amp;quot;api.example.com&amp;quot;,</span>
<span class="c">#        &amp;quot;User-Agent&amp;quot;: &amp;quot;curl/8.1.2&amp;quot;,</span>
<span class="c">#        &amp;quot;X-Envoy-Expected-Rq-Timeout-Ms&amp;quot;: &amp;quot;15000&amp;quot;</span>
<span class="c">#      },</span>
<span class="c">#      &amp;quot;origin&amp;quot;: &amp;quot;10.244.0.12&amp;quot;,</span>
<span class="c">#      &amp;quot;url&amp;quot;: &amp;quot;http://api.example.com/get&amp;quot;</span>
<span class="c">#    }</span>
</code></pre></div></div>

<p>Note that if we attempt to invoke another valid endpoint <code class="language-plaintext highlighter-rouge">/delay</code> on the <code class="language-plaintext highlighter-rouge">httpbin</code> service, it will fail with a <code class="language-plaintext highlighter-rouge">404 Not Found</code> error. Why? Because our <code class="language-plaintext highlighter-rouge">HTTPRoute</code> policy is only exposing access to <code class="language-plaintext highlighter-rouge">/get</code>, one of the many endpoints available on the service. If we try to consume an alternative <code class="language-plaintext highlighter-rouge">httpbin</code> endpoint like <code class="language-plaintext highlighter-rouge">/delay</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 호출 응답 왜 그럴까?</span>
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/delay/1
<span class="c"># =&gt; Handling connection for 8080</span>
<span class="c">#    HTTP/1.1 404 Not Found</span>
<span class="c">#    date: Sat, 1 Oct 2024 16:20:23 GMT</span>
<span class="c">#    server: envoy</span>
<span class="c">#    content-length: 0</span>
<span class="c"># &lt;span style="color: green;"&gt;👉 gloo를 통했을때는 HTTProute 설정에서 /get 이라는 경로에대해서 정확하게 일치(Exact) 할 경우에만 라우팅하도록 해서 그렇습니다.&lt;/span&gt;</span>

<span class="c"># nodeport 직접 접속 테스트</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"httproute - http://api.example.com:30000/delay/1"</span> <span class="c"># 1초 후 응답</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"httproute - http://api.example.com:30000/delay/5"</span> <span class="c"># 5초 후 응답</span>
<span class="c"># &lt;span style="color: green;"&gt;👉 노드포트로 직접 접속할 경우 gloo HTTPRoute를 거치지 않기 때문에 접속이 가능합니다.&lt;/span&gt;</span>
</code></pre></div></div>

<p>kind 클러스터를 구성할때 30000 포트를 열었기 때문에 NodePort로 직접 접속이 가능합니다.</p>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_25.png" alt="img.png" class="w-80 image-center" loading="lazy" width="877" height="523">
<em class="image-caption">http://api.example.com:30000/delay/1 호출 결과 =&gt; 1초후 응답</em></p>

<p><strong>[정규식 패턴 매칭] Explore Routing with Regex Matching Patterns</strong></p>

<p>Let’s assume that now we DO want to expose other <code class="language-plaintext highlighter-rouge">httpbin</code> endpoints like <code class="language-plaintext highlighter-rouge">/delay</code>. Our initial <code class="language-plaintext highlighter-rouge">HTTPRoute</code> is inadequate, because it is looking for an exact path match with <code class="language-plaintext highlighter-rouge">/get</code>.</p>

<p>We’ll <strong>modify</strong> it in a couple of ways. <strong>First</strong>, we’ll modify the matcher to look for <strong>path prefix matches</strong> instead of an <strong>exact match</strong>. <strong>Second</strong>, we’ll add a <strong>new request filter</strong> to <strong>rewrite</strong> the matched <code class="language-plaintext highlighter-rouge">/api/httpbin/</code> prefix with just a <code class="language-plaintext highlighter-rouge">/</code> prefix, which will give us the flexibility to access any endpoint available on the <code class="language-plaintext highlighter-rouge">httpbin</code> service. So a path like <code class="language-plaintext highlighter-rouge">/api/httpbin/delay/1</code> will be sent to <code class="language-plaintext highlighter-rouge">httpbin</code> with the path <code class="language-plaintext highlighter-rouge">/delay/1</code>.</p>

<p>URL에 패턴이 매치가 되면 rewrite해서 실제 접속되는 경로를 변경할 수 있습니다.</p>
<ul>
  <li>예시) <code class="language-plaintext highlighter-rouge">/api/httpbin/delay/1</code> ⇒ <code class="language-plaintext highlighter-rouge">/delay/1</code>
</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Here are the modifications we’ll apply to our HTTPRoute:</span>

    - matches:
        <span class="c"># Switch from an Exact Matcher(정확한 매팅) to a PathPrefix (경로 매팅) Matcher</span>
        - path:
            <span class="nb">type</span>: PathPrefix
            value: /api/httpbin/
      filters:
        <span class="c"># Replace(변경) the /api/httpbin matched prefix with /</span>
        - <span class="nb">type</span>: URLRewrite
          urlRewrite:
            path:
              <span class="nb">type</span>: ReplacePrefixMatch
              replacePrefixMatch: /
</code></pre></div></div>

<ul>
  <li>2가지 수정 내용 적용 후 확인</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/solo-io/gloo-gateway-use-cases/main/gateway-api-tutorial/04-httpbin-rewrite.yaml
<span class="c"># =&gt; httproute.gateway.networking.k8s.io/httpbin configured</span>

<span class="c"># 확인</span>
<span class="nv">$ </span>kubectl describe httproute <span class="nt">-n</span> httpbin
<span class="c"># =&gt; ...</span>
<span class="c">#    Spec:</span>
<span class="c">#      Hostnames:</span>
<span class="c">#        api.example.com</span>
<span class="c">#      Parent Refs:</span>
<span class="c">#        Group:      gateway.networking.k8s.io</span>
<span class="c">#        Kind:       Gateway</span>
<span class="c">#        Name:       http</span>
<span class="c">#        Namespace:  gloo-system</span>
<span class="c">#      Rules:</span>
<span class="c">#        Backend Refs:</span>
<span class="c">#          Group:</span>
<span class="c">#          Kind:    Service</span>
<span class="c">#          Name:    httpbin</span>
<span class="c">#          Port:    8000</span>
<span class="c">#          Weight:  1</span>
<span class="c">#        Filters:</span>
<span class="c">#          Type:  URLRewrite</span>
<span class="c">#          URL Rewrite:</span>
<span class="c">#            Path:</span>
<span class="c">#              Replace Prefix Match:  /</span>
<span class="c">#              Type:                  ReplacePrefixMatch</span>
<span class="c">#        Matches:</span>
<span class="c">#          Path:</span>
<span class="c">#            Type:   PathPrefix</span>
<span class="c">#            Value:  /api/httpbin/</span>
<span class="c">#    ...</span>
</code></pre></div></div>

<p><strong>Test Routing with Regex Matching Patterns</strong></p>

<p>When we used only a single route with an exact match pattern, we could only exercise the httpbin <code class="language-plaintext highlighter-rouge">/get</code> endpoint. Let’s now use <code class="language-plaintext highlighter-rouge">curl</code> to confirm that both <code class="language-plaintext highlighter-rouge">/get</code> and <code class="language-plaintext highlighter-rouge">/delay</code> work as expected.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"httproute - http://api.example.com:30001/api/httpbin/get"</span> <span class="c"># 웹브라우저</span>
<span class="c"># 혹은</span>
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/httpbin/get <span class="c"># kubectl port-forward 사용 시</span>
<span class="c"># =&gt; HTTP/1.1 200 OK</span>
<span class="c">#    server: envoy</span>
<span class="c">#    date: Sat, 1 Oct 2024 16:33:20 GMT</span>
<span class="c">#    content-type: application/json</span>
<span class="c">#    content-length: 289</span>
<span class="c">#    access-control-allow-origin: *</span>
<span class="c">#    access-control-allow-credentials: true</span>
<span class="c">#    x-envoy-upstream-service-time: 20</span>
<span class="c">#    </span>
<span class="c">#    {</span>
<span class="c">#      &amp;quot;args&amp;quot;: {},</span>
<span class="c">#      &amp;quot;headers&amp;quot;: {</span>
<span class="c">#        &amp;quot;Accept&amp;quot;: &amp;quot;*/*&amp;quot;,</span>
<span class="c">#        &amp;quot;Host&amp;quot;: &amp;quot;api.example.com&amp;quot;,</span>
<span class="c">#        &amp;quot;User-Agent&amp;quot;: &amp;quot;curl/8.1.2&amp;quot;,</span>
<span class="c">#        &amp;quot;X-Envoy-Expected-Rq-Timeout-Ms&amp;quot;: &amp;quot;15000&amp;quot;,</span>
<span class="c">#        &amp;quot;X-Envoy-Original-Path&amp;quot;: &amp;quot;/api/httpbin/get&amp;quot;</span>
<span class="c">#      },</span>
<span class="c">#      &amp;quot;origin&amp;quot;: &amp;quot;10.244.0.12&amp;quot;,</span>
<span class="c">#      &amp;quot;url&amp;quot;: &amp;quot;http://api.example.com/get&amp;quot;</span>
<span class="c">#    }</span>

<span class="c"># 아래 NodePort 와 GW API 통한 접속 비교</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"httproute - http://api.example.com:30001/api/httpbin/get"</span>
<span class="c"># =&gt; HTTP/1.1 200 OK</span>
<span class="c">#    ...</span>
<span class="c">#      &amp;quot;url&amp;quot;: &amp;quot;&lt;span style="color: red;"&gt;http://api.example.com/get&lt;/span&gt;&amp;quot;</span>
<span class="c">#    }</span>
<span class="c"># &lt;span style="color: green;"&gt;👉 gloo gateway가 /app/httpbin/get =&gt; / 로 변경하여 잘 접속이 되었습니다.&lt;/span&gt;</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"httproute - http://api.example.com:30000/api/httpbin/get"</span> <span class="c"># NodePort 직접 접근</span>
<span class="c"># =&gt; HTTP/1.1 404 NOT FOUND</span>
<span class="c">#    ...</span>
<span class="c"># &lt;span style="color: green;"&gt;👉 NodePort에 직접 접근시에는 /app/httpbin/get이 그대로 파드에 전달되어 없는 경로라서 404 에러가 납니다.&lt;/span&gt;</span>

<span class="nt">---</span>
<span class="c">#</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"httproute - http://api.example.com:30001/api/httpbin/delay/1"</span> <span class="c"># 웹브라우저</span>
<span class="c"># 혹은</span>
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/httpbin/delay/1 <span class="c"># kubectl port-forward 사용 시</span>
<span class="c"># =&gt; HTTP/1.1 200 OK</span>
<span class="c">#    server: envoy</span>
<span class="c">#    date: Sat, 1 Oct 2024 16:36:49 GMT</span>
<span class="c">#    content-type: application/json</span>
<span class="c">#    content-length: 343</span>
<span class="c">#    access-control-allow-origin: *</span>
<span class="c">#    access-control-allow-credentials: true</span>
<span class="c">#    x-envoy-upstream-service-time: 1049     # envoy 가 업스트림 httpbin 요청 처리에 걸리 시간 1초 이상</span>
<span class="c">#    </span>
<span class="c">#    {</span>
<span class="c">#      &amp;quot;args&amp;quot;: {},</span>
<span class="c">#      &amp;quot;data&amp;quot;: &amp;quot;&amp;quot;,</span>
<span class="c">#      &amp;quot;files&amp;quot;: {},</span>
<span class="c">#      &amp;quot;form&amp;quot;: {},</span>
<span class="c">#      &amp;quot;headers&amp;quot;: {</span>
<span class="c">#        &amp;quot;Accept&amp;quot;: &amp;quot;*/*&amp;quot;,</span>
<span class="c">#        &amp;quot;Host&amp;quot;: &amp;quot;api.example.com&amp;quot;,</span>
<span class="c">#        &amp;quot;User-Agent&amp;quot;: &amp;quot;curl/8.1.2&amp;quot;,</span>
<span class="c">#        &amp;quot;X-Envoy-Expected-Rq-Timeout-Ms&amp;quot;: &amp;quot;15000&amp;quot;,</span>
<span class="c">#        &amp;quot;X-Envoy-Original-Path&amp;quot;: &amp;quot;/api/httpbin/delay/1&amp;quot;</span>
<span class="c">#      },</span>
<span class="c">#      &amp;quot;origin&amp;quot;: &amp;quot;10.244.0.12&amp;quot;,</span>
<span class="c">#      &amp;quot;url&amp;quot;: &amp;quot;http://api.example.com/delay/1&amp;quot;</span>
<span class="c">#    }</span>

<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/httpbin/delay/2
<span class="c"># =&gt; ...</span>
<span class="c">#    x-envoy-upstream-service-time: 2133</span>
<span class="c">#    ...</span>
</code></pre></div></div>

<p>Perfect! It works just as expected! Note that the <code class="language-plaintext highlighter-rouge">/delay</code> operation completed successfully and that the 1-second delay was applied. The response header <code class="language-plaintext highlighter-rouge">x-envoy-upstream-service-time: 1023</code> indicates that Envoy reported that the upstream <code class="language-plaintext highlighter-rouge">httpbin</code> service required just over 1 second (1,023 milliseconds) to process the request. In the initial <code class="language-plaintext highlighter-rouge">/get</code> operation, which doesn’t inject an artificial delay, observe that the same header reported only 14 milliseconds of upstream processing time.</p>

<p><strong>[업스트림 베어러 토큰을 사용한 변환] Test Transformations with Upstream Bearer Tokens</strong></p>

<p><strong>목적</strong> : 요청을 라우팅하는 <strong>백엔드</strong> 시스템 중 하나에서 <strong>인증</strong>해야 하는 <strong>요구</strong> 사항이 있는 경우는 어떻게 할까요? 이 업스트림 시스템에는 권한 부여를 위한 API 키가 필요하고, 이를 소비하는 <strong>클라이언트에 직접 노출하고 싶지 않다</strong>고 가정해 보겠습니다. 즉<strong>, 프록시 계층</strong>에서 <strong>요청</strong>에 <strong>주입</strong>할 간단한 <strong>베어러 토큰</strong>을 구성하고 싶습니다. (정적 API 키 토큰을 직접 주입)</p>

<p>What if we have a requirement to <strong>authenticate</strong> with one of the <strong>backend</strong> systems to which we route our requests?</p>

<p>Let’s assume that this <strong>upstream</strong> system requires an <strong>API key</strong> for authorization, and that we <strong>don’t</strong> want to expose this directly to the <strong>consuming client</strong>. In other words, we’d like to configure a <strong>simple bearer toke</strong>n to be <strong>injected</strong> into the <strong>request</strong> at the <strong>proxy layer.</strong></p>

<p>We can <strong>express</strong> this in the <strong>Gateway API</strong> by adding a <strong>filter</strong> that applies a simple <strong>transformation</strong> to the i<strong>ncoming request</strong>.</p>

<p>This will be applied along with the <strong>URLRewrite</strong> filter we created in the previous step.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># The new filters stanza in our HTTPRoute now looks like this:</span>

      filters:
        - <span class="nb">type</span>: URLRewrite
          urlRewrite:
            path:
              <span class="nb">type</span>: ReplacePrefixMatch
              replacePrefixMatch: /
              
        <span class="c"># Add a Bearer token to supply a static API key when routing to backend system</span>
        - <span class="nb">type</span>: RequestHeaderModifier
          requestHeaderModifier:
            add:
              - name: Authorization
                value: Bearer my-api-key
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/solo-io/gloo-gateway-use-cases/main/gateway-api-tutorial/05-httpbin-rewrite-xform.yaml

<span class="c">#</span>
<span class="nv">$ </span>kubectl describe httproute <span class="nt">-n</span> httpbin
<span class="c"># =&gt; ...</span>
<span class="c">#    Spec:</span>
<span class="c">#      ...</span>
<span class="c">#      Rules:</span>
<span class="c">#        Backend Refs:</span>
<span class="c">#          Group:</span>
<span class="c">#          Kind:    Service</span>
<span class="c">#          Name:    httpbin</span>
<span class="c">#          Port:    8000</span>
<span class="c">#          Weight:  1</span>
<span class="c">#        Filters:</span>
<span class="c">#          Type:  URLRewrite</span>
<span class="c">#          URL Rewrite:</span>
<span class="c">#            Path:</span>
<span class="c">#              Replace Prefix Match:  /</span>
<span class="c">#              Type:                  ReplacePrefixMatch</span>
<span class="c">#          Request Header Modifier:</span>
<span class="c">#            Add:</span>
<span class="c">#              Name:   Authorization</span>
<span class="c">#              Value:  Bearer my-api-key</span>
<span class="c">#          Type:       RequestHeaderModifier</span>
<span class="c">#        Matches:</span>
<span class="c">#          Path:</span>
<span class="c">#            Type:   PathPrefix</span>
<span class="c">#            Value:  /api/httpbin/</span>
</code></pre></div></div>

<ul>
  <li>동작 테스트</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"httproute - http://api.example.com:30001/api/httpbin/get"</span> <span class="c"># 웹브라우저</span>
<span class="c"># 혹은</span>
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/httpbin/get <span class="c"># kubectl port-forward 사용 시</span>
<span class="c"># =&gt; HTTP/1.1 200 OK</span>
<span class="c">#    server: envoy</span>
<span class="c">#    date: Sat, 1 Oct 2024 16:40:59 GMT</span>
<span class="c">#    content-type: application/json</span>
<span class="c">#    content-length: 332</span>
<span class="c">#    access-control-allow-origin: *</span>
<span class="c">#    access-control-allow-credentials: true</span>
<span class="c">#    x-envoy-upstream-service-time: 19</span>
<span class="c">#    </span>
<span class="c">#    {</span>
<span class="c">#      &amp;quot;args&amp;quot;: {},</span>
<span class="c">#      &amp;quot;headers&amp;quot;: {</span>
<span class="c">#        &amp;quot;Accept&amp;quot;: &amp;quot;*/*&amp;quot;,</span>
<span class="c">#        &lt;span style="color: red"&gt;&amp;quot;Authorization&amp;quot;: &amp;quot;Bearer my-api-key&amp;quot;,&lt;/span&gt; </span>
<span class="c">#        &amp;quot;Host&amp;quot;: &amp;quot;api.example.com&amp;quot;,</span>
<span class="c">#        &amp;quot;User-Agent&amp;quot;: &amp;quot;curl/8.1.2&amp;quot;,</span>
<span class="c">#        &amp;quot;X-Envoy-Expected-Rq-Timeout-Ms&amp;quot;: &amp;quot;15000&amp;quot;,</span>
<span class="c">#        &amp;quot;X-Envoy-Original-Path&amp;quot;: &amp;quot;/api/httpbin/get&amp;quot;</span>
<span class="c">#      },</span>
<span class="c">#      &amp;quot;origin&amp;quot;: &amp;quot;10.244.0.12&amp;quot;,</span>
<span class="c">#      &amp;quot;url&amp;quot;: &amp;quot;http://api.example.com/get&amp;quot;</span>
<span class="c">#    }</span>
<span class="c"># &lt;span style="color: green;"&gt;👉 클라이언트에서는 Authorization 헤더를 안 주었지만, Gloo gateway를 통하자&lt;/span&gt; </span>
<span class="c"># &lt;span style="color: green;"&gt;    Authorization 헤더에 Bearer my-api-key 가 추가되어 있습니다.&lt;/span&gt;</span>
</code></pre></div></div>

<h5 id="migrate">Migrate</h5>

<p>In this section, we’ll explore how a couple of common service migration techniques, <strong>dark launches with header-based routing</strong> and <strong>canary releases with percentage-based routing,</strong> are supported by the Gateway API standard.</p>

<p><strong>Configure Two Workloads for Migration Routing</strong></p>

<p>Let’s first establish <strong>two versions</strong> of a <strong>workload</strong> to facilitate our migration example. We’ll use the open-source <a href="https://github.com/nicholasjackson/fake-service">Fake Service</a> to enable this.</p>

<ul>
  <li>
<strong>Fake service</strong> that can handle both <strong>HTTP</strong> and <strong>gRPC</strong> traffic, for <strong>testing</strong> upstream service communications and testing service mesh and other scenarios.</li>
</ul>

<p>Let’s establish a <code class="language-plaintext highlighter-rouge">v1</code> of our <code class="language-plaintext highlighter-rouge">my-workload</code> service that’s configured to return a response string containing “v1”. We’ll create a corresponding <code class="language-plaintext highlighter-rouge">my-workload-v2</code> service as well.</p>

<ul>
  <li>ingress의 카나리 배포와 유사하게 V1의 일부 트래픽을 V2로 라우팅할 수 있습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># You should see the response below, indicating deployments for both v1 and v2 of my-workload have been created in the my-workload namespace.</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/solo-io/gloo-gateway-use-cases/main/gateway-api-tutorial/06-workload-svcs.yaml
<span class="c"># =&gt; namespace/my-workload created</span>
<span class="c">#    serviceaccount/my-workload created</span>
<span class="c">#    deployment.apps/my-workload-v1 created</span>
<span class="c">#    deployment.apps/my-workload-v2 created</span>
<span class="c">#    service/my-workload-v1 created</span>
<span class="c">#    service/my-workload-v2 created</span>

<span class="c"># v1,v2 2가지 버전 워크로드 확인</span>
<span class="nv">$ </span>kubectl get deploy,pod,svc,endpointslices <span class="nt">-n</span> my-workload
<span class="c"># =&gt; NAME                             READY   UP-TO-DATE   AVAILABLE   AGE</span>
<span class="c">#    deployment.apps/my-workload-v1   1/1     1            1           15s</span>
<span class="c">#    deployment.apps/my-workload-v2   1/1     1            1           15s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                  READY   STATUS    RESTARTS   AGE</span>
<span class="c">#    pod/my-workload-v1-644f98bbd9-q6cs5   1/1     Running   0          15s</span>
<span class="c">#    pod/my-workload-v2-5bb5fcfcbc-bq88c   1/1     Running   0          15s</span>
<span class="c">#    </span>
<span class="c">#    NAME                     TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span>
<span class="c">#    service/my-workload-v1   ClusterIP   10.96.203.193   &amp;lt;none&amp;gt;        8080/TCP   15s</span>
<span class="c">#    service/my-workload-v2   ClusterIP   10.96.210.160   &amp;lt;none&amp;gt;        8080/TCP   15s</span>
<span class="c">#    </span>
<span class="c">#    NAME                                                  ADDRESSTYPE   PORTS   ENDPOINTS     AGE</span>
<span class="c">#    endpointslice.discovery.k8s.io/my-workload-v1-d9sqd   IPv4          8080    10.244.0.14   15s</span>
<span class="c">#    endpointslice.discovery.k8s.io/my-workload-v2-mv7fq   IPv4          8080    10.244.0.13   15s</span>
</code></pre></div></div>

<p><strong>Test Simple V1 Routing</strong></p>

<p>Before we dive into routing to multiple services, we’ll start by building a simple <strong><code class="language-plaintext highlighter-rouge">HTTPRoute</code></strong> that sends HTTP requests to host <code class="language-plaintext highlighter-rouge">api.example.com</code> whose paths begin with <strong><code class="language-plaintext highlighter-rouge">/api/my-workload</code></strong> to the <strong><code class="language-plaintext highlighter-rouge">v1</code></strong> workload:</p>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_26.png" alt="img.png" loading="lazy" width="999" height="563"></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">gateway.networking.k8s.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">HTTPRoute</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-workload</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">my-workload</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">example</span><span class="pi">:</span> <span class="s">my-workload-route</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">parentRefs</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">http</span>
      <span class="na">namespace</span><span class="pi">:</span> <span class="s">gloo-system</span>
  <span class="na">hostnames</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">api.example.com"</span>
  <span class="na">rules</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">matches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span>
          <span class="na">type</span><span class="pi">:</span> <span class="s">PathPrefix</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s">/api/my-workload</span>
      <span class="na">backendRefs</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">my-workload-v1</span>
          <span class="na">namespace</span><span class="pi">:</span> <span class="s">my-workload</span>
          <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div></div>

<p>Now apply this route:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/solo-io/gloo-gateway-use-cases/main/gateway-api-tutorial/07-workload-route.yaml
<span class="c"># =&gt; httproute.gateway.networking.k8s.io/my-workload created</span>

<span class="c">#</span>
<span class="nv">$ </span>kubectl get httproute <span class="nt">-A</span>
<span class="c"># =&gt; NAMESPACE     NAME          HOSTNAMES             AGE</span>
<span class="c">#    httpbin       httpbin       [&amp;quot;api.example.com&amp;quot;]   29m</span>
<span class="c">#    my-workload   my-workload   [&amp;quot;api.example.com&amp;quot;]   29s</span>

<span class="c">#</span>
<span class="nv">$ </span>kubectl describe httproute <span class="nt">-n</span> my-workload
<span class="c"># =&gt; ...</span>
<span class="c">#    Spec:</span>
<span class="c">#      Hostnames:</span>
<span class="c">#        api.example.com</span>
<span class="c">#      Parent Refs:</span>
<span class="c">#        Group:      gateway.networking.k8s.io</span>
<span class="c">#        Kind:       Gateway</span>
<span class="c">#        Name:       http</span>
<span class="c">#        Namespace:  gloo-system</span>
<span class="c">#      Rules:</span>
<span class="c">#        Backend Refs:</span>
<span class="c">#          Group:</span>
<span class="c">#          Kind:       Service</span>
<span class="c">#          Name:       my-workload-v1</span>
<span class="c">#          Namespace:  my-workload</span>
<span class="c">#          Port:       8080</span>
<span class="c">#          Weight:     1</span>
<span class="c">#        Matches:</span>
<span class="c">#          Path:</span>
<span class="c">#            Type:   PathPrefix</span>
<span class="c">#            Value:  /api/my-workload</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> http://api.example.com:8080/api/my-workload | <span class="nb">grep </span>Workload<span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;  100   &amp;quot;body&amp;quot;: &amp;quot;Hello From My Workload (v1)!&amp;quot;,</span>

<span class="c"># &lt;span style="color: green;"&gt;👉 현재는 모든 연결이 v1으로 향합니다.&lt;/span&gt;</span>
</code></pre></div></div>

<p><strong>Simulate a v2 Dark Launch with Header-Based Routing</strong></p>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_27.png" alt="img.png" loading="lazy" width="999" height="563"></p>

<p><a href="https://www.cloudbees.com/blog/when-dark-launch-right-release-strategy">Dark Launch</a> is a great cloud migration technique that <strong>releases new feature</strong>s to a select <strong>subset of users</strong> to gather <strong>feedback</strong> and experiment with improvements <strong>before</strong> potentially disrupting a larger user community.</p>

<ul>
  <li>Dark Launch : 일부 사용자에게 새로운 기능을 출시하여 피드백을 수집하고 잠재적으로 더 큰 사용자 커뮤니티를 방해하기 전에 개선 사항을 실험하는 훌륭한 클라우드 마이그레이션 기술</li>
</ul>

<p>We will simulate a dark launch in our example by installing the <strong>new cloud version</strong> of our <strong>service</strong> in our Kubernetes cluster, and then using declarative policy to route only requests containing a <strong>particular heade</strong>r to the new <code class="language-plaintext highlighter-rouge">v2</code> instance. The <strong>vast majority of users</strong> will continue to use the original <strong><code class="language-plaintext highlighter-rouge">v1</code></strong> of the service just as before.</p>

<ul>
  <li>우리는 Kubernetes 클러스터에 서비스의 새로운 클라우드 버전을 설치한 다음 선언적 정책을 사용하여 특정 헤더를 포함하는 요청만 새 인스턴스로 라우팅하여 예제에서 다크 런치를 시뮬레이션할 것입니다 . 대다수의 사용자는 이전과 마찬가지로 서비스의 <code class="language-plaintext highlighter-rouge">v1</code>을 계속 사용할 것 입니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  rules:
    - matches:
      - path:
          <span class="nb">type</span>: PathPrefix
          value: /api/my-workload
        <span class="c"># Add a matcher to route requests with a v2 version header to v2</span>
        <span class="c"># version=v2 헤더값이 있는 사용자만 v2 라우팅</span>
        headers:
        - name: version
          value: v2
      backendRefs:
        - name: my-workload-v2
          namespace: my-workload
          port: 8080      
    - matches:
      <span class="c"># Route requests without the version header to v1 as before</span>
      <span class="c"># 대다수 일반 사용자는 기존 처럼 v1 라우팅</span>
      - path:
          <span class="nb">type</span>: PathPrefix
          value: /api/my-workload
      backendRefs:
        - name: my-workload-v1
          namespace: my-workload
          port: 8080
</code></pre></div></div>

<p>Configure two separate routes, one for <code class="language-plaintext highlighter-rouge">v1</code> that the majority of service consumers will still use, and another route for <code class="language-plaintext highlighter-rouge">v2</code> that will be accessed by specifying a request header with name <code class="language-plaintext highlighter-rouge">version</code> and value <code class="language-plaintext highlighter-rouge">v2</code>. Let’s apply the modified <code class="language-plaintext highlighter-rouge">HTTPRoute</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/solo-io/gloo-gateway-use-cases/main/gateway-api-tutorial/08-workload-route-header.yaml
<span class="c"># =&gt; httproute.gateway.networking.k8s.io/my-workload configured</span>

<span class="c"># </span>
<span class="nv">$ </span>kubectl describe httproute <span class="nt">-n</span> my-workload
<span class="c"># =&gt; ...</span>
<span class="c">#    Spec:  </span>
<span class="c">#      Rules:</span>
<span class="c">#        Backend Refs:</span>
<span class="c">#          Group:</span>
<span class="c">#          Kind:       Service</span>
<span class="c">#          Name:       my-workload-v2</span>
<span class="c">#          Namespace:  my-workload</span>
<span class="c">#          Port:       8080</span>
<span class="c">#          Weight:     1</span>
<span class="c">#        Matches:</span>
<span class="c">#          Headers:</span>
<span class="c">#            Name:   version</span>
<span class="c">#            Type:   Exact</span>
<span class="c">#            Value:  v2</span>
<span class="c">#          Path:</span>
<span class="c">#            Type:   PathPrefix</span>
<span class="c">#            Value:  /api/my-workload</span>
<span class="c">#        Backend Refs:</span>
<span class="c">#          Group:</span>
<span class="c">#          Kind:       Service</span>
<span class="c">#          Name:       my-workload-v1</span>
<span class="c">#          Namespace:  my-workload</span>
<span class="c">#          Port:       8080</span>
<span class="c">#          Weight:     1</span>
<span class="c">#        Matches:</span>
<span class="c">#          Path:</span>
<span class="c">#            Type:   PathPrefix</span>
<span class="c">#            Value:  /api/my-workload</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># version: v2 헤더가 없는 경우 v1으로 라우팅됩니다.</span>
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/my-workload
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/my-workload | <span class="nb">grep </span>body
<span class="c"># =&gt; "body": "Hello From My Workload (v1)!",</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> http://api.example.com:8080/api/my-workload | <span class="nb">grep </span>Workload<span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;  100   &amp;quot;body&amp;quot;: &amp;quot;Hello From My Workload (v1)!&amp;quot;,</span>

<span class="c"># 하지만 version: v2 헤더가 있는 경우 v2로 라우팅됩니다.</span>
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> <span class="nt">-H</span> <span class="s2">"version: v2"</span> http://localhost:8080/api/my-workload
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> <span class="nt">-H</span> <span class="s2">"version: v2"</span> http://localhost:8080/api/my-workload | <span class="nb">grep </span>body
<span class="c"># =&gt;   &amp;quot;body&amp;quot;: &amp;quot;Hello From My Workload (v2)!&amp;quot;,</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> http://api.example.com:8080/api/my-workload | <span class="nb">grep </span>Workload<span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;  100   &amp;quot;body&amp;quot;: &amp;quot;Hello From My Workload (v1)!&amp;quot;,</span>
</code></pre></div></div>

<p><strong>Expand V2 Testing with Percentage-Based Routing</strong></p>

<p>After a successful dark-launch, we may want a period where we use a <strong>blue-green strategy</strong> of gradually <strong>shifting</strong> user traffic from the <strong>old</strong> version to the <strong>new</strong> one. Let’s explore this with a routing policy that splits our traffic evenly, sending half our traffic to <strong><code class="language-plaintext highlighter-rouge">v1</code></strong> and the other <strong>half</strong> to <strong><code class="language-plaintext highlighter-rouge">v2</code></strong>.</p>

<ul>
  <li>성공적인 다크 런칭 이후, 우리는 <strong>점진적</strong>으로 이전 버전에서 새 버전으로 사용자 트래픽을 옮기는 <strong>블루-그린 전략</strong>을 사용하는 기간을 원할 수 있습니다. 트래픽을 균등하게 분할하고 트래픽의 절반을 로 보내고 <code class="language-plaintext highlighter-rouge">v1</code>나머지 절반을 로 보내는 라우팅 정책으로 이를 살펴보겠습니다 <code class="language-plaintext highlighter-rouge">v2</code>.</li>
</ul>

<p>We will modify our <strong><code class="language-plaintext highlighter-rouge">HTTPRoute</code></strong> to accomplish this by removing the header-based routing rule that drove our dark launch. Then we will <strong>replace</strong> that with a <strong>50-50 <code class="language-plaintext highlighter-rouge">weight</code></strong> applied to each of the routes, as shown below:</p>

<p><img src="/assets/2024/kans-3th/w6/20241012_kans_w6_28.png" alt="img.png" loading="lazy" width="999" height="563"></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  rules:
    - matches:
      - path:
          <span class="nb">type</span>: PathPrefix
          value: /api/my-workload
      <span class="c"># Configure a 50-50 traffic split across v1 and v2 : 버전 1,2 50:50 비율</span>
      backendRefs:
        - name: my-workload-v1
          namespace: my-workload
          port: 8080
          weight: 50
        - name: my-workload-v2
          namespace: my-workload
          port: 8080
          weight: 50
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Apply this 50-50 routing policy with kubectl:</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/solo-io/gloo-gateway-use-cases/main/gateway-api-tutorial/09-workload-route-split.yaml
<span class="c"># =&gt; httproute.gateway.networking.k8s.io/my-workload configured</span>

<span class="c">#</span>
<span class="nv">$ </span>kubectl describe httproute <span class="nt">-n</span> my-workload
<span class="c"># =&gt; Spec:</span>
<span class="c">#      ...</span>
<span class="c">#      Rules:</span>
<span class="c">#        Backend Refs:</span>
<span class="c">#          Group:</span>
<span class="c">#          Kind:       Service</span>
<span class="c">#          Name:       my-workload-v1</span>
<span class="c">#          Namespace:  my-workload</span>
<span class="c">#          Port:       8080</span>
<span class="c">#          Weight:     50</span>
<span class="c">#          Group:</span>
<span class="c">#          Kind:       Service</span>
<span class="c">#          Name:       my-workload-v2</span>
<span class="c">#          Namespace:  my-workload</span>
<span class="c">#          Port:       8080</span>
<span class="c">#          Weight:     50</span>
<span class="c">#        Matches:</span>
<span class="c">#          Path:</span>
<span class="c">#            Type:   PathPrefix</span>
<span class="c">#            Value:  /api/my-workload</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 반복 접속 후 대략 비률 확인</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/my-workload/ | <span class="nb">grep </span>body<span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;   51   &amp;quot;body&amp;quot;: &amp;quot;Hello From My Workload (v1)!&amp;quot;,</span>
<span class="c">#      49   &amp;quot;body&amp;quot;: &amp;quot;Hello From My Workload (v2)!&amp;quot;,</span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..200<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/my-workload/ | <span class="nb">grep </span>body<span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;  116   &amp;quot;body&amp;quot;: &amp;quot;Hello From My Workload (v1)!&amp;quot;,</span>
<span class="c">#      84   &amp;quot;body&amp;quot;: &amp;quot;Hello From My Workload (v2)!&amp;quot;,</span>
</code></pre></div></div>

<h5 id="debug">Debug</h5>

<p><strong>Solve a Problem with Glooctl CLI</strong></p>

<p>A common source of Gloo configuration <strong>errors</strong> is <strong>mistyping</strong> an upstream reference, perhaps when copy/pasting it from another source but “missing a spot” when changing the name of the backend service target. In this example, we’ll simulate making an error like that, and then demonstrating how <code class="language-plaintext highlighter-rouge">glooctl</code> can be used to detect it.</p>

<ul>
  <li>Gloo 구성 오류의 일반적인 원인은 <strong>업스트림 참조를 잘못 입력</strong>하는 것입니다. 아마도 다른 소스에서 복사/붙여넣을 때이지만 백엔드 서비스 대상의 이름을 변경할 때 “한 군데를 놓친” 것입니다. 이 예에서 우리는 그런 오류를 만드는 것을 시뮬레이션하고, <code class="language-plaintext highlighter-rouge">glooctl</code>그것을 감지하는 데 어떻게 사용할 수 있는지 보여줍니다.</li>
</ul>

<p><strong>First</strong>, let’s apply a change to simulate the <strong>mistyping</strong> of an upstream config so that it is targeting a <strong>non-existent <code class="language-plaintext highlighter-rouge">my-bad-workload-v2</code></strong> backend service, rather than the correct <strong><code class="language-plaintext highlighter-rouge">my-workload-v2</code></strong>.</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">my-bad-workload-v2</code> 업스트림 구성의 오타를 시뮬레이션하여 올바른 타겟팅하는 대신 존재하지 않는 백엔드 서비스를 타겟팅하도록 변경</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># [신규 터미널] 모니터링</span>
<span class="nv">$ </span>kubectl get httproute <span class="nt">-n</span> my-workload my-workload <span class="nt">-o</span> yaml <span class="nt">-w</span>

<span class="c">#</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/solo-io/gloo-gateway-use-cases/main/gateway-api-tutorial/10-workload-route-split-bad-dest.yaml
<span class="c"># =&gt; httproute.gateway.networking.k8s.io/my-workload configured</span>

<span class="c">#</span>
<span class="nv">$ </span>kubectl describe httproute <span class="nt">-n</span> my-workload
<span class="c"># =&gt; ...</span>
<span class="c">#    Spec:</span>
<span class="c">#      Rules:</span>
<span class="c">#        Backend Refs:</span>
<span class="c">#          Group:</span>
<span class="c">#          Kind:       Service</span>
<span class="c">#          Name:       my-workload-v1</span>
<span class="c">#          Namespace:  my-workload</span>
<span class="c">#          Port:       8080</span>
<span class="c">#          Weight:     50</span>
<span class="c">#          Group:</span>
<span class="c">#          Kind:       Service</span>
<span class="c">#          Name:       my-bad-workload-v2</span>
<span class="c">#          Namespace:  my-workload</span>
<span class="c">#          Port:       8080</span>
<span class="c">#          Weight:     50</span>
<span class="c">#        Matches:</span>
<span class="c">#          Path:</span>
<span class="c">#            Type:   PathPrefix</span>
<span class="c">#            Value:  /api/my-workload</span>
<span class="c">#    Status:</span>
<span class="c">#      Parents:</span>
<span class="c">#        Conditions:</span>
<span class="c">#          Last Transition Time:  2024-10-12T16:55:06Z</span>
<span class="c">#          Message:               Service &amp;quot;my-bad-workload-v2&amp;quot; not found</span>
<span class="c">#          Observed Generation:   4</span>
<span class="c">#          Reason:                BackendNotFound</span>
<span class="c">#          Status:                False</span>
<span class="c">#          Type:                  ResolvedRefs</span>
<span class="c">#          Last Transition Time:  2024-10-12T16:45:41Z</span>
<span class="c">#          Message:</span>
<span class="c">#          Observed Generation:   4</span>
<span class="c">#          Reason:                Accepted</span>
<span class="c">#          Status:                True</span>
<span class="c">#          Type:                  Accepted</span>
<span class="c">#        Controller Name:         solo.io/gloo-gateway</span>
<span class="c">#        Parent Ref:</span>
<span class="c">#          Group:      gateway.networking.k8s.io</span>
<span class="c">#          Kind:       Gateway</span>
<span class="c">#          Name:       http</span>
<span class="c">#          Namespace:  gloo-system</span>
<span class="c">#    Events:           &amp;lt;none&amp;gt;</span>
</code></pre></div></div>

<p>When we test this out, note that the 50-50 traffic split is still in place. This means that about half of the requests will be routed to <code class="language-plaintext highlighter-rouge">my-workload-v1</code> and succeed, while the others will attempt to use the non-existent <code class="language-plaintext highlighter-rouge">my-bad-workload-v2</code> and fail like this:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/my-workload
<span class="c"># =&gt; HTTP/1.1 500 Internal Server Error</span>
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/my-workload
<span class="c"># =&gt; HTTP/1.1 200 OK</span>
<span class="c">#    vary: Origin</span>
<span class="c">#    date: Sat, 12 Oct 2024 16:56:37 GMT</span>
<span class="c">#    content-length: 292</span>
<span class="c">#    content-type: text/plain; charset=utf-8</span>
<span class="c">#    x-envoy-upstream-service-time: 5</span>
<span class="c">#    server: envoy</span>
<span class="c">#    ...</span>

<span class="c"># </span>
<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/my-workload/ | <span class="nb">grep </span>body<span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="nb">sort</span> <span class="nt">-nr</span>
<span class="c"># =&gt;   55   &amp;quot;body&amp;quot;: &amp;quot;Hello From My Workload (v1)!&amp;quot;,</span>

<span class="c"># &lt;span style="color: green;"&gt;👉 디버깅 테스트를 위해 일부러 50%의 워크로드에는 오타를 내어서&lt;/span&gt;</span>
<span class="c"># &lt;span style="color: green;"&gt;    50%의 요청은 v1로 라우팅되어 성공하고 나머지 50%는 실패합니다.&lt;/span&gt;</span>
</code></pre></div></div>

<p>So we’ll deploy one of the first weapons from the Gloo debugging arsenal, the <code class="language-plaintext highlighter-rouge">glooctl check</code> utility. It verifies a number of Gloo resources, confirming that they are configured correctly and are interconnected with other resources correctly. For example, in this case, <code class="language-plaintext highlighter-rouge">glooctl</code> will detect the error in the mis-connection between the <code class="language-plaintext highlighter-rouge">HTTPRoute</code> and its backend target:</p>

<ul>
  <li>gloo에서 제공하는 <code class="language-plaintext highlighter-rouge">glooctl check</code> 명령으로 구성 오류를 확인합니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> myk8s-control-plane bash
<span class="c"># -----------------------------------</span>
<span class="nv">$ </span><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$HOME</span>/.gloo/bin:<span class="nv">$PATH</span>
<span class="nv">$ </span>glooctl check
<span class="c"># =&gt; ...</span>
<span class="c">#    Checking Gateways... OK</span>
<span class="c">#    Checking Proxies... 1 Errors!</span>
<span class="c">#    </span>
<span class="c">#    Detected Kubernetes Gateway integration!</span>
<span class="c">#    Checking Kubernetes GatewayClasses... OK</span>
<span class="c">#    Checking Kubernetes Gateways... OK</span>
<span class="c">#    Checking Kubernetes HTTPRoutes... 1 Errors!</span>
<span class="c">#    </span>
<span class="c">#    Skipping Gloo Instance check -- Gloo Federation not detected.</span>
<span class="c">#    Error: 2 errors occurred:</span>
<span class="c">#     * Found proxy with warnings by 'gloo-system': gloo-system gloo-system-http</span>
<span class="c">#    Reason: warning:</span>
<span class="c">#      Route Warning: InvalidDestinationWarning. Reason: invalid destination in weighted destination list: *v1.Upstream { blackhole_ns.kube-svc:blackhole-ns-blackhole-cluster-8080 } not found</span>
<span class="c">#    </span>
<span class="c">#     * HTTPRoute my-workload.my-workload.http status (ResolvedRefs) is not set to expected (True). Reason: BackendNotFound, Message: Service &amp;quot;my-bad-workload-v2&amp;quot; not found</span>

<span class="c"># 원인 관련 정보 확인</span>
<span class="nv">$ </span>kubectl get httproute my-workload <span class="nt">-n</span> my-workload <span class="nt">-o</span> yaml
<span class="c"># =&gt; ...</span>
<span class="c">#    status:</span>
<span class="c">#      parents:</span>
<span class="c">#      - conditions:</span>
<span class="c">#        - lastTransitionTime: &amp;quot;2024-10-12T16:55:06Z&amp;quot;</span>
<span class="c">#          message: Service &amp;quot;my-bad-workload-v2&amp;quot; not found</span>
<span class="c">#          observedGeneration: 4</span>
<span class="c">#          reason: BackendNotFound</span>
<span class="c">#          status: &amp;quot;False&amp;quot;</span>
<span class="c">#          type: ResolvedRefs</span>
<span class="c">#          ...</span>

<span class="c"># 정상 설정으로 해결 configuration is again clean.</span>
<span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/solo-io/gloo-gateway-use-cases/main/gateway-api-tutorial/09-workload-route-split.yaml
<span class="c"># =&gt; httproute.gateway.networking.k8s.io/my-workload configured</span>
<span class="nv">$ </span>kubectl get httproute my-workload <span class="nt">-n</span> my-workload <span class="nt">-o</span> yaml

<span class="c">#</span>
<span class="nv">$ </span>glooctl check
<span class="c"># =&gt; Checking Deployments... OK</span>
<span class="c">#    Checking Pods... OK</span>
<span class="c">#    Checking Upstreams... OK</span>
<span class="c">#    Checking UpstreamGroups... OK</span>
<span class="c">#    Checking AuthConfigs... OK</span>
<span class="c">#    Checking RateLimitConfigs... OK</span>
<span class="c">#    Checking VirtualHostOptions... OK</span>
<span class="c">#    Checking RouteOptions... OK</span>
<span class="c">#    Checking Secrets... OK</span>
<span class="c">#    Checking VirtualServices... OK</span>
<span class="c">#    Checking Gateways... OK</span>
<span class="c">#    Checking Proxies... OK</span>
<span class="c">#    </span>
<span class="c">#    Detected Kubernetes Gateway integration!</span>
<span class="c">#    Checking Kubernetes GatewayClasses... OK</span>
<span class="c">#    Checking Kubernetes Gateways... OK</span>
<span class="c">#    Checking Kubernetes HTTPRoutes... OK</span>
<span class="c">#    </span>
<span class="c">#    Skipping Gloo Instance check -- Gloo Federation not detected.</span>
<span class="c">#    No problems detected.</span>
<span class="c"># &lt;span style="color: green;"&gt;👉 이제 문제가 없다고 합니다. 😀&lt;/span&gt;</span>
</code></pre></div></div>

<h5 id="observe">Observe</h5>

<p><strong>Explore Envoy Metrics</strong></p>

<p><strong>Envoy</strong> publishes a host of <strong>metrics</strong> that may be useful for observing system behavior. In our very modest kind cluster for this exercise, you can count over <strong>3,000 individual metrics</strong>! You can learn more about them in the Envoy documentation <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/upstream/cluster_manager/cluster_stats">here</a>.</p>

<p>For this 30-minute exercise, let’s take a quick look at a couple of the useful metrics that Envoy produces for every one of our backend targets.</p>

<p>First, we’ll <strong>port-forward</strong> the <strong>Envoy</strong> <strong>administrative</strong> <strong>port</strong> <strong>19000</strong> to our local workstation:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="nv">$ </span>kubectl <span class="nt">-n</span> gloo-system port-forward deployment/gloo-proxy-http 19000 &amp;

<span class="c"># 아래 관리 페이지에서 각각 메뉴 링크 클릭 확인</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"Envoy Proxy Admin - http://localhost:19000"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"Envoy Proxy Admin - http://localhost:19000/stats/prometheus"</span>tZBli7jsXv<span class="s1">'XALZnaKnB2MSBvJNI
</span></code></pre></div></div>

<p>For this exercise, let’s view <strong>two</strong> of the relevant <strong>metrics</strong> from the first part of this exercise: one that counts the <strong>number</strong> of <strong>successful</strong> (HTTP 2xx) requests processed by our <code class="language-plaintext highlighter-rouge">httpbin</code> backend (or <strong><code class="language-plaintext highlighter-rouge">cluster</code></strong>, in Envoy terminology), and another that <strong>counts</strong> the number of requests <strong>returning</strong> server errors (HTTP <strong>5xx</strong>) from that same backend:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 2xx, 5xx 요청 확인</span>
<span class="nv">$ </span>curl <span class="nt">-s</span> http://localhost:19000/stats | <span class="nb">grep</span> <span class="nt">-E</span> <span class="s2">"(^cluster.kube-svc_httpbin-httpbin-8000_httpbin.upstream.*(2xx|5xx))"</span>
<span class="c"># =&gt; cluster.kube-svc_httpbin-httpbin-8000_httpbin.upstream_rq_2xx: 7</span>

<span class="c"># If we apply a curl request that forces a 500 failure from the httpbin backend, using the /status/500 endpoint, I’d expect the number of 2xx requests to remain the same, and the number of 5xx requests to increment by one:</span>
<span class="nv">$ </span>curl <span class="nt">-is</span> <span class="nt">-H</span> <span class="s2">"Host: api.example.com"</span> http://localhost:8080/api/httpbin/status/500
<span class="c"># =&gt; HTTP/1.1 500 Internal Server Error</span>
<span class="c">#    server: envoy</span>
<span class="c">#    date: Sat, 12 Oct 2024 17:02:53 GMT</span>
<span class="c">#    content-type: text/html; charset=utf-8</span>
<span class="c">#    access-control-allow-origin: *</span>
<span class="c">#    access-control-allow-credentials: true</span>
<span class="c">#    content-length: 0</span>
<span class="c">#    x-envoy-upstream-service-time: 38</span>

<span class="c"># 500에러를 발생시키자 500에러가 1개 증가하고 2xx는 변화가 없습니다.</span>
<span class="nv">$ </span>curl <span class="nt">-s</span> http://localhost:19000/stats | <span class="nb">grep</span> <span class="nt">-E</span> <span class="s2">"(^cluster.kube-svc_httpbin-httpbin-8000_httpbin.upstream.*(2xx|5xx))"</span>
<span class="c"># =&gt; cluster.kube-svc_httpbin-httpbin-8000_httpbin.upstream_rq_2xx: 7</span>
<span class="c">#    cluster.kube-svc_httpbin-httpbin-8000_httpbin.upstream_rq_5xx: 1</span>
</code></pre></div></div>

<h5 id="정리">정리</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kind delete cluster <span class="nt">--name</span> myk8s
<span class="c"># =&gt; Deleted nodes: [&amp;quot;myk8s-control-plane&amp;quot;]</span>
</code></pre></div></div>

<h3 id="기타-gateway-api-구현체">기타 Gateway API 구현체</h3>

<ul>
  <li>
    <dl>
      <dt><strong><code class="language-plaintext highlighter-rouge">Cilium</code></strong></dt>
      <dd>Cilium은 CNI로 알려져있지만 Gateway API 역할도 지원합니다.</dd>
    </dl>
    <ul>
      <li><strong>(참고) [OnlineLab] Cilium Gateway API - <a href="https://isovalent.com/labs/cilium-gateway-api/">Link</a></strong></li>
      <li><strong>(참고) [OnlineLab] Advanced Gateway API Use Cases - <a href="https://isovalent.com/labs/cilium-gateway-api-advanced/">Link</a></strong></li>
    </ul>
  </li>
  <li>
    <dl>
      <dt><strong><code class="language-plaintext highlighter-rouge">Istio</code></strong></dt>
      <dd>Istio는 Service Mesh로 알려져있지만 Gateway API 역할도 지원합니다. Gateway API 자체가 Service Mesh인 Istio 등을 참조하였기에 어찌보면 당연한 일입니다.</dd>
    </dl>
    <ul>
      <li>Kubernetes Traffic Management: Combining Gateway API with Service Mesh for North-South and East-West Use Cases - <a href="https://medium.com/@disha.20.10/kubernetes-traffic-management-combining-gateway-api-with-service-mesh-for-north-south-and-63e39ad95dcc">Blog</a>
</li>
      <li>Istio Gateway API 활용하기 <a href="https://devops-james.tistory.com/317">https://devops-james.tistory.com/317</a>
</li>
    </ul>
  </li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">Kong API Gateway</code></strong>
    <ul>
      <li>Kong API Gateway 를 Gateway API 형태 설치 <a href="https://mokpolar.tistory.com/68">https://mokpolar.tistory.com/68</a>
</li>
    </ul>
  </li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">Envoy Gateway</code></strong>
    <ul>
      <li>Envoy Gateway 사용하여 + 부하분산 <a href="https://devops-james.tistory.com/320">https://devops-james.tistory.com/320</a>
</li>
    </ul>
  </li>
</ul>

<hr>

<h2 id="마치며">마치며</h2>

<p>파드 통신에서 부터 CNI, 서비스(ClusterIP, NodePort, LoadBalancer)를 거쳐, ingress, gateway api까지 왔습니다.
나중에 배운 기술이 이전 기술을 필요없게 만드는 부분도 있지만, 기초의 중요성을 알기에 더욱 중요하다고 생각합니다.</p>

<p>그런데 gateway api를 만들면서 ingress를 frozen 하게 된것은 살짝 충격적입니다.
ingress를 없앤다는 얘기는 없지만 결국 gateway api가 더 좋은 기술이고, 
ingress는 점점 점유율을 잃다가 조용히 deprecated 될것 같은 느낌입니다.
ingress가 심심하지 않도록 더 자주 써줘야겠습니다.</p>

<p>이번주는 특히나 실습이 많았던것 같은데, 다른 분들도 다들 잘 생존했으면 좋겠습니다.
(일단 저부터 스터디에서 생존하기를 빕니다.. <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20" loading="lazy">)</p>

  </div>

  <div id="toc-minimap" class="toc-minimap collapsed">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0">들어가며</a></li>
<li class="toc-entry toc-h2">
<a href="#ingress">Ingress</a>
<ul>
<li class="toc-entry toc-h3"><a href="#ingress%EB%9E%80">Ingress란?</a></li>
<li class="toc-entry toc-h3"><a href="#ingress-controller%EC%9D%98-%EC%A2%85%EB%A5%98">Ingress Controller의 종류</a></li>
<li class="toc-entry toc-h3">
<a href="#%EC%8B%A4%EC%8A%B5-%ED%99%98%EA%B2%BD-%EC%A4%80%EB%B9%84">실습 환경 준비</a>
<ul>
<li class="toc-entry toc-h4"><a href="#k3s-%ED%8A%B9%EC%A7%95">k3s 특징</a></li>
<li class="toc-entry toc-h4"><a href="#k3s%EC%9D%98-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90">k3s의 아키텍쳐</a></li>
<li class="toc-entry toc-h4"><a href="#k3s-%EC%84%A4%EC%B9%98">k3s 설치</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#nginx-ingress-controller-%EC%84%A4%EC%B9%98">Nginx Ingress Controller 설치</a></li>
<li class="toc-entry toc-h3">
<a href="#%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4ingress-%EC%8B%A4%EC%8A%B5-%EB%B0%8F-%ED%86%B5%EC%8B%A0-%ED%9D%90%EB%A6%84-%ED%99%95%EC%9D%B8">인그레스(Ingress) 실습 및 통신 흐름 확인</a>
<ul>
<li class="toc-entry toc-h4"><a href="#deployment%EC%99%80-service-%EC%83%9D%EC%84%B1">deployment와 service 생성</a></li>
<li class="toc-entry toc-h4"><a href="#%EC%9D%B8%EA%B7%B8%EB%A0%88%EC%8A%A4%EC%A0%95%EC%B1%85-%EC%83%9D%EC%84%B1">인그레스(정책) 생성</a></li>
<li class="toc-entry toc-h4"><a href="#ingress%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%82%B4%EB%B6%80-%EC%A0%91%EC%86%8D">ingress를 통한 내부 접속</a></li>
<li class="toc-entry toc-h4"><a href="#%ED%8C%A8%ED%82%B7-%EB%B6%84%EC%84%9D">패킷 분석</a></li>
<li class="toc-entry toc-h4"><a href="#nginx-%EB%B6%84%EC%82%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B3%80%EA%B2%BD">Nginx 분산 알고리즘 변경</a></li>
<li class="toc-entry toc-h4"><a href="#host-%EA%B8%B0%EB%B0%98-%EB%9D%BC%EC%9A%B0%ED%8C%85">Host 기반 라우팅</a></li>
<li class="toc-entry toc-h4"><a href="#%EC%B9%B4%EB%82%98%EB%A6%AC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8">카나리 업데이트</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#gateway-api">Gateway API</a>
<ul>
<li class="toc-entry toc-h3"><a href="#gateway-api-%EC%86%8C%EA%B0%9C">Gateway API 소개</a></li>
<li class="toc-entry toc-h3">
<a href="#gloo-gateway">Gloo Gateway</a>
<ul>
<li class="toc-entry toc-h4"><a href="#gloo-gateway-architecture">Gloo Gateway Architecture</a></li>
<li class="toc-entry toc-h4"><a href="#%EC%8B%A4%EC%8A%B5">실습</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#%EA%B8%B0%ED%83%80-gateway-api-%EA%B5%AC%ED%98%84%EC%B2%B4">기타 Gateway API 구현체</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
</ul>
  </div>
<a class="u-url" href="/posts/2024-10-13-KANS-Study-Week6/" hidden></a>
</article>



<div class="PageNavigation">
  
  <a class="prev" href="/posts/2024-10-05-KANS-Study-Week5/">« [KANS 3기] LoadBalancer(MetalLB), IPVS</a>
  
  
  <a class="next" href="/posts/2024-10-19-KANS-Study-Week7/">[KANS 3기] Service Mesh : Istio - Mode (Sidecar, Ambient) »</a>
  
</div>

<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = "https://sweetlittlebird.github.io/posts/2024-10-13-KANS-Study-Week6/";
this.page.identifier = "/posts/KANS Study - Week6";
};
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
      </div>

<!--      <div class="adsbygoogle-side">-->
<!--        &lt;!&ndash; ad_side &ndash;&gt;-->
<!--        <ins class="adsbygoogle "-->
<!--             style="display: block"-->
<!--             data-ad-client="ca-pub-6564723532026864"-->
<!--             data-ad-slot="1339398797"-->
<!--             data-ad-format="auto"-->
<!--             data-full-width-responsive="true"></ins>-->
<!--      </div>-->
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Sweet Little Bird</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Sweet Little Bird</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/sweetlittlebird"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">sweetlittlebird</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>공부 기록과 개발 이야기를 담은 블로그입니다.</p>
      </div>
    </div>

  </div>

</footer>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
      <!-- Background of PhotoSwipe. 
           It's a separate element as animating opacity is faster than rgba(). -->
      <div class="pswp__bg"></div>
      <!-- Slides wrapper with overflow:hidden. -->
      <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
          <div class="pswp__item"></div>
          <div class="pswp__item"></div>
          <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
          <div class="pswp__top-bar">
            <!--  Controls are self-explanatory. Order can be changed. -->
            <div class="pswp__counter"></div>
            <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
            <button class="pswp__button pswp__button--share" title="Share"></button>
            <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
            <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
            <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
            <!-- element will get class pswp__preloader--active when preloader is running -->
            <div class="pswp__preloader">
              <div class="pswp__preloader__icn">
                <div class="pswp__preloader__cut">
                  <div class="pswp__preloader__donut"></div>
                </div>
              </div>
            </div>
          </div>
          <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
            <div class="pswp__share-tooltip"></div>
          </div>
          <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
          </button>
          <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
          </button>
          <div class="pswp__caption">
            <div class="pswp__caption__center"></div>
          </div>
        </div>
      </div>
    </div>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-EWGY9N8QXY"></script>

    
    <script async src="/assets/dist/app.min.js"></script>
    
  
    <a href="#" id="back-to-top"><span>Back to Top</span></a>

<!--    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6564723532026864"-->
<!--            crossorigin="anonymous"></script>-->
<!--    <script>-->
<!--    (adsbygoogle = window.adsbygoogle || []).push({});-->
<!--    </script>-->
  </body>

</html>
